<head>
  <meta charset="UTF-8">
</head>
<body>
  <h2 id="niem-logo"><img src="https://github.com/niemopen/oasis-open-project/raw/main/artwork/NIEM-NO-Logo-v5.png" alt="NIEM Logo" style="width: 400px; display: block; margin: 0;"</h2>

  <!--
  If you want to check the line length in code blocks, uncomment this code block,
  set the width of your markdown preview window so that the following line does not wrap,
  and the final "X" is visible without the horizontal scrollbar:

  ```
  .........1.........2.........3.........4.........5.........6.........7.........8.........9.........0.........1.........2.........3......X
  This is the width of a code block in the PDF version
  ```
  -->

  <h1 id="niem-naming-and-design-rules-ndr-version-60">NIEM Naming and
  Design Rules (NDR) Version 6.0</h1>
  <h2 id="project-specification-01">Project Specification 01</h2>
  <h2 id="25-july-2025-draft">25 July 2025 draft</h2>
  <p> </p>
  <h4 id="this-stage">This stage:</h4>
  <p><a href="https://docs.oasis-open.org/niemopen/ndr/v6.0/ps01/ndr-v6.0-ps01.html">https://docs.oasis-open.org/niemopen/ndr/v6.0/ps01/ndr-v6.0-ps01.html</a><br />
  <a href="https://docs.oasis-open.org/niemopen/ndr/v6.0/ps01/ndr-v6.0-ps01.pdf">https://docs.oasis-open.org/niemopen/ndr/v6.0/ps01/ndr-v6.0-ps01.pdf</a>
  (Authoritative)</p>
  <h4 id="previous-stage">Previous stage:</h4>
  <p><a href="https://docs.oasis-open.org/niemopen/ndr/v6.0/psd01/ndr-v6.0-psd01.html">https://docs.oasis-open.org/niemopen/ndr/v6.0/psd01/ndr-v6.0-psd01.html</a><br />
  <a href="https://docs.oasis-open.org/niemopen/ndr/v6.0/psd01/ndr-v6.0-psd01.pdf">https://docs.oasis-open.org/niemopen/ndr/v6.0/psd01/ndr-v6.0-psd01.pdf</a>
  (Authoritative)</p>
  <h4 id="latest-stage">Latest stage:</h4>
  <p><a href="https://docs.oasis-open.org/niemopen/ndr/v6.0/ndr-v6.0.html">https://docs.oasis-open.org/niemopen/ndr/v6.0/ndr-v6.0.html</a><br />
  <a href="https://docs.oasis-open.org/niemopen/ndr/v6.0/ndr-v6.0.pdf">https://docs.oasis-open.org/niemopen/ndr/v6.0/ndr-v6.0.pdf</a>
  (Authoritative)</p>
  <h4 id="open-project">Open Project:</h4>
  <p><a href="http://www.niemopen.org/">OASIS NIEMOpen OP</a></p>
  <h4 id="project-chair">Project Chair:</h4>
  <p>Katherine Escobar (katherine.b.escobar.civ@mail.mil), <a
  href="https://www.jcs.mil/Directorates/J6-C4-Cyber/">Joint Staff
  J6</a></p>
  <h4 id="ntac-technical-steering-committee-chairs">NTAC Technical
  Steering Committee Chairs:</h4>
  <p>Brad Bolliger (brad.bolliger@ey.com), <a href="ey.com">EY</a><br />
  James Cabral (jim@cabral.org), Individual<br />
  Scott Renner (sar@mitre.org), <a
  href="https://mitre.org/">MITRE</a></p>
  <h4 id="editors">Editors:</h4>
  <p>James Cabral (jim@cabral.org), Individual<br />
  Tom Carlson (Thomas.Carlson@gtri.gatech.edu), <a
  href="https://gtri.gatech.edu/">Georgia Tech Research
  Institute</a><br />
  Scott Renner (sar@mitre.org), <a
  href="https://mitre.org/">MITRE</a></p>
  <h4 id="related-work">Related work:</h4>
  <p>This specification replaces or supersedes:</p>
  <ul>
  <li><em>National Information Exchange Model Naming and Design
  Rules</em>. Version 5.0 December 18, 2020. NIEM Technical Architecture
  Committee (NTAC).
  <a href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html">https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html</a>.</li>
  </ul>
  <p>This specification is related to:</p>
  <ul>
  <li><p><em>NIEM Model Version 6.0</em>. Edited by Christina
  Medlin.<br />
  Latest stage:
  <a href="https://docs.oasis-open.org/niemopen/niem-model/v6.0/niem-model-v6.0.html">https://docs.oasis-open.org/niemopen/niem-model/v6.0/niem-model-v6.0.html</a>.</p></li>
  <li><p>Conformance Targets Attribute Specification (CTAS) Version 3.0.
  Edited by Tom Carlson. 22 February 2023. OASIS Project Specification
  01.
  <a href="https://docs.oasis-open.org/niemopen/ctas/v3.0/ps01/ctas-v3.0-ps01.html.">https://docs.oasis-open.org/niemopen/ctas/v3.0/ps01/ctas-v3.0-ps01.html.</a><br />
  Latest stage:
  <a href="https://docs.oasis-open.org/niemopen/ctas/v3.0/ctas-v3.0.html">https://docs.oasis-open.org/niemopen/ctas/v3.0/ctas-v3.0.html</a>.</p></li>
  </ul>
  <h4 id="abstract">Abstract:</h4>
  <p>NIEM is a framework for scalable and reusable data exchange across
  public and private sectors. It provides the tools and standards
  necessary for organizations to define structured data contracts,
  enabling machine-to-machine communication across diverse use cases
  like web services and APIs.</p>
  <p>This document provides the normative specifications for creating
  data models, namespaces, schemas, and messages that conform to the
  NIEM framework. It defines enforceable rules for naming conventions,
  documentation, structural integrity, and conformance targets. The
  document outlines how developers can use NIEM to define structured
  data contracts, specifying syntax, semantics, and relationships for
  machine-to-machine communication.</p>
  <h4 id="status">Status:</h4>
  <p>This document was last revised or approved by the Project Governing
  Board of the OASIS NIEMOpen OP on the above date. The level of
  approval is also listed above. Check the "Latest stage" location noted
  above for possible later revisions of this document. Any other
  numbered Versions and other technical work produced by the Open
  Project (OP) are listed at http://www.niemopen.org/.</p>
  <p>Comments on this work can be provided by opening issues in the
  project repository or by sending email to the project’s public comment
  list: niemopen@lists.oasis-open-projects.org. List information is
  available at https://lists.oasis-open-projects.org/g/niemopen.</p>
  <p>Note that any machine-readable content (<a
  href="https://www.oasis-open.org/policies-guidelines/tc-process-2017-05-26/#wpComponentsCompLang">Computer
  Language Definitions</a>) declared Normative for this Work Product is
  provided in separate plain text files. In the event of a discrepancy
  between any such plain text file and display content in the Work
  Product's prose narrative document(s), the content in the separate
  plain text file prevails.</p>
  <h4 id="key-words">Key words:</h4>
  <p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
  "OPTIONAL" in this document are to be interpreted as described in
  <a href="#bcp14"><b>[BCP14]</b></a>: <a href="#rfc-2119"><b>[RFC
  2119]</b></a> and <a href="#rfc-8174"><b>[RFC 8174]</b></a> when, and
  only when, they appear in all capitals, as shown here.</p>
  <h4 id="citation-format">Citation format:</h4>
  <p>When referencing this specification the following citation format
  should be used:</p>
  <p><strong>[NIEM-NDR-v6.0]</strong></p>
  <p><em>NIEM Naming and Design Rules (NDR) Version 6.0</em>. Edited by
  Scott Renner. DATE-TODO. OASIS Project Specification 01.<br />
  <a href="https://docs.oasis-open.org/niemopen/ndr/v6.0/psd01/ndr-v6.0-ps01.html">https://docs.oasis-open.org/niemopen/ndr/v6.0/psd01/ndr-v6.0-ps01.html</a>.<br />
  Latest stage:
  <a href="https://docs.oasis-open.org/niemopen/ndr/v6.0/ndr-v6.0.html">https://docs.oasis-open.org/niemopen/ndr/v6.0/ndr-v6.0.html</a>.</p>
  <hr />
  <h2 id="notices">Notices</h2>
  <p>Copyright © OASIS Open 2025. All Rights Reserved.</p>
  <p>Distributed under the terms of the OASIS <a
  href="https://www.oasis-open.org/policies-guidelines/ipr/">IPR
  Policy</a>.</p>
  <p>For complete copyright information please see the Notices section
  in the Appendix.</p>
  <hr />
  <h1 id="table-of-contents">Table of Contents</h1>
  <tocHere/>
<nav id="TOC">
<ul>
<li><a href="#1-introduction" id="toc-1-introduction">1.
Introduction</a>
<ul>
<li><a href="#11-glossary" id="toc-11-glossary">1.1 Glossary</a>
<ul>
<li><a href="#111-definitions-of-terms"
id="toc-111-definitions-of-terms">1.1.1 Definitions of terms</a></li>
<li><a href="#112-acronyms-and-abbreviations"
id="toc-112-acronyms-and-abbreviations">1.1.2 Acronyms and
abbreviations</a></li>
</ul></li>
</ul></li>
<li><a href="#2-how-to-read-this-document"
id="toc-2-how-to-read-this-document">2. How To Read This Document</a>
<ul>
<li><a href="#21-document-references"
id="toc-21-document-references">2.1 Document references</a></li>
<li><a href="#22-clark-notation-and-qualified-names"
id="toc-22-clark-notation-and-qualified-names">2.2 Clark notation and
qualified names</a></li>
<li><a href="#23-use-of-namespaces-and-namespace-prefixes"
id="toc-23-use-of-namespaces-and-namespace-prefixes">2.3 Use of
namespaces and namespace prefixes</a></li>
</ul></li>
<li><a href="#3-overview-of-the-niem-technical-architecture"
id="toc-3-overview-of-the-niem-technical-architecture">3. Overview of
the NIEM Technical Architecture</a>
<ul>
<li><a href="#31-machine-to-machine-data-specifications"
id="toc-31-machine-to-machine-data-specifications">3.1
Machine-to-machine data specifications</a>
<ul>
<li><a href="#311-messages" id="toc-311-messages">3.1.1
Messages</a></li>
<li><a href="#312-message-format" id="toc-312-message-format">3.1.2
Message format</a></li>
<li><a href="#313-message-type" id="toc-313-message-type">3.1.3 Message
type</a></li>
<li><a href="#314-message-specification"
id="toc-314-message-specification">3.1.4 Message specification</a></li>
</ul></li>
<li><a href="#32-reuse-of-community-agreed-data-models"
id="toc-32-reuse-of-community-agreed-data-models">3.2 Reuse of
community-agreed data models</a></li>
<li><a href="#33-reuse-of-open-standards"
id="toc-33-reuse-of-open-standards">3.3 Reuse of open standards</a></li>
<li><a href="#34-the-niem-metamodel" id="toc-34-the-niem-metamodel">3.4
The NIEM metamodel</a></li>
<li><a href="#35-niem-model-representations-xsd-and-cmf"
id="toc-35-niem-model-representations-xsd-and-cmf">3.5 NIEM model
representations: XSD and CMF</a></li>
<li><a href="#36-namespaces" id="toc-36-namespaces">3.6
Namespaces</a></li>
<li><a href="#37-model-extensions" id="toc-37-model-extensions">3.7
Model extensions</a></li>
<li><a href="#38-model-and-message-semantics"
id="toc-38-model-and-message-semantics">3.8 Model and message
semantics</a></li>
</ul></li>
<li><a href="#4-data-models-in-niem" id="toc-4-data-models-in-niem">4.
Data models in NIEM</a>
<ul>
<li><a href="#41-model" id="toc-41-model">4.1 Model</a></li>
<li><a href="#42-namespace" id="toc-42-namespace">4.2 Namespace</a></li>
<li><a href="#43-component" id="toc-43-component">4.3 Component</a></li>
<li><a href="#44-class" id="toc-44-class">4.4 Class</a></li>
<li><a href="#45-childpropertyassociation"
id="toc-45-childpropertyassociation">4.5
ChildPropertyAssociation</a></li>
<li><a href="#46-anypropertyassociation"
id="toc-46-anypropertyassociation">4.6 AnyPropertyAssociation</a></li>
<li><a href="#47-property" id="toc-47-property">4.7 Property</a></li>
<li><a href="#48-objectproperty" id="toc-48-objectproperty">4.8
ObjectProperty</a></li>
<li><a href="#49-dataproperty" id="toc-49-dataproperty">4.9
DataProperty</a></li>
<li><a href="#410-datatype" id="toc-410-datatype">4.10 Datatype</a></li>
<li><a href="#411-list" id="toc-411-list">4.11 List</a></li>
<li><a href="#412-union" id="toc-412-union">4.12 Union</a></li>
<li><a href="#413-restriction" id="toc-413-restriction">4.13
Restriction</a></li>
<li><a href="#414-facet" id="toc-414-facet">4.14 Facet</a></li>
<li><a href="#415-codelistbinding" id="toc-415-codelistbinding">4.15
CodeListBinding</a></li>
<li><a href="#416-augmentation-class"
id="toc-416-augmentation-class">4.16 Augmentation class</a>
<ul>
<li><a href="#4161-augmentations-in-cmf"
id="toc-4161-augmentations-in-cmf">4.16.1 Augmentations in CMF</a></li>
<li><a href="#4162-augmentations-in-xsd"
id="toc-4162-augmentations-in-xsd">4.16.2 Augmentations in XSD</a>
<ul>
<li><a href="#41621-attribute-augmentations-in-xsd"
id="toc-41621-attribute-augmentations-in-xsd">4.16.2.1 Attribute
augmentations in XSD</a></li>
<li><a
href="#41622-augmenting-one-object-class-or-association-class-with-an-element-property"
id="toc-41622-augmenting-one-object-class-or-association-class-with-an-element-property">4.16.2.2
Augmenting one object class or association class with an element
property</a></li>
<li><a
href="#41623-augmenting-every-object-class-or-association-class-with-an-element-property"
id="toc-41623-augmenting-every-object-class-or-association-class-with-an-element-property">4.16.2.3
Augmenting every object class or association class with an element
property</a></li>
<li><a
href="#41624-augmenting-a-literal-class-with-an-element-property-in-xsd"
id="toc-41624-augmenting-a-literal-class-with-an-element-property-in-xsd">4.16.2.4
Augmenting a literal class with an element property in XSD</a></li>
</ul></li>
</ul></li>
<li><a href="#417-localterm" id="toc-417-localterm">4.17
LocalTerm</a></li>
<li><a href="#418-texttype" id="toc-418-texttype">4.18 TextType</a></li>
</ul></li>
<li><a href="#5-data-modeling-patterns"
id="toc-5-data-modeling-patterns">5. Data modeling patterns</a>
<ul>
<li><a href="#51-datatypes-and-literal-classes"
id="toc-51-datatypes-and-literal-classes">5.1 Datatypes and literal
classes</a></li>
<li><a href="#52-metadata-and-augmentation"
id="toc-52-metadata-and-augmentation">5.2 Metadata and
augmentation</a></li>
<li><a href="#53-relationship-properties"
id="toc-53-relationship-properties">5.3 Relationship properties</a></li>
<li><a href="#54-roles" id="toc-54-roles">5.4 Roles</a></li>
<li><a href="#55-representation-pattern"
id="toc-55-representation-pattern">5.5 Representation pattern</a></li>
<li><a href="#56-container-objects" id="toc-56-container-objects">5.6
Container objects</a></li>
</ul></li>
<li><a href="#6-conformance" id="toc-6-conformance">6. Conformance</a>
<ul>
<li><a href="#61-conformance-targets"
id="toc-61-conformance-targets">6.1 Conformance targets</a>
<ul>
<li><a href="#611-namespace-conformance-target"
id="toc-611-namespace-conformance-target">6.1.1 Namespace conformance
target</a></li>
<li><a href="#612-schema-document-conformance-target"
id="toc-612-schema-document-conformance-target">6.1.2 Schema document
conformance target</a></li>
<li><a href="#613-model-conformance-target"
id="toc-613-model-conformance-target">6.1.3 Model conformance
target</a></li>
<li><a href="#614-message-conformance-target"
id="toc-614-message-conformance-target">6.1.4 Message conformance
target</a></li>
</ul></li>
<li><a href="#62-conformance-target-assertions"
id="toc-62-conformance-target-assertions">6.2 Conformance target
assertions</a></li>
<li><a href="#63-conformance-testing"
id="toc-63-conformance-testing">6.3 Conformance testing</a></li>
</ul></li>
<li><a href="#7-rules-for-model-components"
id="toc-7-rules-for-model-components">7. Rules for model components</a>
<ul>
<li><a href="#71-rules-for-component-names"
id="toc-71-rules-for-component-names">7.1 Rules for component names</a>
<ul>
<li><a href="#711-rules-based-on-kind-of-component"
id="toc-711-rules-based-on-kind-of-component">7.1.1 Rules based on kind
of component</a>
<ul>
<li><a href="#7111-rules-for-names-of-class-components"
id="toc-7111-rules-for-names-of-class-components">7.1.1.1 Rules for
names of Class components</a></li>
<li><a href="#7112-rules-for-names-of-datatype-components"
id="toc-7112-rules-for-names-of-datatype-components">7.1.1.2 Rules for
names of Datatype components</a></li>
<li><a href="#7113-rules-for-names-of-property-components"
id="toc-7113-rules-for-names-of-property-components">7.1.1.3 Rules for
names of Property components</a></li>
</ul></li>
<li><a href="#712-rules-for-composition-of-component-names"
id="toc-712-rules-for-composition-of-component-names">7.1.2 Rules for
composition of component names</a></li>
<li><a href="#713-general-component-naming-rules-from-iso-11179-5"
id="toc-713-general-component-naming-rules-from-iso-11179-5">7.1.3
General component naming rules from ISO 11179-5</a></li>
<li><a href="#714-property-naming-rules-from-iso-11179-5"
id="toc-714-property-naming-rules-from-iso-11179-5">7.1.4 Property
naming rules from ISO 11179-5</a>
<ul>
<li><a href="#7141-object-class-term"
id="toc-7141-object-class-term">7.1.4.1 Object-class term</a></li>
<li><a href="#7142-property-term" id="toc-7142-property-term">7.1.4.2
Property term</a></li>
<li><a href="#7143-qualifier-terms"
id="toc-7143-qualifier-terms">7.1.4.3 Qualifier terms</a></li>
<li><a href="#7144-representation-term"
id="toc-7144-representation-term">7.1.4.4 Representation term</a></li>
</ul></li>
<li><a href="#715-acronyms-abbreviations-and-jargon"
id="toc-715-acronyms-abbreviations-and-jargon">7.1.5 Acronyms,
abbreviations, and jargon</a></li>
</ul></li>
<li><a href="#72-rules-for-component-documentation"
id="toc-72-rules-for-component-documentation">7.2 Rules for component
documentation</a>
<ul>
<li><a href="#721-rules-for-documented-components"
id="toc-721-rules-for-documented-components">7.2.1 Rules for documented
components</a></li>
<li><a href="#722-rules-for-data-definitions"
id="toc-722-rules-for-data-definitions">7.2.2 Rules for data
definitions</a></li>
<li><a href="#723-data-definition-rules-from-iso-11179-4"
id="toc-723-data-definition-rules-from-iso-11179-4">7.2.3 Data
definition rules from ISO 11179-4</a></li>
<li><a href="#724-data-definition-opening-phrases"
id="toc-724-data-definition-opening-phrases">7.2.4 Data definition
opening phrases</a>
<ul>
<li><a href="#7241-opening-phrases-for-properties"
id="toc-7241-opening-phrases-for-properties">7.2.4.1 Opening phrases for
properties</a></li>
<li><a href="#7242-opening-phrases-for-classes"
id="toc-7242-opening-phrases-for-classes">7.2.4.2 Opening phrases for
classes</a></li>
</ul></li>
</ul></li>
<li><a href="#73-rules-for-specifications-of-components"
id="toc-73-rules-for-specifications-of-components">7.3 Rules for
specifications of components</a></li>
</ul></li>
<li><a href="#8-rules-for-namespaces" id="toc-8-rules-for-namespaces">8.
Rules for namespaces</a>
<ul>
<li><a href="#81-rules-for-properties-of-namespaces"
id="toc-81-rules-for-properties-of-namespaces">8.1 Rules for properties
of namespaces</a></li>
<li><a href="#82-rules-for-reference-namespaces"
id="toc-82-rules-for-reference-namespaces">8.2 Rules for reference
namespaces</a></li>
<li><a href="#83-rules-for-extension-namespaces"
id="toc-83-rules-for-extension-namespaces">8.3 Rules for extension
namespaces</a></li>
<li><a href="#84-rules-for-subset-namespaces"
id="toc-84-rules-for-subset-namespaces">8.4 Rules for subset
namespaces</a></li>
</ul></li>
<li><a href="#9-rules-for-schema-documents"
id="toc-9-rules-for-schema-documents">9. Rules for schema documents</a>
<ul>
<li><a href="#91-rules-for-the-niem-profile-of-xsd"
id="toc-91-rules-for-the-niem-profile-of-xsd">9.1 Rules for the NIEM
profile of XSD</a></li>
<li><a href="#92-rules-for-xsd-types"
id="toc-92-rules-for-xsd-types">9.2 Rules for XSD types</a></li>
<li><a href="#93-rules-for-attribute-and-element-declarations"
id="toc-93-rules-for-attribute-and-element-declarations">9.3 Rules for
attribute and element declarations</a></li>
<li><a href="#94-rules-for-adapters-and-external-components"
id="toc-94-rules-for-adapters-and-external-components">9.4 Rules for
adapters and external components</a></li>
<li><a href="#95-rules-for-proxy-types"
id="toc-95-rules-for-proxy-types">9.5 Rules for proxy types</a></li>
<li><a href="#96-rules-for-augmentations"
id="toc-96-rules-for-augmentations">9.6 Rules for augmentations</a></li>
<li><a href="#97-rules-for-machine-readable-annotations"
id="toc-97-rules-for-machine-readable-annotations">9.7 Rules for
machine-readable annotations</a></li>
<li><a href="#98-rules-for-reference-schema-documents"
id="toc-98-rules-for-reference-schema-documents">9.8 Rules for reference
schema documents</a></li>
<li><a href="#99-rules-for-extension-schema-documents"
id="toc-99-rules-for-extension-schema-documents">9.9 Rules for extension
schema documents</a></li>
</ul></li>
<li><a href="#10-rules-for-models" id="toc-10-rules-for-models">10.
Rules for models</a>
<ul>
<li><a href="#101-rules-for-model-files"
id="toc-101-rules-for-model-files">10.1 Rules for model files</a></li>
<li><a href="#102-rules-for-schema-document-sets"
id="toc-102-rules-for-schema-document-sets">10.2 Rules for schema
document sets</a></li>
</ul></li>
<li><a href="#11-rules-for-message-types-and-message-formats"
id="toc-11-rules-for-message-types-and-message-formats">11. Rules for
message types and message formats</a></li>
<li><a href="#12-rules-for-xml-messages"
id="toc-12-rules-for-xml-messages">12. Rules for XML messages</a></li>
<li><a href="#13-rules-for-json-messages"
id="toc-13-rules-for-json-messages">13. Rules for JSON messages</a></li>
<li><a href="#14-interpretation-of-niem-data"
id="toc-14-interpretation-of-niem-data">14. Interpretation of NIEM
data</a>
<ul>
<li><a href="#141-rdf-interpretation-of-niem-models"
id="toc-141-rdf-interpretation-of-niem-models">14.1 RDF interpretation
of NIEM models</a>
<ul>
<li><a href="#1411-model-terminology-in-cmf-xsd-and-rdf"
id="toc-1411-model-terminology-in-cmf-xsd-and-rdf">14.1.1 Model
terminology in CMF, XSD, and RDF</a></li>
<li><a href="#1412-identifiers-for-model-components"
id="toc-1412-identifiers-for-model-components">14.1.2 Identifiers for
model components</a></li>
<li><a href="#1413-rdf-interpretation-of-class-objects"
id="toc-1413-rdf-interpretation-of-class-objects">14.1.3 RDF
interpretation of Class objects</a></li>
<li><a href="#1414-rdf-interpretation-of-dataproperty-objects"
id="toc-1414-rdf-interpretation-of-dataproperty-objects">14.1.4 RDF
interpretation of DataProperty objects</a></li>
<li><a href="#1415-rdf-interpretation-of-objectproperty-objects"
id="toc-1415-rdf-interpretation-of-objectproperty-objects">14.1.5 RDF
interpretation of ObjectProperty objects</a></li>
</ul></li>
<li><a href="#142-rdf-interpretation-of-niem-messages"
id="toc-142-rdf-interpretation-of-niem-messages">14.2 RDF interpretation
of NIEM messages</a>
<ul>
<li><a href="#1421-objects-properties-and-values"
id="toc-1421-objects-properties-and-values">14.2.1 Objects, properties,
and values</a></li>
<li><a href="#1422-messages-and-message-objects"
id="toc-1422-messages-and-message-objects">14.2.2 Messages and message
objects</a></li>
<li><a href="#1423-objects-and-object-identifiers"
id="toc-1423-objects-and-object-identifiers">14.2.3 Objects and object
identifiers</a></li>
<li><a href="#1424-object-properties-and-object-class"
id="toc-1424-object-properties-and-object-class">14.2.4 Object
properties and object class</a></li>
<li><a href="#1425-data-properties-and-literal-values"
id="toc-1425-data-properties-and-literal-values">14.2.5 Data properties
and literal values</a></li>
<li><a href="#1426-literal-class-and-language-tags"
id="toc-1426-literal-class-and-language-tags">14.2.6 Literal class and
language tags</a></li>
<li><a href="#1427-repeatable-properties"
id="toc-1427-repeatable-properties">14.2.7 Repeatable
properties</a></li>
<li><a href="#1428-ordered-properties"
id="toc-1428-ordered-properties">14.2.8 Ordered properties</a></li>
<li><a href="#1429-relationship-properties"
id="toc-1429-relationship-properties">14.2.9 Relationship
properties</a></li>
<li><a href="#14210-reference-attributes"
id="toc-14210-reference-attributes">14.2.10 Reference
attributes</a></li>
<li><a href="#14211-augmentation-elements"
id="toc-14211-augmentation-elements">14.2.11 Augmentation
elements</a></li>
</ul></li>
</ul></li>
<li><a href="#appendix-a-references"
id="toc-appendix-a-references">Appendix A. References</a>
<ul>
<li><a href="#a1-normative-references"
id="toc-a1-normative-references">A.1 Normative References</a></li>
<li><a href="#a2-informative-references"
id="toc-a2-informative-references">A.2 Informative References</a></li>
</ul></li>
<li><a href="#appendix-b-structures-namespace"
id="toc-appendix-b-structures-namespace">Appendix B. Structures
namespace</a></li>
<li><a href="#appendix-c-index-of-rules"
id="toc-appendix-c-index-of-rules">Appendix C. Index of rules</a></li>
<li><a href="#appendix-d-mapping-niem-5-rules-to-niem-6"
id="toc-appendix-d-mapping-niem-5-rules-to-niem-6">Appendix D. Mapping
NIEM 5 rules to NIEM 6</a></li>
<li><a href="#appendix-e-table-of-examples"
id="toc-appendix-e-table-of-examples">Appendix E. Table of
examples</a></li>
<li><a href="#appendix-f-table-of-figures"
id="toc-appendix-f-table-of-figures">Appendix F. Table of
figures</a></li>
<li><a href="#appendix-g-table-of-tables"
id="toc-appendix-g-table-of-tables">Appendix G. Table of tables</a></li>
<li><a href="#appendix-h-acknowledgments"
id="toc-appendix-h-acknowledgments">Appendix H. Acknowledgments</a>
<ul>
<li><a href="#h1-participants" id="toc-h1-participants">H.1
Participants</a></li>
</ul></li>
<li><a href="#appendix-i-notices" id="toc-appendix-i-notices">Appendix
I. Notices</a></li>
</ul>
</nav>
</ul>

  <hr />
  <h1 id="1-introduction">1. Introduction</h1>
  <p>NIEM, formerly known as the "National Information Exchange Model,"
  is a framework for exchanging information among public and private
  sector organizations. The framework includes a <a
  href="https://docs.oasis-open.org/niemopen/niem-model/v6.0/niem-model-v6.0.html">reference
  data model</a> for objects, properties, and relationships; and a set
  of technical specifications for using and extending the data model in
  information exchanges. The NIEM framework supports developer-level
  specifications of data that form a contract between developers. The
  data being specified is called a <em>message</em> in NIEM. While a
  message is usually something passed between applications, NIEM works
  equally well to specify an information resource published on the web,
  or an input or output for a web service or remote procedure --
  basically, any package of data that crosses a system or organization
  boundary.</p>
  <p>NIEM promotes scalability and reusability of messages between
  information systems, allowing organizations to share data and
  information more efficiently. It was launched in 2005 in response to
  the U.S. Homeland Security Presidential Directives to improve
  information sharing between agencies following 9/11. Until 2023, NIEM
  was updated and maintained in a collaboration between the U.S. federal
  government, state and local government agencies, private sector, and
  non-profit and international organizations, with new versions released
  around once per year. NIEM defines a set of technical specifications,
  plus a set of common objects -- the <em>NIEM Core</em>, and 17 sets of
  objects that are specific to certain government or industry verticals,
  the <em>NIEM Domains</em>.</p>
  <p>In 2023, NIEM became the NIEMOpen OASIS Open Project. NIEMOpen
  welcomes participation by anyone irrespective of affiliation with
  OASIS. Substantive contributions to NIEMOpen and feedback are invited
  from all parties, following the OASIS rules and the usual conventions
  for participation in GitHub public repository projects.</p>
  <p>NIEMOpen is the term generally used when referring to the
  organization such as Project Governing Board (PGB), NIEMOpen Technical
  Architecture Committee (NTAC), NIEMOpen Business Architecture
  Committee (NBAC), organization activities or processes. NIEM is the
  term used when directly referring to the model i.e. NIEM Domain, NIEM
  Model version.</p>
  <p>This document specifies principles and enforceable rules for NIEM
  data components and schemas. Schemas and components that obey the
  rules set forth here are conformant to specific conformance targets.
  Conformance targets may include more than the level of conformance
  defined by this NDR, and may include specific patterns of use,
  additional quality criteria, and requirements to reuse NIEM release
  schemas.</p>
  <h2 id="11-glossary">1.1 Glossary</h2>
  <h3 id="111-definitions-of-terms">1.1.1 Definitions of terms</h3>
  <table>
  <thead>
  <tr>
  <th style="text-align: left;">Term</th>
  <th style="text-align: left;">Definition</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td style="text-align: left;"><a name="def-absolute-uri"> Absolute URI
  </a></td>
  <td style="text-align: left;">A Uniform Resource Identifier (URI) with
  scheme, hierarchical part, and optional query, but without a fragment;
  a URI matching the grammar syntax <code>&lt;absoluteURI&gt;</code> as
  defined by <a href="#rfc-3986"><b>[RFC 3986]</b></a>.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-adapter-class"> Adapter
  class </a></td>
  <td style="text-align: left;">A class that contains only properties
  from a single <a
  href="#def-external-namespace"><span class="termRef">external
  namespace</span></a>. <em>(see <a href="#44-class">§4.4</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-adapter-type"> Adapter type
  </a></td>
  <td style="text-align: left;">An XSD type definition that encapsulates
  <a href="#def-external-component"><span class="termRef">external
  components</span></a> for use within NIEM. <em>(see <a
  href="#94-rules-for-adapters-and-external-components">§9.4</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-appinfo-namespace"> Appinfo
  namespace </a></td>
  <td style="text-align: left;">A namespace defined by a schema document
  that provides additional semantics for components in the XSD
  representation of a model. <em>(see <a
  href="#97-rules-for-machine-readable-annotations">§9.7</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-association-class">
  Association class </a></td>
  <td style="text-align: left;">A class that represents a specific
  relationship between objects. <em>(see <a
  href="#44-class">§4.4</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-association-type">
  Association type </a></td>
  <td style="text-align: left;">A type definition representing an
  association class in XSD</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-attribute-property">
  Attribute property </a></td>
  <td style="text-align: left;">A data property represented in XSD as an
  attribute declaration. <em>(see <a
  href="#49-dataproperty">§4.9</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-augmentation"> Augmentation
  </a></td>
  <td style="text-align: left;">The means by which a designer of one
  namespace adds properties to a class defined in a different namespace.
  <em>(see <a href="#37-model-extensions">§3.7</a>, <a
  href="#416-augmentation-class">§4.16</a></em>)</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-augmentation-element">
  Augmentation element </a></td>
  <td style="text-align: left;">An element in an XML message that is a
  container for one or more <a
  href="#def-augmentation-property"><span class="termRef">augmentation
  properties</span></a>. <em>(see <a
  href="#41622-augmenting-one-object-class-or-association-class-with-an-element-property">§4.16.2.2</a>)</em></td>
  </tr>
  <tr>
  <td
  style="text-align: left;"><a name="def-augmentation-point-element">
  Augmentation point element </a></td>
  <td style="text-align: left;">An abstract element declaration that
  provides a place for <a
  href="#def-augmentation-property"><span class="termRef">augmentation
  properties</span></a> within the XSD representation of an augmented
  class. <em>(see <a
  href="#41622-augmenting-one-object-class-or-association-class-with-an-element-property">§4.16.2.2</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-augmentation-property">
  Augmentation property </a></td>
  <td style="text-align: left;">A property added by one namespace to an
  augmented class in another namespace. <em>(see <a
  href="#41622-augmenting-one-object-class-or-association-class-with-an-element-property">§4.16.2.2</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-augmentation-type">
  Augmentation type </a></td>
  <td style="text-align: left;">An XSD type definition for an <a
  href="#def-augmentation-element"><span class="termRef">augmentation
  element</span></a>. <em>(see <a
  href="#41622-augmenting-one-object-class-or-association-class-with-an-element-property">§4.16.2.2</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-augmented-class"> Augmented
  class </a></td>
  <td style="text-align: left;">A class to which a property is added
  through augmentation. <em>(see <a
  href="#41622-augmenting-one-object-class-or-association-class-with-an-element-property">§4.16.2.2</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-cardinality"> Cardinality
  </a></td>
  <td style="text-align: left;">The number of times a property may/must
  appear in an object.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-class"> Class </a></td>
  <td style="text-align: left;">A definition of an entity in a model;
  that is, a real-world object, concept, or thing. <em>(see <a
  href="#34-the-niem-metamodel">§3.4</a>, <a
  href="#44-class">§4.4</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-code-list-datatype"> Code
  list datatype </a></td>
  <td style="text-align: left;">A datatype in which each valid value is
  also a string in a <a href="#def-code-list"><span class="termRef">code
  list</span></a>. <em>(see <a
  href="#413-restriction">§4.13</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-code-list"> Code list
  </a></td>
  <td style="text-align: left;">A set of string values, each having a
  known meaning beyond its value, each representing a distinct
  conceptual entity. <em>(see <a
  href="#413-restriction">§4.13</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-conforming-namespace">
  Conforming namespace </a></td>
  <td style="text-align: left;">A namespace that satisfies all of the
  applicable rules in this document; a <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a>, <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a>, or <a
  href="#def-subset-namespace"><span class="termRef">subset
  namespace</span></a>. <em>(see <a
  href="#61-conformance-targets">§6.1</a>)</em></td>
  </tr>
  <tr>
  <td
  style="text-align: left;"><a name="def-conforming-schema-document">
  Conforming schema document </a></td>
  <td style="text-align: left;">A <a
  href="#def-schema-document"><span class="termRef">schema
  document</span></a> that satisfies all of the applicable rules in this
  document. <em>(see <a
  href="#61-conformance-targets">§6.1</a>)</em></td>
  </tr>
  <tr>
  <td
  style="text-align: left;"><a name="def-conforming-schema-document-set">
  Conforming schema document set </a></td>
  <td style="text-align: left;">A <a
  href="#def-schema-document-set"><span class="termRef">schema document
  set</span></a> that satisfies all of the applicable rules in this
  document. <em>(see <a
  href="#61-conformance-targets">§6.1</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-data-definition"> Data
  definition </a></td>
  <td style="text-align: left;">A text definition of a component,
  describing what the component means.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-data-property"> Data
  property </a></td>
  <td style="text-align: left;">Defines a relationship between an object
  and a literal value.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-datatype"> Datatype
  </a></td>
  <td style="text-align: left;">Defines the allowed values of a
  corresponding literal value in a message.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-documented-component">
  Documented component </a></td>
  <td style="text-align: left;">A CMF object or XSD schema component
  that has an associated data definition.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-element-property"> Element
  property </a></td>
  <td style="text-align: left;">An object property, or a data property
  that is not an <a
  href="#def-attribute-property"><span class="termRef">attribute
  property</span></a>; represented in XSD by an element declaration.
  <em>(see <a href="#49-dataproperty">§4.9</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-extension-namespace">
  Extension namespace </a></td>
  <td style="text-align: left;">A <a
  href="#def-namespace"><span class="termRef">namespace</span></a>
  defining components that are intended for reuse, but within a more
  narrow scope than those defined in a <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a>. <em>(see <a
  href="#36-namespaces">§3.6</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-extension-schema-document">
  Extension schema document </a></td>
  <td style="text-align: left;">A <a
  href="#def-schema-document"><span class="termRef">schema
  document</span></a> that is the XSD representation of an <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a>.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-external-attribute">
  External attribute </a></td>
  <td style="text-align: left;">An attribute declaration in <a
  href="#def-external-schema-document"><span class="termRef">external
  schema document</span></a>.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-external-component">
  External component </a></td>
  <td style="text-align: left;">A component defined by an <a
  href="#def-external-schema-document"><span class="termRef">external
  schema document</span></a>. <em>(see <a
  href="#94-rules-for-adapters-and-external-components">§9.4</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-external-namespace">
  External namespace </a></td>
  <td style="text-align: left;">Any namespace defined by a <a
  href="#def-schema-document"><span class="termRef">schema
  document</span></a> that is not a <a
  href="#def-conforming-namespace"><span class="termRef">conforming
  namespace</span></a>, the <a
  href="#def-structures-namespace"><span class="termRef">structures
  namespace</span></a>, or the XML namespace
  <code>http://www.w3.org/XML/1998/namespace</code>. <em>(see <a
  href="#36-namespaces">§3.6</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-external-schema-document">
  External schema document </a></td>
  <td style="text-align: left;">A schema document that defines an <a
  href="#def-external-namespace"><span class="termRef">external
  namespace</span></a>. <em>(see <a
  href="#36-namespaces">§3.6</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-literal-class"> Literal
  class </a></td>
  <td style="text-align: left;">A class that contains no object
  properties, one or more <a
  href="#def-attribute-property"><span class="termRef">attribute
  properties</span></a>, and exactly one <a
  href="#def-element-property"><span class="termRef">element
  property</span></a>. <em>(see <a href="#44-class">§4.4</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-literal-property"> Literal
  property </a></td>
  <td style="text-align: left;">The <a
  href="#def-element-property"><span class="termRef">element
  property</span></a> in a <a
  href="#def-literal-class"><span class="termRef">literal
  class</span></a>.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-local-term"> Local term
  </a></td>
  <td style="text-align: left;">A word, phrase, acronym, or other string
  of characters that is used in the name of a namespace component, but
  that is not defined in OED, or that has a non-OED definition in this
  namespace, or has a word sense that is in some way unclear. <em>(see
  <a href="#417-localterm">§4.17</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-message"> Message </a></td>
  <td style="text-align: left;">A package of data shared at runtime; a
  sequence of bits that convey information to be exchanged or shared; an
  instance of a <a
  href="#def-message-type"><span class="termRef">message
  type</span></a>. <em>(see <a
  href="#311-messages">§3.1.1</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-message-designer"> Message
  designer </a></td>
  <td style="text-align: left;">A person who creates a <a
  href="#def-message-type"><span class="termRef">message type</span></a>
  and <a href="#def-message-format"><span class="termRef">message
  format</span></a> from an information requirement, so that an instance
  <a href="#def-message"><span class="termRef">message</span></a> at
  runtime will contain all the facts that need to be conveyed.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-message-developer"> Message
  developer </a></td>
  <td style="text-align: left;">A person who writes software to
  implement a <a
  href="#def-message-specification"><span class="termRef">message
  specification</span></a>, producing or processing <a
  href="#def-message"><span class="termRef">messages</span></a> that
  conform to the message format.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-message-format"> Message
  format </a></td>
  <td style="text-align: left;">A specification of the valid syntax of
  <a href="#def-message"><span class="termRef">messages</span></a> that
  conform to a <a href="#def-message-type"><span class="termRef">message
  type</span></a>. <em>(see <a
  href="#312-message-format">§3.1.2</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-message-model"> Message
  model </a></td>
  <td style="text-align: left;">A data model intended to precisely
  define the mandatory and optional content of <a
  href="#def-message"><span class="termRef">messages</span></a> and the
  meaning of that content. <em>(see <a
  href="#313-message-type">§3.1.3</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-message-object"> Message
  object </a></td>
  <td style="text-align: left;">The initial object in a message.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-message-property"> Message
  property </a></td>
  <td style="text-align: left;">The initial property of a message type.
  *(See <a href="#313-message-type">§3.1.3</a>)</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-message-specification">
  Message specification </a></td>
  <td style="text-align: left;">A collection of related <a
  href="#def-message-format"><span class="termRef">message
  formats</span></a> and <a
  href="#def-message-type"><span class="termRef">message
  types</span></a>. <em>(see <a
  href="#314-message-specification">§3.1.4</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-message-type"> Message type
  </a></td>
  <td style="text-align: left;">A specification of the information
  content of <a
  href="#def-message"><span class="termRef">messages</span></a>.
  <em>(see <a href="#313-message-type">§3.1.3</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-model-file"> Model file
  </a></td>
  <td style="text-align: left;">The CMF representation of a NIEM model;
  a <a href="#def-message"><span class="termRef">message</span></a> that
  conforms to the CMF <a
  href="#def-message-type"><span class="termRef">message
  type</span></a>. <em>(see <a
  href="#35-niem-model-representations-xsd-and-cmf">§3.5</a>, <a
  href="#61-conformance-targets">§6.1</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-namespace"> Namespace
  </a></td>
  <td style="text-align: left;">A collection of uniquely-named
  components, managed by an authoritative source. <em>(see <a
  href="#36-namespaces">§3.6</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-ncname"> NCName </a></td>
  <td style="text-align: left;">A non-colonized name, matching the
  grammar syntax <code>&lt;NCName&gt;</code> as defined by
  <a href="#xml-namespaces"><b>[XML Namespaces]</b></a>.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-object-class"> Object class
  </a></td>
  <td style="text-align: left;">Represents a class of objects defined by
  a NIEM model. <em>(see <a href="#44-class">§4.4</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-object-property"> Object
  property </a></td>
  <td style="text-align: left;">Defines a relationship between a parent
  object and a child object.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-object-type"> Object type
  </a></td>
  <td style="text-align: left;">A type definition representing an object
  class in XSD</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-proxy-type"> Proxy type
  </a></td>
  <td style="text-align: left;">An XSD complex type definition with
  simple content that extends one of the simple types in the XML Schema
  namespace with <code>structures:SimpleObjectAttributeGroup</code>.
  <em>(see <a href="#95-rules-for-proxy-types">§9.5</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-relationship-property">
  Relationship property </a></td>
  <td style="text-align: left;">A property that provides information
  about the relationship between its parent and grandparent objects.
  <em>(see <a href="#46-property">§4.6</a>, <a
  href="#55-relationship-properties">§5.5</a>)</em></td>
  </tr>
  <tr>
  <td
  style="text-align: left;"><a name="def-reference-attribute-property">
  Reference attribute property </a></td>
  <td style="text-align: left;">An <a
  href="#def-attribute-property"><span class="termRef">attribute
  property</span></a> that contains a reference to an object in a
  message. <em>(see <a href="#49-dataproperty">§4.9</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-reference-namespace">
  Reference namespace </a></td>
  <td style="text-align: left;">A namespace containing components that
  are intended for the widest possible reuse. <em>(see <a
  href="#36-namespaces">§3.6</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-reference-schema-document">
  Reference schema document </a></td>
  <td style="text-align: left;">The XSD representation of a <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a>. <em>(see <a
  href="#98-rules-for-reference-schema-documents">§9.8</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-reuse-model"> Reuse model
  </a></td>
  <td style="text-align: left;">A data model entirely comprised of <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespaces</span></a> and <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespaces</span></a>; a model intended to make the agreed definitions
  of a community available for reuse.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-schema"> Schema </a></td>
  <td style="text-align: left;">An artifact that can be used to assess
  the validity of a message; in XML Schema for XML messages, JSON Schema
  for JSON messages. <em>(see <a
  href="#312-message-format">§3.1.2</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-schema-document-set">
  Schema document set </a></td>
  <td style="text-align: left;">A collection of <a
  href="#def-schema-document"><span class="termRef">schema
  documents</span></a> that together are capable of validating an XML
  document. <em>(see <a
  href="#102-rules-for-schema-document-sets">§10.2</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-serialization">
  Serialization </a></td>
  <td style="text-align: left;"><em>(Verb)</em> A process of converting
  a data structure into a sequence of bits that can be stored or
  transferred.<br><em>(Noun)</em> A standard for the output of
  serialization; for example, XML and JSON.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-structures-namespace">
  Structures namespace </a></td>
  <td style="text-align: left;">A namespace that provides base types and
  attributes for the XSD representation of NIEM models. <em>(see <a
  href="#36-namespaces">§3.6</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-subset-namespace"> Subset
  namespace </a></td>
  <td style="text-align: left;">A subset of the components in a
  reference or extension namespace. <em>(see <a
  href="#36-namespaces">§3.6</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-subset-rule"> Subset rule
  </a></td>
  <td style="text-align: left;">Any data that is valid for a <a
  href="#def-subset-namespace"><span class="termRef">subset
  namespace</span></a> must also be valid for its <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> or <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a>, and must have the same meaning. <em>(see <a
  href="#84-rules-for-subset-namespaces">§8.4</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-subset-schema-document">
  Subset schema document </a></td>
  <td style="text-align: left;">A <a
  href="#def-schema-document"><span class="termRef">schema
  document</span></a> for a <a
  href="#def-subset-namespace"><span class="termRef">subset
  namespace</span></a>. <em>(see <a
  href="#910-rules-for-subset-schema-documents">§9.10</a>)</em></td>
  </tr>
  </tbody>
  </table>
  <p><strong>Terms imported from <em>Extensible Markup Language (XML)
  1.0 (Fourth Edition)</em>
  <a href="#xml"><b>[XML]</b></a>:</strong></p>
  <table>
  <thead>
  <tr>
  <th style="text-align: left;">Term</th>
  <th style="text-align: left;">Definition</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td style="text-align: left;"><a name="def-document-element"> Document
  element </a></td>
  <td style="text-align: left;">An element, no part of which appears in
  the content of another element; preferred synonym for <em>root
  element</em>.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-xml-document"> XML document
  </a></td>
  <td style="text-align: left;">A data object is an XML document if it
  is well-formed, as defined in this specification. <em>(<a
  href="https://www.w3.org/TR/2008/REC-xml-20081126/#dt-xml-doc">Section
  2, Documents</a>)</em></td>
  </tr>
  </tbody>
  </table>
  <p><strong>Terms imported from <em>XML Information Set (Second
  Edition)</em> <a href="#xml-infoset"><b>[XML
  Infoset]</b></a>:</strong></p>
  <table>
  <thead>
  <tr>
  <th style="text-align: left;">Term</th>
  <th style="text-align: left;">Definition</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td style="text-align: left;"><a name="def-attribute"> Attribute
  </a></td>
  <td style="text-align: left;">An <em>attribute information item</em>,
  as defined by <a
  href="http://www.w3.org/TR/2004/REC-xml-infoset-20040204/#infoitem.element">Section
  2.3: <em>Attribute Information Items</em></a>.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-element"> Element </a></td>
  <td style="text-align: left;">An <em>element information item</em>, as
  defined by <a
  href="http://www.w3.org/TR/2004/REC-xml-infoset-20040204/#infoitem.element">Section
  2.2, <em>Element Information Items</em></a>.</td>
  </tr>
  </tbody>
  </table>
  <p><strong>Terms imported from
  <a href="#xml-schema-structures"><b>[XML Schema
  Structures]</b></a>:</strong></p>
  <table>
  <thead>
  <tr>
  <th style="text-align: left;">Term</th>
  <th style="text-align: left;">Definition</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td style="text-align: left;"><a name="def-attribute-declaration">
  Attribute declaration </a></td>
  <td style="text-align: left;">As defined by <a
  href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#Attribute_Declaration"><em>Section
  2.2.2.3, Attribute Declaration</em></a>.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-base-type-definition"> Base
  type definition </a></td>
  <td style="text-align: left;">A type definition used as the basis for
  an extension or restriction. <em>(see <a
  href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#key-baseTypeDefinition">Section
  2.2.1.1, Type Definition Hierarchy</a></em>)</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-complex-type-definition">
  Complex type definition </a></td>
  <td style="text-align: left;">As defined by <a
  href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#Complex_Type_Definition"><em>Section
  2.2.1.3, Complex Type Definition</em></a>*.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-element-declaration">
  Element declaration </a></td>
  <td style="text-align: left;">As defined by <a
  href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#Element_Declaration"><em>Section
  2.2.2.1, Element Declaration</em></a>.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-schema-component"> Schema
  component </a></td>
  <td style="text-align: left;">The generic term for the building blocks
  that comprise the abstract data model of the schema. <em>(see <a
  href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#key-component">Section
  2.2, XML Schema Abstract Data Model</a>)</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-schema-document"> Schema
  document </a></td>
  <td style="text-align: left;">As defined by <a
  href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#key-schemaDoc"><em>Section
  3.1.2, XML Representations of Components</em></a>, which states, "A
  document in this form (i.e. a <schema> element information item) is a
  schema document."</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-simple-type-definition">
  Simple type definition </a></td>
  <td style="text-align: left;">As defined by <a
  href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#Simple_Type_Definition"><em>Section
  2.2.1.2, Simple Type Definition</em></a>.</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-valid"> Valid </a></td>
  <td style="text-align: left;">As defined by <a
  href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#key-vn"><em>Section
  2.1, Overview of XML Schema</em></a>, which states, "The word valid
  and its derivatives are used to refer to clause 1 above, the
  determination of local schema-validity."</td>
  </tr>
  <tr>
  <td style="text-align: left;"><a name="def-xml-schema"> XML Schema
  </a></td>
  <td style="text-align: left;">A set of schema components. <em>(see <a
  href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#key-component">Section
  2.2, XML Schema Abstract Data Model</a>)</em></td>
  </tr>
  <tr>
  <td
  style="text-align: left;"><a name="def-xml-schema-definition-language-(xsd)">
  XML Schema definition language (XSD) </a></td>
  <td style="text-align: left;">As defined by <a
  href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#abstract"><em>Abstract</em></a>,
  which states, "XML Schema: Structures specifies the XML Schema
  definition language, which offers facilities for describing the
  structure and constraining the contents of XML 1.0 documents,
  including those which exploit the XML Namespace facility."</td>
  </tr>
  </tbody>
  </table>
  <p><strong>Terms imported from NIEM Conformance Targets Attribute
  Specification
  <a href="#ctas-v3.0"><b>[CTAS-v3.0]</b></a>:</strong></p>
  <table>
  <thead>
  <tr>
  <th style="text-align: left;">Term</th>
  <th style="text-align: left;">Definition</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td style="text-align: left;"><a name="def-conformance-target">
  Conformance target </a></td>
  <td style="text-align: left;">A class of artifact, such as an
  interface, protocol, document, platform, process or service, that is
  the subject of conformance clauses and normative statements. <em>(see
  <a href="#61-conformance-targets">§6.1</a>)</em></td>
  </tr>
  <tr>
  <td
  style="text-align: left;"><a name="def-conformance-target-identifier">
  Conformance target identifier </a></td>
  <td style="text-align: left;">An internationalized resource identifier
  (IRI) that uniquely identifies a <a
  href="#def-conformance-target"><span class="termRef">conformance
  target</span></a>.</td>
  </tr>
  <tr>
  <td
  style="text-align: left;"><a name="def-effective-conformance-targets-attribute">
  Effective conformance targets attribute </a></td>
  <td style="text-align: left;">The first occurrence of the attribute
  <code>{https://docs.oasis-open.org/niemopen/ns/specification/conformanceTargets/6.0/}conformanceTargets</code>,<br>in
  document order.</td>
  </tr>
  <tr>
  <td
  style="text-align: left;"><a name="def-effective-conformance-target-identifier">
  Effective conformance target identifier </a></td>
  <td style="text-align: left;">An internationalized resource identifier
  reference that occurs in the document's <a
  href="#def-effective-conformance-targets-attribute"><span class="termRef">effective
  conformance targets attribute</span></a>.</td>
  </tr>
  </tbody>
  </table>
  <h3 id="112-acronyms-and-abbreviations">1.1.2 Acronyms and
  abbreviations</h3>
  <table>
  <thead>
  <tr>
  <th style="text-align: left;">Term</th>
  <th style="text-align: left;">Literal</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td style="text-align: left;">APPINFO</td>
  <td style="text-align: left;">Application Information</td>
  </tr>
  <tr>
  <td style="text-align: left;">CCC</td>
  <td style="text-align: left;">Complex type with Complex Content</td>
  </tr>
  <tr>
  <td style="text-align: left;">CMF</td>
  <td style="text-align: left;">Common Model Format</td>
  </tr>
  <tr>
  <td style="text-align: left;">CSC</td>
  <td style="text-align: left;">Complex type with Simple Content</td>
  </tr>
  <tr>
  <td style="text-align: left;">CSV</td>
  <td style="text-align: left;">Comma Separated Values</td>
  </tr>
  <tr>
  <td style="text-align: left;">CTAS</td>
  <td style="text-align: left;">Conformance Targets Attribute
  Specification</td>
  </tr>
  <tr>
  <td style="text-align: left;">ID</td>
  <td style="text-align: left;">Identifier</td>
  </tr>
  <tr>
  <td style="text-align: left;">IEP</td>
  <td style="text-align: left;">Information Exchange Package</td>
  </tr>
  <tr>
  <td style="text-align: left;">IEPD</td>
  <td style="text-align: left;">Information Exchange Package
  Documentation</td>
  </tr>
  <tr>
  <td style="text-align: left;">ISO</td>
  <td style="text-align: left;">International Organization for
  Standardization</td>
  </tr>
  <tr>
  <td style="text-align: left;">JSON</td>
  <td style="text-align: left;">JavaScript Object Notation</td>
  </tr>
  <tr>
  <td style="text-align: left;">JSON-LD</td>
  <td style="text-align: left;">JavaScript Object Notation Linked
  Data</td>
  </tr>
  <tr>
  <td style="text-align: left;">NBAC</td>
  <td style="text-align: left;">NIEMOpen Business Architecture
  Committee</td>
  </tr>
  <tr>
  <td style="text-align: left;">NS</td>
  <td style="text-align: left;">Namespace</td>
  </tr>
  <tr>
  <td style="text-align: left;">NTAC</td>
  <td style="text-align: left;">NIEMOpen Technical Architecture
  Committee</td>
  </tr>
  <tr>
  <td style="text-align: left;">OED</td>
  <td style="text-align: left;">Oxford English Dictionary</td>
  </tr>
  <tr>
  <td style="text-align: left;">OP</td>
  <td style="text-align: left;">Open Project</td>
  </tr>
  <tr>
  <td style="text-align: left;">OWL</td>
  <td style="text-align: left;">Web Ontology Language</td>
  </tr>
  <tr>
  <td style="text-align: left;">PGB</td>
  <td style="text-align: left;">Project Governing Board</td>
  </tr>
  <tr>
  <td style="text-align: left;">QName</td>
  <td style="text-align: left;">Qualified Name</td>
  </tr>
  <tr>
  <td style="text-align: left;">RDF</td>
  <td style="text-align: left;">Resource Description Framework</td>
  </tr>
  <tr>
  <td style="text-align: left;">RDFS</td>
  <td style="text-align: left;">Resource Description Framework
  Schema</td>
  </tr>
  <tr>
  <td style="text-align: left;">RFC</td>
  <td style="text-align: left;">Request For Comments</td>
  </tr>
  <tr>
  <td style="text-align: left;">UML</td>
  <td style="text-align: left;">Unified Modeling Language</td>
  </tr>
  <tr>
  <td style="text-align: left;">URI</td>
  <td style="text-align: left;">Uniform Resource Identifier</td>
  </tr>
  <tr>
  <td style="text-align: left;">URL</td>
  <td style="text-align: left;">Uniform Resource Locator</td>
  </tr>
  <tr>
  <td style="text-align: left;">URN</td>
  <td style="text-align: left;">Uniform Resource Name</td>
  </tr>
  <tr>
  <td style="text-align: left;">XML</td>
  <td style="text-align: left;">Extensible Markup Language</td>
  </tr>
  <tr>
  <td style="text-align: left;">XSD</td>
  <td style="text-align: left;">XML Schema Definition</td>
  </tr>
  </tbody>
  </table>
  <hr />
  <h1 id="2-how-to-read-this-document">2. How To Read This Document</h1>
  <p>This document provides normative specifications for NIEM-conforming
  data models. It also describes the goals and principles behind those
  specifications. It includes examples and explanations to help users of
  NIEM understand the goals, principles, and specifications.</p>
  <p>This document is not intended as a user guide. Training materials
  for message designers and developers will be available at
  www.niemopen.org.</p>
  <p>The relevant sections of this document will depend on the role of
  the user. <a href="#fig2-1">Figure 2-1</a> illustrates the
  relationships between these roles and NIEM activities.</p>
  <figure>
    <img src="images/userRoles.png" style="zoom: 100%;" />
    <figcaption><a name="fig2-1">Figure 2-1: User roles and activities</a></figcaption>
  </figure>

  <p>The user roles in the above figure are:</p>
  <ul>
  <li><p><em>Business analysts</em> and <em>subject matter experts</em>,
  who provide the requirements for information transfer. These
  requirements might describe an information resource available to all
  comers. They could describe an information exchange as part of a
  business process. They need not be tied to known producers and
  consumers.</p></li>
  <li><p><em>Message designers</em>, who express those requirements as a
  <a href="#def-message-type"><span class="termRef">message
  type</span></a>, which specifies the syntax and semantics of the data
  that will convey the required information at runtime.</p></li>
  <li><p><em>Message developers</em>, who write software to construct
  messages that contain the required information and follows the defined
  syntax, and who write software to parse and process such
  messages.</p></li>
  </ul>
  <p>The remaining sections of this document most relevant to each of
  these roles are shown in the following table:</p>
  <table>
  <thead>
  <tr>
  <th style="text-align: left;">Section</th>
  <th style="text-align: center;">Manager</th>
  <th style="text-align: center;">Business Analyst</th>
  <th style="text-align: center;">Message Designer</th>
  <th style="text-align: center;">Message Developer</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td style="text-align: left;">3. Overview of NIEM technical
  architecture</td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;">x</td>
  </tr>
  <tr>
  <td style="text-align: left;">4. Data models in NIEM</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;"></td>
  </tr>
  <tr>
  <td style="text-align: left;">5. Data modeling patterns</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;"></td>
  </tr>
  <tr>
  <td style="text-align: left;">6. Conformance</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;">x</td>
  </tr>
  <tr>
  <td style="text-align: left;">7. Rules for model components</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;"></td>
  </tr>
  <tr>
  <td style="text-align: left;">8. Rules for namespaces</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;"></td>
  </tr>
  <tr>
  <td style="text-align: left;">9. Rules for schema documents</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;"></td>
  </tr>
  <tr>
  <td style="text-align: left;">10. Rules for models</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;"></td>
  </tr>
  <tr>
  <td style="text-align: left;">11. Rules for message types and message
  formats</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;">x</td>
  </tr>
  <tr>
  <td style="text-align: left;">12. Rules for XML messages</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;">x</td>
  </tr>
  <tr>
  <td style="text-align: left;">13. Rules for JSON messages</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;">x</td>
  </tr>
  <tr>
  <td style="text-align: left;">14. RDF interpretation of NIEM models
  and messages</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;">x</td>
  <td style="text-align: center;"></td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab2-2">Table 2-2: Relevant document sections by user role</a></figcaption>

  <h2 id="21-document-references">2.1 Document references</h2>
  <p>This document relies on references to many outside documents. Such
  references are noted by bold, bracketed inline terms. For example, a
  reference to RFC 3986 is shown as <a href="#rfc-3986"><b>[RFC
  3986]</b></a>. All reference documents are recorded in <a
  href="#appendix-a-references">Appendix A, References, below</a>.</p>
  <h2 id="22-clark-notation-and-qualified-names">2.2 Clark notation and
  qualified names</h2>
  <p>This document uses both Clark notation and QName notation to
  represent qualified names.</p>
  <p>QName notation is defined by <a href="#xml-namespaces"><b>[XML
  Namespaces]</b></a> Section 4, Qualified Names. A QName for the XML
  Schema string datatype is xs:string. Namespace prefixes used within
  this specification are listed in Section 2.3, Use of namespaces and
  namespace prefixes, below.</p>
  <p>This document sometimes uses Clark notation to represent qualified
  names in normative text. Clark notation is described by
  <a href="#clarkns"><b>[ClarkNS]</b></a>, and provides the information
  in a QName without the need to first define a namespace prefix, and
  then to reference that namespace prefix. A Clark notation
  representation for the qualified name for the XML Schema string
  datatype is <code>{http://www.w3.org/2001/XMLSchema}string</code>.</p>
  <p>Each Clark notation value usually consists of a namespace URI
  surrounded by curly braces, concatenated with a local name. The
  exception to this is when Clark notation is used to represent the
  qualified name for an attribute with no namespace, which is ambiguous
  when represented using QName notation. For example, the element
  targetNamespace, which has no [namespace name] property, is
  represented in Clark notation as <code>{}targetNamespace</code>.</p>
  <h2 id="23-use-of-namespaces-and-namespace-prefixes">2.3 Use of
  namespaces and namespace prefixes</h2>
  <p>The following namespace prefixes are used consistently within this
  specification. These prefixes are not normative; this document issues
  no requirement that these prefixes be used in any conformant artifact.
  Although there is no requirement for a schema or XML document to use a
  particular namespace prefix, the meaning of the following namespace
  prefixes have fixed meaning in this document.</p>
  <ul>
  <li><code>xs</code> and <code>xsd</code>: The namespace for the XML
  Schema definition language as defined by
  <a href="#xml-schema-structures"><b>[XML Schema Structures]</b></a>
  and <br><a href="#xml-schema-datatypes"><b>[XML Schema
  Datatypes]</b></a>,
  <code class="uri-nb">http://www.w3.org/2001/XMLSchema</code>.</li>
  <li><code>xsi</code>: The XML Schema instance namespace, defined by
  <a href="#xml-schema-structures"><b>[XML Schema Structures]</b></a>,
  Section 2.6, Schema-Related Markup in Documents Being Validated, for
  use in XML documents,
  <code class="uri-nb">http://www.w3.org/2001/XMLSchema-instance</code>.</li>
  <li><code>ct</code>: The namespace defined by Conformance Targets
  Attribute Specification (<a href="#ctas"><b>[CTAS]</b></a>),
  <code class="uri-nb">https://docs.oasis-open.org/niemopen/ns/specification/conformanceTargets/6.0/</code>.</li>
  <li><code>appinfo</code>: The appinfo namespace,
  <code class="uri-nb">https://docs.oasis-open.org/niemopen/ns/model/appinfo/6.0/</code>.</li>
  <li><code>structures</code>: The structures namespace,
  <code class="uri-nb">https://docs.oasis-open.org/niemopen/ns/model/structures/6.0/</code>.</li>
  <li><code>cmf</code>: The namespace for the CMF model representation,
  <code class="uri-nb">https://docs.oasis-open.org/niemopen/ns/specification/cmf/1.0/</code>.</li>
  <li><code>nc</code>: The namespace of the NIEM Core model,
  <code class="uri-nb">https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/</code>.</li>
  <li><code>rdf</code>: The namespace for the Resource Description
  Framework,
  <code class="uri-nb">http://www.w3.org/1999/02/22-rdf-syntax-ns#</code>.</li>
  <li><code>rdfs</code>: The namespace for RDF Schema,
  <code class="uri-nb">http://www.w3.org/2000/01/rdf-schema#</code>.</li>
  <li><code>owl</code>: The namespace for OWL 2 Web Ontology Language,
  <code class="uri-nb">http://www.w3.org/2002/07/owl#</code>.</li>
  </ul>
  <p>XML Schema examples in this document presume namespace declarations
  for all of the above; for example,
  <code>xmlns:xs="http://www.w3.org/2001/XMLSchema"</code>.</p>
  <p>RDF examples in Turtle syntax presume prefix declarations for the
  above; for example,
  <code>@prefix xs: &lt;http://www.w3.org/2001/XMLSchema&gt; .</code></p>
  <p>JSON-LD examples presume <code>@context</code> entries; for
  example,
  <code>"@context": { "xs":, "http://www.w3.org/2001/XMLSchema" }</code></p>
  <hr />
  <h1 id="3-overview-of-the-niem-technical-architecture">3. Overview of
  the NIEM Technical Architecture</h1>
  <p>This overview describes NIEM's design goals and principles, and
  introduces key features of the architecture. The major design goals
  are:</p>
  <ul>
  <li><p><em>Shared understanding of data.</em> NIEM helps developers
  working on different systems to understand the data their systems
  share with each other. NIEM also helps data analysts understand and
  integrate data from multiple sources.</p></li>
  <li><p><em>Reuse of community-agreed data definitions.</em> NIEM
  reduces the cost of data interoperability by promoting shared data
  definitions — without requiring a single data model of everything for
  everyone.</p></li>
  <li><p><em>Open standards with free-and-open-source developer
  tools.</em> NIEM does not depend on proprietary standards or the use
  of expensive developer tools.</p></li>
  </ul>
  <p>The key architecture features mentioned in this section:</p>
  <ul>
  <li><p><em>The NIEM metamodel</em> — an abstract, technology-neutral
  data model for NIEM data models</p></li>
  <li><p><em>Two equivalent model representations</em> — One is a
  profile of XML Schema (XSD) that has been used in every version of
  NIEM. The other is itself a NIEM-based data specification, suitable
  for XML and many other data technologies.</p></li>
  <li><p><em>Model namespaces</em> — for model configuration management
  by multiple authors working independently.</p></li>
  </ul>
  <h2 id="31-machine-to-machine-data-specifications">3.1
  Machine-to-machine data specifications</h2>
  <p>NIEM is a framework for developer-level specifications of data. A
  NIEM-based data specification — which is built <em>using</em> NIEM and
  in <em>conformance</em> to NIEM, but is not itself a <em>part</em> of
  NIEM — describes data in detail sufficient to the developers of
  producing and consuming systems. This data may be shared via:</p>
  <ul>
  <li>a message passed between applications</li>
  <li>an information resource published on the web</li>
  <li>an API for a system or service</li>
  </ul>
  <p>NIEM is potentially useful for any data sharing mechanism that
  transfers data across a system or organization boundary. (Within a
  system, NIEM may also be useful when data passes between system
  components belonging to different developer teams.)</p>
  <p>The primary purpose of a NIEM-based data specification is to
  establish a common understanding among developers, so that they can
  write software that correctly handles the shared data, hence
  "machine-to-machine". (NIEM-conforming data may also be directly
  presented to human consumers, and NIEM can help these consumers
  understand what they see.)</p>
  <p>Data sharing in NIEM is implemented in terms of messages, message
  formats, and message types. These are illustrated in <a
  href="#fig3-1">figure 3-1</a>.</p>
  <ul>
  <li><a href="#def-message"><span class="termRef">message</span></a> —
  a package of data shared at runtime; an instance of a <a
  href="#def-message-format"><span class="termRef">message
  format</span></a> and of a <a
  href="#def-message-type"><span class="termRef">message
  type</span></a></li>
  <li><a href="#def-message-format"><span class="termRef">message
  format</span></a> — a definition of a syntax for the messages of a <a
  href="#def-message-type"><span class="termRef">message
  type</span></a></li>
  <li><a href="#def-message-type"><span class="termRef">message
  type</span></a> — a definition of the information content in
  equivalent <a href="#def-message-format"><span class="termRef">message
  formats</span></a></li>
  </ul>
  <figure>
    <img src="images/m2mShare.png" alt="figure" style="zoom:100%"/>
    <figcaption><a name="fig3-1">Figure 3-1: Message types, message formats, and messages</a></figcaption>
  </figure>

  <p>A message designer turns information requirements into a <a
  href="#def-message-type"><span class="termRef">message
  type</span></a>, then turns a <a
  href="#def-message-type"><span class="termRef">message type</span></a>
  into one or more <a
  href="#def-message-format"><span class="termRef">message
  formats</span></a>. Message developers then use the <a
  href="#def-message-type"><span class="termRef">message type</span></a>
  and <a href="#def-message-format"><span class="termRef">message
  format</span></a> to understand how to implement software that
  produces or consumes conforming messages.</p>
  <h3 id="311-messages">3.1.1 Messages</h3>
  <p>In NIEM terms, the package of data shared at runtime is a <a
  href="#def-message"><span class="termRef">message</span></a>. This
  data is arranged according to a supported serialization; for example,
  XML or JSON. The result is a sequence of bits that represents the
  information content of the message. <a href="#ex3-2">Example 3-2</a>
  shows two messages representing the same information, one serialized
  in XML, the other in JSON. Each message in this example is a request
  for a quantity of some item. (In all examples, closing tags and
  brackets may be omitted, long lines may be truncated, and some
  portions omitted and/or replaced with ellipses (...).)</p>
  <pre><code>&lt;msg:Request                                                  | {
 xmlns:nc=&quot;https://docs.oasis-open.org/niemopen/ns/model/niem |   &quot;@context&quot;: {
 xmlns:msg=&quot;http://example.com/ReqRes/1.0/&quot;&gt;                  |     &quot;nc&quot;: &quot;https://docs.oasis-open.org/niemopen/ns/model/niem-
  &lt;msg:RequestID&gt;RQ001&lt;/msg:RequestID&gt;                        |     &quot;msg&quot;: &quot;http://example.com/ReqRes/1.0/&quot;
  &lt;msg:RequestedItem&gt;                                         |   },
    &lt;nc:ItemName&gt;Wrench&lt;/nc:ItemName&gt;                         |   &quot;msg:Request&quot;: {
    &lt;nc:ItemQuantity&gt;10&lt;/nc:ItemQuantity&gt;                     |     &quot;msg:RequestID&quot; : &quot;RQ001&quot;,
  &lt;/msg:RequestedItem&gt;                                        |     &quot;msg:RequestedItem&quot;: {
&lt;/msg:Request&gt;                                                |       &quot;nc:ItemName&quot;: &quot;Wrench&quot;,
                                                              |       &quot;nc:ItemQuantity&quot;: 10
                                                              |      }
                                                              |   }
                                                              | }</code></pre>
  <figcaption><a name="ex3-2">Example 3-2: Messages in XML and JSON syntax</a></figcaption>

  <p>The data structure of a NIEM message appears to be a tree with a
  root node. It is actually a directed graph with an initial node called
  the <a href="#def-message-object"><span class="termRef">message
  object</span></a>. For example, the <a
  href="#def-message-object"><span class="termRef">message
  object</span></a> in <a href="#ex3-2">example 3-2</a> is the
  <code>msg:Request</code> element in the XML message. In the JSON
  message it is the value for the <code>msg:Request</code> key.</p>
  <p>Every NIEM serialization has a mechanism for references; that is, a
  way for one object in the serialized graph to point to an object
  elsewhere in the graph. This mechanism supports cycles and avoids
  duplication in the graph data structure. <em>(See <a
  href="#1423-objects-and-object-identifiers">§14.2.3</a>)</em></p>
  <p>Every <a
  href="#def-message"><span class="termRef">message</span></a> is an
  instance of a <a
  href="#def-message-format"><span class="termRef">message
  format</span></a>. A conforming message must satisfy the rules in <a
  href="#12-rules-for-xml-messages">section 12</a> and <a
  href="#13-rules-for-json-messages">section 13</a>. In particular, it
  must be valid according to the <a
  href="#def-schema"><span class="termRef">schema</span></a> of its <a
  href="#def-message-format"><span class="termRef">message
  format</span></a>.</p>
  <blockquote>
  <p>A NIEM message was originally known as an <em>information exchange
  package (IEP)</em>, a term that found its way into the U.S. Federal
  Enterprise Architecture (2005). A message specification was originally
  known as an <em>information exchange package documentation
  (IEPD).</em> These terms are in widespread use within the NIEM
  community today, and will not go away soon (if ever).</p>
  </blockquote>
  <h3 id="312-message-format">3.1.2 Message format</h3>
  <p>A <a href="#def-message-format"><span class="termRef">message
  format</span></a> specifies the syntax of valid messages. This
  provides message developers with an exact description of the messages
  to be generated or processed by their software.</p>
  <p>A <a href="#def-message-format"><span class="termRef">message
  format</span></a> includes a <a
  href="#def-schema"><span class="termRef">schema</span></a> that can be
  used to assess the validity of a <a
  href="#def-message"><span class="termRef">message</span></a>. This <a
  href="#def-schema"><span class="termRef">schema</span></a> is
  expressed in XML Schema (XSD) for XML message formats, and JSON Schema
  for JSON message formats. <a href="#ex3-3">Example 3-3</a> shows a
  portion of the schemas for the two example messages in <a
  href="#ex3-2">example 3-2</a>.</p>
  <pre><code>&lt;xs:complexType name=&quot;RequestType&quot;&gt;                    | {
  &lt;xs:sequence&gt;                                        |   &quot;msg:RequestType&quot;: {
    &lt;xs:element ref=&quot;msg:RequestID&quot;/&gt;                  |     &quot;type&quot;: &quot;object&quot;,
    &lt;xs:element ref=&quot;msg:RequestedItem&quot;/&gt;              |     &quot;properties&quot;: {
  &lt;/xs:sequence&gt;                                       |       &quot;msg:RequestID&quot;: {&quot;$ref&quot;: &quot;#/properties/msg:RequestID&quot;},
&lt;/xs:complexType&gt;                                      |       &quot;msg:RequestedItem&quot;: {&quot;$ref&quot;: &quot;#/properties/msg:RequestedItem&quot;}
&lt;xs:element name=&quot;Request&quot; type=&quot;msg:RequestType&quot;/&gt;    |     },
                                                       |     &quot;required&quot;: [
                                                       |       &quot;msg:RequestID&quot;,
                                                       |       &quot;msg:RequestedItem&quot;
                                                       |     ]
                                                       |   },
                                                       |   &quot;msg:Request&quot;: {
                                                       |     &quot;$ref&quot;: &quot;#/definitions/msg:RequestType&quot;
                                                       |   }
                                                       | }</code></pre>
  <figcaption><a name="ex3-3">Example 3-3: Example message format schemas</a></figcaption>

  <p>Producing and consuming systems may use the message format schema
  to validate the syntax of messages at runtime, but are not obligated
  to do so. Message developers may use the schema during development for
  software testing. The schemas may also be used by developers for data
  binding; for example, Java Architecture for XML Binding (JAXB).</p>
  <p>A <a href="#def-message-format"><span class="termRef">message
  format</span></a> belongs to exactly one <a
  href="#def-message-type"><span class="termRef">message
  type</span></a>. A conforming <a
  href="#def-message-format"><span class="termRef">message
  format</span></a> must satisfy the rules in <a
  href="#11-rules-for-message-types-and-message-formats">section 11</a>;
  in particular, it must be constructed so that every <a
  href="#def-message"><span class="termRef">message</span></a> that is
  valid according to the format also satisfies the information content
  constraints of its <a
  href="#def-message-type"><span class="termRef">message
  type</span></a>.</p>
  <h3 id="313-message-type">3.1.3 Message type</h3>
  <p>One important feature of NIEM is that every <a
  href="#def-message"><span class="termRef">message</span></a> has an
  equivalent <a
  href="#def-message"><span class="termRef">message</span></a> in every
  other supported serialization. These equivalent messages have a
  different <a href="#def-message-format"><span class="termRef">message
  format</span></a>, but have the same <a
  href="#def-message-type"><span class="termRef">message
  type</span></a>. For example, the XML message and the JSON message in
  <a href="#ex3-2">example 3-2</a> above are equivalent. They represent
  the same information content, and can be converted one to the other
  without loss of information.</p>
  <p>A <a href="#def-message-type"><span class="termRef">message
  type</span></a> specifies the information content of its messages
  without prescribing their syntax. A <a
  href="#def-message-type"><span class="termRef">message type</span></a>
  includes a <a href="#def-message-model"><span class="termRef">message
  model</span></a>, which is the means through which the message
  designer precisely defines the mandatory and optional content of
  conforming messages and the meaning of that content. This model is
  expressed in either of NIEM's two model representations, which are
  described in <a href="#34-the-niem-metamodel">section 3.4</a> and <a
  href="#35-niem-model-representations-xsd-and-cmf">section 3.5</a>, and
  fully defined in <a href="#4-data-models-in-niem">section 4</a>. <a
  href="#ex3-4">Example 3-4</a> shows a portion of the message model for
  the two message formats in <a href="#ex3-3">example 3-3</a>.</p>
  <pre><code>&lt;xs:complexType name=&quot;ItemType&quot; appinfo:referenceCode=&quot;NONE&quot;&gt; | &lt;Class structures:id=&quot;nc.ItemType&quot;&gt;
  &lt;xs:annotation&gt;                                             |   &lt;Name&gt;ItemType&lt;/Name&gt;
    &lt;xs:documentation&gt;A data type for an article or thing.    |   &lt;Namespace structures:ref=&quot;nc&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;/xs:annotation&gt;                                            |   &lt;DocumentationText&gt;A data type for an article or th
  &lt;xs:complexContent&gt;                                         |   &lt;ReferenceCode&gt;NONE&lt;/ReferenceCode&gt;
    &lt;xs:extension base=&quot;structures:ObjectType&quot;&gt;               |   &lt;ChildPropertyAssociation&gt;
      &lt;xs:sequence&gt;                                           |     &lt;DataProperty structures:ref=&quot;nc.ItemName&quot; xsi:nil=&quot;true&quot;/&gt;
        &lt;xs:element ref=&quot;nc:ItemName&quot;/&gt;                       |     &lt;MinOccursQuantity&gt;1&lt;/MinOccursQuantity&gt;
        &lt;xs:element ref=&quot;nc:ItemQuantity&quot;/&gt;                   |     &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;
      &lt;/xs:sequence&gt;                                          |   &lt;/ChildPropertyAssociation&gt;
    &lt;/xs:extension&gt;                                           |   &lt;ChildPropertyAssociation&gt;
  &lt;/xs:complexContent&gt;                                        |     &lt;DataProperty structures:ref=&quot;nc.ItemQuantity&quot;
&lt;/xs:complexType&gt;                                             |     &lt;MinOccursQuantity&gt;1&lt;/MinOccursQuantity&gt;
&lt;xs:element name=&quot;ItemName&quot; type=&quot;nc:TextType&quot;&gt;               |     &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;
  &lt;xs:annotation&gt;                                             |   &lt;/ChildPropertyAssociation&gt;
    &lt;xs:documentation&gt;A name of an item.&lt;/xs:documentation&gt;   | &lt;/Class&gt;
  &lt;/xs:annotation&gt;                                            | &lt;DataProperty structures:id=&quot;nc.ItemName&quot;&gt;
&lt;/xs:element&gt;                                                 |   &lt;Name&gt;ItemName&lt;/Name&gt;
&lt;xs:element name=&quot;RequestedItem&quot; type=&quot;nc:ItemType&quot;&gt;          |   &lt;Namespace structures:ref=&quot;nc&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;xs:annotation&gt;                                             |   &lt;DocumentationText&gt;A name of an item.
    &lt;xs:documentation&gt;A specification of an item request.&lt;/xs |   &lt;Datatype structures:ref=&quot;nc.TextType&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;/xs:annotation&gt;                                            | &lt;/DataProperty&gt;
&lt;/xs:element&gt;                                                 | &lt;ObjectProperty structures:id=&quot;msg.RequestedItem&quot;&gt;
                                                              |   &lt;Name&gt;RequestedItem&lt;/Name&gt;
                                                              |   &lt;Namespace structures:ref=&quot;msg&quot; xsi:nil=&quot;true&quot;/&gt;
                                                              |   &lt;DocumentationText&gt;A specification of an item
                                                              |   &lt;Class structures:ref=&quot;nc.ItemType&quot; xsi:nil=&quot;true&quot;/&gt;
                                                              |   &lt;ReferenceCode&gt;NONE&lt;/ReferenceCode&gt;
                                                              | &lt;/ObjectProperty&gt;</code></pre>
  <figcaption><a name="ex3-4">Example 3-4: Example message model in XSD and CMF</a></figcaption>

  <p>In addition to the <a
  href="#def-message-model"><span class="termRef">message
  model</span></a>, a <a
  href="#def-message-type"><span class="termRef">message type</span></a>
  also declares the initial property of conforming messages. In a
  conforming message, the <a
  href="#def-message-object"><span class="termRef">message
  object</span></a> is always the value of the initial property; this is
  the <a href="#def-message-property"><span class="termRef">message
  property</span></a>. For example, the <a
  href="#def-message-type"><span class="termRef">message type</span></a>
  for the <a
  href="#def-message"><span class="termRef">message</span></a> in <a
  href="#ex3-2">example 3-2</a> declares that the initial property is
  <code>msg:Request</code>.</p>
  <p>A <a href="#def-message-type"><span class="termRef">message
  type</span></a> provides all of the information needed to generate the
  schema for each <a
  href="#def-message-format"><span class="termRef">message
  format</span></a> it specifies. NIEMOpen provides free and open-source
  software tools to generate these schemas from the message model; see
  <a href="#niem-tools"><b>[NIEM-Tools]</b></a>. (Message designers may
  also compose these schemas by hand, if desired.)</p>
  <p>A conforming <a
  href="#def-message-type"><span class="termRef">message type</span></a>
  must satisfy all of the rules in <a
  href="#11-rules-for-message-types-and-message-formats">section
  11</a>.</p>
  <h3 id="314-message-specification">3.1.4 Message specification</h3>
  <p>A <a
  href="#def-message-specification"><span class="termRef">message
  specification</span></a> is a collection of related <a
  href="#def-message-type"><span class="termRef">message
  types</span></a>. For instance, a Request message type might be paired
  with a Response message type as part of a request/response protocol.
  Those two message types could be collected into a <a
  href="#def-message-specification"><span class="termRef">message
  specification</span></a> for the protocol, as illustrated below in <a
  href="#ex3-5">example 3-5</a>.</p>
  <figure>
    <img src="images/messageSpec.png" alt="figure" style="zoom:100%"/>
    <figcaption><a name="ex3-5">Example 3-5: Message specifications, types, and formats</a></figcaption>
  </figure>

  <p><strong>Summary:</strong></p>
  <ul>
  <li>A <a
  href="#def-message-specification"><span class="termRef">message
  specification</span></a> defines one or more <a
  href="#def-message-type"><span class="termRef">message
  types</span></a>; a <a
  href="#def-message-type"><span class="termRef">message type</span></a>
  belongs to one <a
  href="#def-message-specification"><span class="termRef">message
  specification</span></a></li>
  <li>A <a href="#def-message-type"><span class="termRef">message
  type</span></a> defines one or more <a
  href="#def-message-format"><span class="termRef">message
  formats</span></a>; a <a
  href="#def-message-format"><span class="termRef">message
  format</span></a> belongs to one <a
  href="#def-message-type"><span class="termRef">message
  type</span></a></li>
  <li>A <a href="#def-message-format"><span class="termRef">message
  format</span></a> defines the syntax of valid <a
  href="#def-message"><span class="termRef">messages</span></a></li>
  <li>A <a href="#def-message-type"><span class="termRef">message
  type</span></a> defines the semantics of valid messages, plus their
  mandatory and optional content</li>
  <li>A <a href="#def-message"><span class="termRef">message</span></a>
  is an instance of a <a
  href="#def-message-format"><span class="termRef">message
  format</span></a> and of that format's <a
  href="#def-message-type"><span class="termRef">message
  type</span></a></li>
  </ul>
  <h2 id="32-reuse-of-community-agreed-data-models">3.2 Reuse of
  community-agreed data models</h2>
  <p>NIEM is also a framework allowing communities to create <a
  href="#def-reuse-model"><span class="termRef">reuse models</span></a>
  for concepts that are useful in multiple data specifications. These
  community models are typically not <em>complete</em> for any
  particular specification. Instead, they reflect the community's
  judgement on which definitions are <em>worth the trouble of
  agreement</em>. The NIEM core model contains definitions found useful
  by the NIEM community as a whole. NIEM domain models reuse the core,
  extending it with definitions found useful by the domain community.
  The core model plus the domain models comprise the "NIEM model". <a
  href="#fig3-6">Figure 3-6</a> below illustrates the relationships
  between domain communities and community models.</p>
  <figure>
    <img src="images/community.png" alt="figure" style="zoom:100%"/>
    <figcaption><a name="fig3-6">Figure 3-6: NIEM communities and data models</a></figcaption>
  </figure>

  <p>Message designers reuse definitions from the NIEM model, selecting
  a (usually small) subset of definitions that express a part of their
  information requirement. Message designers then create model
  extensions, adding components that do not yet exist in the NIEM model.
  These local extensions could be useful to others in the community
  beyond the scope of the original message, and may be submitted for
  potential adoption into the NIEM model (see
  <code class="uri-nb">https://github.com/niemopen/niem-model/issues</code>).</p>
  <p>NIEM's policy of easy model extension supports easy reuse of
  community data models. Because a community model does not need to be
  complete for the union of all needs, each community may focus its
  effort on its common needs, where the effort of agreement has the
  highest value. Data definitions that are not common, that are needed
  only for a particular message appear only as extensions in that
  message type, and need be learned only by the message developers who
  implement it. Model extensions are further described in <a
  href="#37-model-extensions">section 3.7</a>.</p>
  <p>Data model reuse is especially useful in a large enterprise. Its
  value grows with the number of developer teams, and with the degree of
  commonality in the shared data. NIEM was originally designed for data
  sharing among federal, state, and local governments — where
  commonality and number of developer teams is large indeed.</p>
  <h2 id="33-reuse-of-open-standards">3.3 Reuse of open standards</h2>
  <p>NIEM is built on a foundation of open standards, primarily:</p>
  <ul>
  <li>XML and XSD — message serialization and validation; also a
  modeling formalism</li>
  <li>JSON and JSON-LD — message serialization and linked data</li>
  <li>JSON Schema — message validation</li>
  <li>RDF, RDFS, and OWL — formal semantics</li>
  <li>ISO 11179 — conventions for data element names and
  documentation</li>
  </ul>
  <p>One of NIEM's principles is to reuse well-known information
  technology standards when these are supported by free and open-source
  software. NIEM avoids reuse of standards that effectively depend on
  proprietary software. When the NIEMOpen project defines a standard of
  its own, it also provides free and open-source software to support
  it.</p>
  <h2 id="34-the-niem-metamodel">3.4 The NIEM metamodel</h2>
  <p>A data model in NIEM is either a <a
  href="#def-message-model"><span class="termRef">message
  model</span></a>, defining the information content of a <a
  href="#def-message-type"><span class="termRef">message
  type</span></a>, or a <a
  href="#def-reuse-model"><span class="termRef">reuse model</span></a>,
  making the agreed definitions of a community available for reuse. The
  information required for those purposes can itself be modeled. The
  model of that information is the <em>NIEM metamodel</em> -- an
  abstract model for NIEM data models. The metamodel is expressed in
  UML, and is described in detail in <a
  href="#4-data-models-in-niem">section 4</a>. At a high level, the
  major components of the metamodel are properties, classes, datatypes,
  namespaces, and models. <a href="#fig3-7">Figure 3-7</a> provides an
  illustration.</p>
  <figure>
    <a name="fig3-2"/></a>
    <img src="images/highLevel.png"/>
    <figcaption><a name="fig3-7">Figure 3-7: High-level view of the NIEM metamodel</a></figcaption>
  </figure>

  <ul>
  <li><p>A <em>property</em> is a concept, idea, or thing. It defines a
  field that may appear in a <a
  href="#def-message"><span class="termRef">message</span></a> and can
  contain subfields (for objects / object properties) or a value (for
  literals / data properties). For example, in <a href="#ex3-4">example
  3-4</a>, <code>req:RequestedItem</code> and <code>nc:ItemName</code>
  are names of properties. <code>req:RequestedItem</code> is an object
  property for the requested item; <code>nc:ItemName</code> is a data
  property for the name of the item. The meaning of these properties is
  captured in the documentation text.</p></li>
  <li><p>A <em>class</em> defines the properties that may appear in the
  content of a corresponding <em>object</em> in a <a
  href="#def-message"><span class="termRef">message</span></a>. A class
  has one or more <em>properties</em>. An <em>object property</em> in a
  class defines a subject-property-value relationship between two
  objects. A <em>data property</em> defines a relationship between an
  object and a literal value. In <a href="#ex3-4">example 3-4</a>,
  <code>nc:ItemType</code> is the name of a class.</p></li>
  <li><p>A <em>datatype</em> defines the allowed values of a
  corresponding <em>literal value</em> in a <a
  href="#def-message"><span class="termRef">message</span></a>. In <a
  href="#ex3-4">example 3-4</a>, <code>nc:TextType</code> is the name of
  a datatype.</p></li>
  <li><p>Classes and datatypes are the two kinds of <em>type</em> in the
  metamodel. For historical reasons, the name of every class and
  datatype in the NIEM model ends in "Type". That is why this high-level
  view of the metamodel includes the abstract Type UML class.</p></li>
  <li><p>Classes, datatypes, and properties are the three kinds of
  metamodel <em>component</em>. (All of the common properties of classes
  and datatypes are defined in the Component class, which is why the
  abstract Type class is not needed in the detailed metamodel diagram in
  <a href="#4-data-models-in-niem">section 4</a>.)</p></li>
  <li><p>A <em>namespace</em> is a collection of uniquely-named
  components defined by an authority. (See <a
  href="#36-namespaces">section 3.6</a>)</p></li>
  <li><p>A <em>model</em> is a collection of components (organized into
  namespaces) and their relationships.</p></li>
  </ul>
  <p><a href="#fig3-8">Figure 3-8</a> below illustrates the
  relationships among metamodel components, NIEM model components, and
  the corresponding <a
  href="#def-message"><span class="termRef">message</span></a> objects
  and values.</p>
  <figure class="image">
    <a name="fig3-3"/></a>
    <img src="images/msg+meta.png" style="zoom:100%"/>
    <figcaption><a name="fig3-8">Figure 3-8: Message, message model, and metamodel relationships</a></figcaption>
  </figure>

  <p>A NIEM <a
  href="#def-message"><span class="termRef">message</span></a> contains
  properties which are based on objects or literal values. These are
  specified by the class, property, and datatype objects in a NIEM <a
  href="#def-message-model"><span class="termRef">message
  model</span></a>, which defines the content of a conforming <a
  href="#def-message"><span class="termRef">message</span></a> and also
  defines the meaning of that content. For example, in <a
  href="#fig3-8">figure 3-8</a>, the <em>item object</em> is defined by
  the <code>nc:ItemType</code> Class object; the <em>literal value</em>
  (<code>Wrench</code>) is defined by the <code>xs:string</code>
  Datatype object, and the property relationship between the two is
  defined by the <code>nc:ItemName</code> DataProperty object.</p>
  <p>Note that the term <em>object</em> is used in the context of
  messages and models. Within a NIEM <a
  href="#def-message"><span class="termRef">message</span></a>, an
  object is the value of a property, representing facts at runtime. A
  message object has a class. In <a href="#ex3-2">example 3-2</a>, the
  <code>msg:RequestedItem</code> XML element is an object, as is the
  value of the JSON key with the same name. These objects are instances
  of the <code>nc:ItemType</code> class.</p>
  <p>Within a NIEM model, an object is an instance of a metamodel Class,
  Datatype, or Property. In <a href="#ex3-3">example 3-3</a>,
  <code>nc:ItemType</code> is a Class object represented by the complex
  type definition in XSD, or by the Class element in CMF.</p>
  <h2 id="35-niem-model-representations-xsd-and-cmf">3.5 NIEM model
  representations: XSD and CMF</h2>
  <p>The abstract metamodel has two concrete representations: NIEM XSD
  and NIEM CMF. These are equivalent representations and may be
  converted from one to the other without loss. (NIEMOpen provides free
  and open-source software tools that perform the conversion; see
  <code class="uri-nb">https://github.com/niemopen/ntac-admin/tree/main/tools</code>.)</p>
  <p>Every version of NIEM has used a profile of XML Schema (XSD) as a
  NIEM model representation. In XSD, a NIEM model is represented as a
  schema assembled from a collection of schema documents. Every aspect
  of the metamodel is represented in some way by a schema component.</p>
  <p>XSD as a model representation directly supports conformance testing
  of NIEM XML messages through schema validation. However, JSON
  developers (and developers working with other formats) cannot use XSD
  to validate their messages. Nor do they want to read XSD
  specifications of message content. For this reason, NIEM 6 introduces
  the Common Model Format (CMF), which is a NIEM model representation
  intended to support all developers.</p>
  <p>CMF is the result of applying the NIEM framework to the information
  requirements in the metamodel. That result is a NIEM-based <a
  href="#def-message-type"><span class="termRef">message
  type</span></a>, which is part of a <a
  href="#def-message-specification"><span class="termRef">message
  specification</span></a>, which is published in
  <a href="#cmf"><b>[CMF]</b></a>. In CMF, a model is represented as an
  instance of that <a
  href="#def-message-type"><span class="termRef">message
  type</span></a>; that is, a CMF <a
  href="#def-message"><span class="termRef">message</span></a>, also
  known as a <a href="#def-model-file"><span class="termRef">model
  file</span></a>.</p>
  <p>CMF is a technology-neutral model representation, because:</p>
  <ul>
  <li><p>A CMF model can be transformed into XSD for validation of XML
  messages, and into JSON Schema for validation of JSON
  messages.</p></li>
  <li><p>A CMF model can itself be represented in XML or JSON, according
  to developer preference. That is, like any other NIEM message, the CMF
  representation of a model can be serialized in either XML or JSON. For
  example, <a href="#ex3-9">example 3-9</a> shows a portion of the
  message model from <a href="#ex3-4">example 3-4</a> in both XML and
  JSON syntax.</p></li>
  </ul>
  <pre><code>&lt;Class structures:id=&quot;nc.ItemType&quot;&gt;                              | {
  &lt;Name&gt;ItemType&lt;/Name&gt;                                          |   &quot;cmf:Class&quot;: {
  &lt;Namespace structures:ref=&quot;nc&quot; xsi:nil=&quot;true&quot;/&gt;                |     &quot;cmf:Name&quot;: &quot;ItemType&quot;,
  &lt;DocumentationText&gt;A data type for an article or thing.&lt;/Docum |     &quot;cmf:Namespace&quot;: { &quot;@id&quot;: &quot;#nc&quot; },
  &lt;ReferenceCode&gt;NONE&lt;/ReferenceCode&gt;                            |     &quot;cmf:DocumentationText&quot;: &quot;A data type for an article
  &lt;ChildPropertyAssociation&gt;                                     |     &quot;cmf:ReferenceCode&quot;: &quot;NONE&quot;,
    &lt;DataProperty structures:ref=&quot;nc.ItemName&quot; xsi:nil=&quot;true&quot;/&gt;  |     &quot;cmf:PropertyAssociation&quot;: {
    &lt;MinOccursQuantity&gt;1&lt;/MinOccursQuantity&gt;                     |       &quot;cmf:DataProperty&quot;: { &quot;@id&quot;: &quot;#nc.ItemName&quot; },
    &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;                     |       &quot;cmf:MinOccursQuantity&quot;: 1,
  &lt;/ChildPropertyAssociation&gt;                                    |       &quot;cmf:MaxOccursQuantity&quot;: 1
  &lt;ChildPropertyAssociation&gt;                                     |     },
    &lt;DataProperty structures:ref=&quot;nc.ItemQuantity&quot; xsi:nil=&quot;true |     &quot;cmf:PropertyAssociation&quot;: {
    &lt;MinOccursQuantity&gt;1&lt;/MinOccursQuantity&gt;                     |       &quot;cmf:DataProperty&quot;: { &quot;@id&quot;: &quot;#nc.ItemQuantity&quot; },
    &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;                     |       &quot;cmf:MinOccursQuantity&quot;: 1,
  &lt;/ChildPropertyAssociation&gt;                                    |       &quot;cmf:MaxOccursQuantity&quot;: 1
&lt;/Class&gt;                                                         |     }
                                                                 |   }
                                                                 | }</code></pre>
  <figcaption><a name="ex3-9">Example 3-9: CMF model in XML and JSON syntax</a></figcaption>

  <p><a href="#4-data-models-in-niem">Section 4</a> defines the mappings
  between the metamodel, NIEM XSD, and CMF.</p>
  <blockquote>
  <p>While NIEM uses JSON Schema to validate JSON messages, there is no
  JSON Schema representation of the metamodel, because JSON Schema does
  not have all of the necessary features to represent NIEM models.</p>
  </blockquote>
  <h2 id="36-namespaces">3.6 Namespaces</h2>
  <p>The components of a NIEM model are partitioned into
  <em>namespaces.</em> This prevents name clashes among communities or
  domains that have different business perspectives, even when they
  choose identical data names to represent different data concepts.</p>
  <p>Each namespace has an author, a person or organization that is the
  authoritative source for the namespace definitions. A namespace is the
  collection of model components for concepts of interest to the
  namespace author. Namespace cohesion is important: a namespace should
  be designed so that its components are consistent, may be used
  together, and may be updated at the same time.</p>
  <p>Each namespace must be uniquely identified by a URI. The namespace
  author must also be the URI's owner, as defined by
  <a href="#webarch"><b>[webarch]</b></a>. Both URNs and URLs are
  allowed. It is helpful, but not required, for the namespace URI to be
  accessible, returning the definition of the namespace content in a
  supported model format.</p>
  <p>NIEM defines two categories of authoritative namespace: <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> and <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a>.</p>
  <ul>
  <li><p><em>Reference namespace:</em> The NIEM model is a <a
  href="#def-reuse-model"><span class="termRef">reuse model</span></a>
  comprised entirely of <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespaces</span></a>. The components in these namespaces are intended
  for the widest possible reuse. They provide names and definitions for
  concepts, and relations among them. These namespaces are characterized
  by "optionality and over-inclusiveness". That is, they define more
  concepts than needed for any particular data exchange specification,
  without cardinality constraints, so it is easy to select the concepts
  that are needed and omit the rest. They also omit unnecessary range or
  length constraints on property datatypes.</p>
  <p>A <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> is intended to capture the meaning of its
  components. It is not intended for a complete definition of any
  particular <a href="#def-message-type"><span class="termRef">message
  type</span></a>. Message designers are expected to subset, profile,
  and extend the components in <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespaces</span></a> as needed to match their information exchange
  requirements.</p></li>
  <li><p><em>Extension namespace:</em> The components in an <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a> are intended for reuse within a more narrow scope
  than those defined in a <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a>. These components express the additional
  vocabulary required for an information exchange, above and beyond the
  vocabulary available from the NIEM model. The intended scope is often
  a particular <a
  href="#def-message-specification"><span class="termRef">message
  specification</span></a>. Sometimes a community or organization will
  define an <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a> for components to be reused in several related
  message specifications. In this case, the namespace components may
  also omit cardinality and datatype constraints, and may be incomplete
  for any particular <a
  href="#def-message-type"><span class="termRef">message
  type</span></a>.</p>
  <p>Message designers are encouraged to subset, profile, and extend the
  components in <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespaces</span></a> created by another author when these satisfy
  their modeling needs, rather than create new components.</p></li>
  </ul>
  <p>Namespaces are the units of model configuration management. Once
  published, the components in a <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> or <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a> may not be removed or changed in meaning. A
  change of that nature may only be made in a new namespace with a
  different URI.</p>
  <p>As a result of this rule, once a specific version of a namespace is
  published, it can no longer be modified. Updates must go into a new
  version of the namespace. All published versions of a namespace
  continue to be valid in support of older exchanges.</p>
  <p>In addition, note that a message specification contains its own
  copy of the schemas that they depend upon. Therefore new versions of a
  model or a namespace do not affect existing exchanges. Exchange
  partners may decide to upgrade to a new version of NIEM if they decide
  it suits their needs, but only if they choose to do so, and only on
  their own timeline. The NIEM release schedule does not force adopters
  to keep in sync.</p>
  <p>Message designers almost never require <em>all</em> the components
  in the NIEM model, and so NIEM defines a third namespace category:</p>
  <ul>
  <li><p><em>Subset namespace:</em> Technically, this is a "namespace
  subset", which contains only some of the components of a <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> or <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a>. It provides components for reuse, while enabling
  message designers and developers to:</p>
  <ul>
  <li><p>Omit optional components in a <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> or <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a> that they do not need.</p></li>
  <li><p>Provide cardinality and datatype constraints that precisely
  define the content of one or more message types.</p></li>
  </ul>
  <p>All message content that is valid for a subset namespace must also
  be valid for the <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> or <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a> with the same URI. Widening the value space of a
  component is not allowed. Adding components is not allowed. Changing
  the documentation of a component is not allowed.</p></li>
  </ul>
  <p>NIEM has a fourth namespace category, for namespaces containing
  components from standards or specifications that are based on XML but
  not based on NIEM.</p>
  <ul>
  <li><p><em>External namespace:</em> Any namespace defined by a <a
  href="#def-schema-document"><span class="termRef">schema
  document</span></a> that is not:</p>
  <ul>
  <li>a <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a></li>
  <li>an <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a></li>
  <li>a <a href="#def-subset-namespace"><span class="termRef">subset
  namespace</span></a></li>
  <li>the <a
  href="#def-structures-namespace"><span class="termRef">structures
  namespace</span></a>,
  <code>https://docs.oasis-open.org/niemopen/ns/model/structures/6.0/</code></li>
  <li>the XML namespace,
  <code>http://www.w3.org/XML/1998/namespace</code>.</li>
  </ul>
  <p>XML attributes defined in an external namespace may be part of a
  NIEM model. XML elements defined in an external namespace are not part
  of a NIEM model, but may be used as properties of an <a
  href="#def-adapter-type"><span class="termRef">adapter type</span></a>
  <em>(see <a
  href="#94-rules-for-adapters-and-external-components">§9.4</a></em>).</p></li>
  </ul>
  <p>Three special namespaces do not fit into any of the four
  categories:</p>
  <ul>
  <li><p>The <a
  href="#def-structures-namespace"><span class="termRef">structures
  namespace</span></a> is not part of any NIEM model. It provides base
  types and attributes that are used in the XSD representation of NIEM
  models.</p></li>
  <li><p>The XML namespace is not considered to be an external
  namespace. It defines the <code>xml:lang</code> attribute, which may
  be a component in a NIEM model.</p></li>
  <li><p>The XSD namespace
  (<code>http://www.w3.org/2001/XMLSchema</code>) defines the primitive
  datatypes (<code>xs:string</code>, etc.) This namespace appears
  explicitly in CMF model representations, and is implicitly part of
  every XSD representation.</p></li>
  </ul>
  <h2 id="37-model-extensions">3.7 Model extensions</h2>
  <p>Reuse of a community data model typically supplies some but not all
  of the necessary data definitions. Model extension allows a model
  designer to supply the missing definitions. NIEM has two forms of
  model extension: subclassing and augmentation.</p>
  <p>In a <em>subclass</em>, a namespace designer creates a new class in
  his own namespace to represent a special kind of thing. The new class
  shares all of the properties of its parent class, and adds properties
  belonging only to the new class. For example, in the NIEM model,
  <code>nc:Vehicle</code> is a subclass of <code>nc:Conveyance</code>.
  Like any Conveyance, a Vehicle may have the
  <code>nc:ConveyanceEngineQuantity</code> property, but only Vehicles
  have the <code>nc:VehicleSeatingQuantity</code> property; other
  Conveyances do not.</p>
  <p>In an <em>augmentation</em>, a namespace designer creates
  additional properties for a class that is defined in a different
  namespace. Here the designer is not creating a new class for a new
  kind of thing. Instead, he is providing properties which could have
  been defined by the original class designer, but in fact were not. For
  example, the designers of the NIEM Justice domain have augmented
  <code>nc:PersonType</code> with the
  <code>j:PersonSightedIndicator</code> property, because for the
  members of the Justice domain it is useful to record whether a person
  is able to see, even though to the NIEM community as a whole, adding
  this property to NIEM Core has not been worth the trouble.</p>
  <p>In general, augmentations are preferred over subclassing. At
  present the NIEM metamodel does not support multiple inheritance. If
  several domains were to create a subclass of
  <code>nc:PersonType</code>, there would be no way for a message
  designer to combine in his message model the properties of a person
  from NIEM Justice, NIEM Immigration, etc. Such a combination is easily
  done with augmentations.</p>
  <h2 id="38-model-and-message-semantics">3.8 Model and message
  semantics</h2>
  <p>The RDF Core Working Group of the World Wide Web consortium has
  developed a simple, consistent conceptual model, the RDF model. The
  RDF model is described and specified through a set of W3C
  Recommendations, the Resource Description Framework (RDF)
  specifications, making it a very well defined standard. The
  interpretations of NIEM models and messages are based on the RDF
  model. This provides numerous advantages:</p>
  <ul>
  <li>NIEM’s conceptual model is defined by a recognized standard.</li>
  <li>NIEM’s conceptual model is very well defined.</li>
  <li>NIEM’s conceptual model provides a consistent basis for relating
  attributes, elements, types, and other XML Schema components.</li>
  <li>NIEM’s use of the RDF model defines what a set of NIEM data means.
  The RDF specification provides a detailed description of what a
  statement means. This meaning is leveraged by NIEM.</li>
  <li>NIEM’s use of the RDF model provides a basis for inferring and
  reasoning about XML data that uses NIEM. That is, using the rules
  defined for the RDF model, programs can determine implications of
  relationships between NIEM-defined objects.</li>
  </ul>
  <p>Each construct in a NIEM model or message entails a number of RDF
  triples. NIEMOpen provides free and open-source software to generate
  those triples. The identifiers in these triples connect the message
  data to the model in a way that forms a <em>knowledge graph</em>. <a
  href="#ex3-10">Example 3-10</a> shows some of the triples entailed by
  the model in <a href="#ex3-4">example 3-4</a> and the message in <a
  href="#ex3-2">example 3-2</a>; <a href="#fig3-11">figure 3-11</a>
  shows a knowledge graph illustration of those triples.</p>
  <pre><code>nc:ItemType
  rdf:type owl:Class ;
  skos:definition &quot;A data type for an article or thing&quot; .

nc:ItemName
  rdf:type owl:DataProperty ;
  rdfs:range nc:TextType ;
  skos:definition &quot;A name of an item.&quot; .

msg:RequestedItem
  rdf:type owl:ObjectProperty ;
  rdfs:range nc:ItemType ;
  skos:definition &quot;A specification of an item request.&quot; .

_:b0 rdf:Type msg:RequestType .
_:b0 msg:RequestID &quot;RQ001&quot; .
_:b0 msg:RequestedItem _:b1 .
_:b1 rdf:type nc:ItemType .
_:b1 nc:ItemName &quot;Wrench&quot; .
_:b1 nc:ItemQuantity &quot;10&quot;^^xsd:decimal .</code></pre>
  <figcaption><a name="ex3-10">Example 3-10: RDF triples from a NIEM model and message</a></figcaption>

  <figure>
    <a name="fig3-11"/></a>
    <img src="images/kgraph.png"/>
    <figcaption><a name="fig3-11">Figure 3-11: Knowledge graph portrayal of a NIEM model and message</a></figcaption>
  </figure>

  <p>With the exception of <a
  href="#14-interpretation-of-niem-data"><em>section 14: Interpretation
  of NIEM data</em></a>, NIEM rules are explained in this document
  without reference to RDF or RDF concepts. Understanding RDF is not
  required to understand NIEM-conformant schemas or data based on NIEM.
  The knowledge graph representation of NIEM data is available to the
  message designers and developers who want it, without burdening those
  who do not.</p>
  <hr />
  <h1 id="4-data-models-in-niem">4. Data models in NIEM</h1>
  <p>The NIEM metamodel is an abstract model that specifies the content
  of a NIEM data model. It is described by the UML diagram in <a
  href="#fig4-1">figure 4-1</a> below.</p>
  <figure>
    <a name="fig4-1"/></a>
    <img src="images/metamodel.png" style="width:100%;"/>
    <figcaption><a name="fig4-1">Figure 4-1:The NIEM metamodel</a></figcaption>
  </figure>

  <p>This section specifies:</p>
  <ul>
  <li>the meaning of the classes, attributes, and relationships in the
  metamodel</li>
  <li>the meaning of the classes, datatypes, and properties in CMF,
  which implements the metamodel</li>
  <li>the XSD constructs that correspond to CMF classes, datatypes, and
  properties, and which also implement the metamodel</li>
  </ul>
  <p>In addition to the UML diagram, this section contains several
  tables that document the classes, attributes, and relationships in the
  metamodel. These tables have the following columns:</p>
  <table>
  <thead>
  <tr>
  <th>Column</th>
  <th>Definition</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Name</td>
  <td>the name of the class, attribute, or relationship</td>
  </tr>
  <tr>
  <td>Definition</td>
  <td>the definition of the object or property</td>
  </tr>
  <tr>
  <td>Card</td>
  <td>the number of times this property may/must appear in an
  object</td>
  </tr>
  <tr>
  <td>Ord</td>
  <td>true when the order of the instances of a repeatable property in
  an object is significant</td>
  </tr>
  <tr>
  <td>Range</td>
  <td>the class or datatype of a property</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-2">Table 4-2: Definition of columns in metamodel property tables</a></figcaption>

  <p>Classes, attributes, and relationships have the same names in the
  metamodel and in CMF. (Attributes and relationship names have lower
  camel case in the diagram and tables, following the UML convention.
  The tables and the CMF specification use the same names in upper camel
  case, following the NIEM convention.)</p>
  <p>The definitions in these tables follow NIEM rules for documentation
  (which are described in <a
  href="#72-rules-for-component-documentation">section 7.2</a>). As a
  result, the definition of each metamodel class begins with "A data
  type for..." instead of "A class for...". (For historical reasons, the
  name of every class and datatype in the NIEM model ends in "Type", and
  this is reflected in the conventions for documentation; see <a
  href="#34-the-niem-metamodel">section 3.4</a>.)</p>
  <p>Names from CMF and the metamodel do not appear in the XSD
  representation of a model. Instead, NIEM defines special
  interpretations of XML Schema components, making the elements and
  attributes in an XSD <a
  href="#def-schema-document"><span class="termRef">schema
  document</span></a> equivalent to CMF model components. The mapping
  between CMF components and XSD schema components is provided by a
  table in each section below, with these columns:</p>
  <table>
  <thead>
  <tr>
  <th>Column</th>
  <th>Definition</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>CMF</td>
  <td>CMF component name</td>
  </tr>
  <tr>
  <td>XSD</td>
  <td>XSD equivalent</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-3">Table 4-3: Definition of columns in CMF-XSD mapping tables</a></figcaption>

  <h2 id="41-model">4.1 Model</h2>
  <p>A Model object represents a NIEM model.</p>
  <figure>
    <a name="fig4-2"/></a>
    <img src="images/modelClass.png" style="zoom:100%"/>
    <figcaption><a name="fig4-4">Figure 4-4: Model class diagram</a></figcaption>
  </figure>

  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Model</td>
  <td>A data type for a NIEM data model.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>Component</td>
  <td>A data concept for a component of a NIEM data model.</td>
  <td style="text-align: center;">0..*</td>
  <td style="text-align: center;">-</td>
  <td>ComponentType</td>
  </tr>
  <tr>
  <td>Namespace</td>
  <td>A namespace of a data model component</td>
  <td style="text-align: center;">0..*</td>
  <td style="text-align: center;">-</td>
  <td>NamespaceType</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-5">Table 4-5: Properties of the Model object class</a></figcaption>

  <p>In XSD, an instance of the Model class is represented by a <a
  href="#def-schema-document-set"><span class="termRef">schema document
  set</span></a>.</p>
  <h2 id="42-namespace">4.2 Namespace</h2>
  <p>A Namespace object represents a namespace in a model. For example,
  the namespace with the URI
  <code>https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/</code>
  is a namespace in the NIEM 6.0 model.</p>
  <figure class="image">
    <a name="fig4-3"/></a>
    <img src="images/namespaceClass.png" style="zoom:100%"/>
    <figcaption><a name="fig4-6">Figure 4-6: Namespace class diagram</a></figcaption>
  </figure>

  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Namespace</td>
  <td>A data type for a namespace.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>NamespaceURI</td>
  <td>A URI for a namespace.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>xs:anyURI</td>
  </tr>
  <tr>
  <td>NamespacePrefixText</td>
  <td>A namespace prefix name for a namespace.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>xs:NCName</td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td>A human-readable text documentation of a namespace.</td>
  <td style="text-align: center;">1..*</td>
  <td style="text-align: center;">Y</td>
  <td>TextType</td>
  </tr>
  <tr>
  <td>NamespaceLanguageName</td>
  <td>A name of a default language of the terms and documentation text
  in a namespace.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>xs:language</td>
  </tr>
  <tr>
  <td>NamespaceVersionText</td>
  <td>A version of a namespace; for example, used to distinguish a
  namespace subset, bug fix, documentation change, etc.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>xs:token</td>
  </tr>
  <tr>
  <td>NamespaceCategoryCode</td>
  <td>A kind of namespace in a NIEM model (external, core, domain,
  etc.).</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>NamespaceCategoryCodeType</td>
  </tr>
  <tr>
  <td>ConformanceTargetURI</td>
  <td>A <a
  href="#def-conformance-target-identifier"><span class="termRef">conformance
  target identifier</span></a>.</td>
  <td style="text-align: center;">0..*</td>
  <td style="text-align: center;">-</td>
  <td>xs:anyURI</td>
  </tr>
  <tr>
  <td>ArchitectureVersionName</td>
  <td>A name of a version for the utility schema components used in an
  XSD representation of a namespace; e.g. "NIEM5.0" or "NIEM6.0".</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>xs:token</td>
  </tr>
  <tr>
  <td>DocumentFilePathText</td>
  <td>A relative file path from the top schema directory to a schema
  document for this namespace.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>xs:string</td>
  </tr>
  <tr>
  <td>ImportDocumentation</td>
  <td>A documentation of an xs:import element in a schema document.</td>
  <td style="text-align: center;">0..*</td>
  <td style="text-align: center;">-</td>
  <td>TextType</td>
  </tr>
  <tr>
  <td>AugmentationRecord</td>
  <td>An augmentation of a class with a property by a namespace.</td>
  <td style="text-align: center;">0..*</td>
  <td style="text-align: center;">-</td>
  <td>AugmentationType</td>
  </tr>
  <tr>
  <td>LocalTerm</td>
  <td>A data type for the meaning of a term that may appear within the
  name of a model component.</td>
  <td style="text-align: center;">0..*</td>
  <td style="text-align: center;">-</td>
  <td>LocalTermType</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-7">Table 4-7: Properties of the Namespace object class</a></figcaption>

  <p>In XSD, an instance of the Namespace class is represented by the
  <code>&lt;xs:schema&gt;</code> element in a schema document. <a
  href="#ex4-8">Example 4-8</a> shows the representation of a Namespace
  object in CMF and in the corresponding XSD.</p>
  <pre><code>&lt;Namespace&gt;
  &lt;NamespaceURI&gt;https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/&lt;/NamespaceURI&gt;
  &lt;NamespacePrefixText&gt;nc&lt;/NamespacePrefixText&gt;
  &lt;DocumentationText&gt;NIEM Core.&lt;/DocumentationText&gt;
  &lt;ConformanceTargetURI&gt;
    https://docs.oasis-open.org/niemopen/ns/specification/NDR/6.0/#ReferenceSchemaDocument
  &lt;/ConformanceTargetURI&gt;
  &lt;NamespaceVersionText&gt;ps02&lt;/NamespaceVersionText&gt;
  &lt;NamespaceLanguageName&gt;en-US&lt;/NamespaceLanguageName&gt;
&lt;/Namespace&gt;
---------------
&lt;xs:schema
  targetNamespace=&quot;https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/&quot;
  xmlns:ct=&quot;https://docs.oasis-open.org/niemopen/ns/specification/conformanceTargets/6.0/&quot;
  xmlns:nc=&quot;https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/&quot;
  xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
  ct:conformanceTargets=&quot;https://docs.oasis-open.org/niemopen/ns/specification/NDR/6.0/#ReferenceSchemaDocument&quot;
  version=&quot;ps02&quot;
  xml:lang=&quot;en-US&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;NIEM Core.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:schema&gt;</code></pre>
  <figcaption><a name="ex4-8">Example 4-8: Namespace object in CMF and XSD</a></figcaption>

  <p>The following table shows the mapping between Namespace object
  representations in CMF and XSD.</p>
  <table>
  <thead>
  <tr>
  <th>CMF</th>
  <th>XSD</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>NamespaceURI</td>
  <td><code>xs:schema/@targetNamespace</code></td>
  </tr>
  <tr>
  <td>NamespacePrefixText</td>
  <td>The prefix in the first namespace declaration of the target
  namespace</td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td><code>xs:schema/xs:annotation/xs:documentation</code></td>
  </tr>
  <tr>
  <td>ConformanceTargetURI</td>
  <td>Each of the URIs in the list attribute
  <code>xs:schema/@ct:conformanceTargets</code></td>
  </tr>
  <tr>
  <td>NamespaceVersionText</td>
  <td><code>xs:schema/@version</code></td>
  </tr>
  <tr>
  <td>NamespaceLanguageName</td>
  <td><code>xs:schema/@xml:lang</code></td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-9">Table 4-9: Namespace object properties in CMF and XSD</a></figcaption>

  <h2 id="43-component">4.3 Component</h2>
  <p>A Component is either a Class object, a Property object, or a
  Datatype object in a NIEM model. This abstract class defines the
  common properties of those three concrete subclasses.</p>
  <figure class="image">
    <a name="fig4-4"/></a>
    <img src="images/component.png" style="zoom:100%"/>
    <figcaption><a name="fig4-10">Figure 4-10: Component class diagram</a></figcaption>
  </figure>

  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Component</td>
  <td>A data type for common properties of a data model component in
  NIEM.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>Name</td>
  <td>The name of a data model component.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>xs:NCName</td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td>A human-readable text definition of a data model component.</td>
  <td style="text-align: center;">0..*</td>
  <td style="text-align: center;">Y</td>
  <td>TextType</td>
  </tr>
  <tr>
  <td>DeprecatedIndicator</td>
  <td>True for a deprecated schema component; that is, a component that
  is provided, but the use of which is not recommended.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>xs:boolean</td>
  </tr>
  <tr>
  <td>Namespace</td>
  <td>The namespace of a data model component.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>NamespaceType</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-11">Table 4-11: Properties of the Component abstract class</a></figcaption>

  <p>In XSD, the common properties of a Component object are represented
  by a complex type definition or an element or attribute declaration.
  <a href="#ex4-12">Example 4-12</a> shows the representation of those
  common properties in CMF and XSD.</p>
  <pre><code>&lt;DataProperty&gt;
  &lt;Name&gt;ActivityCompletedIndicator&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;nc&quot;/&gt;
  &lt;DocumentationText&gt;True if an activity has ended; false otherwise.&lt;/DocumentationText&gt;
  &lt;DeprecatedIndicator&gt;false&lt;/DeprecatedIndicator&gt;
---------------
&lt;xs:element name=&quot;ActivityCompletedIndicator&quot; type=&quot;niem-xs:boolean&quot; appinfo:deprecated=&quot;false&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;True if an activity has ended; false otherwise.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;</code></pre>
  <figcaption><a name="ex4-12">Example 4-12: Component object (abstract) in CMF and XSD</a></figcaption>

  <p>The following table shows the mapping between Component object
  properties in CMF and XSD.</p>
  <table>
  <thead>
  <tr>
  <th>CMF</th>
  <th>XSD</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Name</td>
  <td><code>@name</code> of an element or attribute declaration</td>
  </tr>
  <tr>
  <td>NamespaceURI</td>
  <td><code>@targetNamespace</code> of a schema document</td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td><code>xs:annotation/xs:documentation</code> of an element or
  attribute declaration</td>
  </tr>
  <tr>
  <td>DeprecatedIndicator</td>
  <td><code>@appinfo:deprecated</code> of an element or attribute
  declaration</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-13">Table 4-13: Component object properties in CMF and XSD</a></figcaption>

  <h2 id="44-class">4.4 Class</h2>
  <p>A Class object represents a class of message objects defined by a
  NIEM model. For example, <code>nc:ItemType</code> is a Class object in
  the NIEM Core model.</p>
  <figure class="image">
    <a name="fig4-6"/></a>
    <img src="images/class.png" style="zoom:100%"/>
    <figcaption><a name="fig4-14">Figure 4-14: Class, AnyPropertyAssociation, and ChildPropertyAssociation class diagram</a></figcaption>
  </figure>

  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Class</td>
  <td>A data type for a class.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>AbstractIndicator</td>
  <td>True if a class is a base for extension, and must be specialized
  to be used directly; false if a class may be used directly.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>xs:boolean</td>
  </tr>
  <tr>
  <td>ReferenceCode</td>
  <td>A code describing how a property may be referenced (or must appear
  inline).</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>ReferenceCodeType</td>
  </tr>
  <tr>
  <td>AnyPropertyAssociation</td>
  <td>An association between a class and a set of properties not fully
  specified by the model.</td>
  <td style="text-align: center;">0..*</td>
  <td style="text-align: center;">-</td>
  <td>AnyPropertyAssociationType</td>
  </tr>
  <tr>
  <td>SubClassOf</td>
  <td>A base class of a subclass.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>ClassType</td>
  </tr>
  <tr>
  <td>ChildPropertyAssociation</td>
  <td>An association between a class and a child property of that
  class.</td>
  <td style="text-align: center;">0..*</td>
  <td style="text-align: center;">Y</td>
  <td>ChildPropertyAssociationType</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-15">Table 4-15: Properties of the Class object class</a></figcaption>

  <p>The range of the <code>ReferenceCode</code> property is a <a
  href="#def-code-list"><span class="termRef">code list</span></a> with
  the following codes and meanings:</p>
  <table>
  <thead>
  <tr>
  <th>Code</th>
  <th>Definition</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>ANY</td>
  <td>A code for a reference that may be any IDREF or URI.</td>
  </tr>
  <tr>
  <td>ANYURI</td>
  <td>A code for a reference that may be any URI.</td>
  </tr>
  <tr>
  <td>INTERNAL</td>
  <td>A code for a reference to an object in the same message; an IDREF,
  or a relative URI.</td>
  </tr>
  <tr>
  <td>RELURI</td>
  <td>A code for a reference that is a relative URI.</td>
  </tr>
  <tr>
  <td>IDREF</td>
  <td>A code for a reference that is an IDREF in XML, or a relative URI
  in an otherwise-empty JSON object; an object pointer.</td>
  </tr>
  <tr>
  <td>NONE</td>
  <td>A code for a property that may not be referenced and must appear
  inline.</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-16">Table 4-16: ReferenceCode code list</a></figcaption>

  <p>Class objects may be categorized into four groups, as follows:</p>
  <ul>
  <li><p>An <a href="#def-object-class"><span class="termRef">object
  class</span></a> contains one or more properties from a <a
  href="#def-conforming-namespace"><span class="termRef">conforming
  namespace</span></a>. An <a
  href="#def-object-class"><span class="termRef">object class</span></a>
  has a name ending in "Type". Most class objects fall into this
  category.</p></li>
  <li><p>An <a href="#def-adapter-class"><span class="termRef">adapter
  class</span></a> contains only properties from a single <a
  href="#def-external-namespace"><span class="termRef">external
  namespace</span></a>. It acts as a conformance wrapper around data
  components defined in standards that are not NIEM conforming. An <a
  href="#def-adapter-class"><span class="termRef">adapter
  class</span></a> has a name ending in "AdapterType". (See <a
  href="#94-rules-for-adapters-and-external-components">section
  9.4</a>.)</p></li>
  <li><p>An <a
  href="#def-association-class"><span class="termRef">association
  class</span></a> represents a specific relationship between objects.
  Associations are used when a simple NIEM property is insufficient to
  model the relationship clearly, or to model properties of the
  relationship itself. An <a
  href="#def-association-class"><span class="termRef">association
  class</span></a> has a name ending in "AssociationType".</p></li>
  <li><p>A <a href="#def-literal-class"><span class="termRef">literal
  class</span></a> contains no object properties, at least one <a
  href="#def-attribute-property"><span class="termRef">attribute
  property</span></a>, and exactly one <a
  href="#def-element-property"><span class="termRef">element
  property</span></a>. A <a
  href="#def-literal-class"><span class="termRef">literal
  class</span></a> has a name ending in "Type".</p></li>
  </ul>
  <p>The instances of most classes (including adapter and association
  classes) are represented in XML as an element with complex content;
  that is, with child elements and sometimes attributes. For example, <a
  href="#ex4-17">example 4-17</a> shows an XML element with complex
  content, and also the equivalent in a JSON message.</p>
  <pre><code>&lt;ex:ItemWeightMeasure&gt;                                                       | &quot;ex:ItemWeightMeasure&quot;: {
  &lt;ex:MassUnitCode&gt;KGM&lt;/unece:MassUnitCode&gt;                                  |   &quot;ex:MassUnitCode&quot;: &quot;KGM&quot;,
  &lt;ex:MeasureDecimalValue&gt;22.5&lt;/ex:MeasureDecimalValue&gt;                      |   &quot;ex:MeasureDecimalValue&quot;: 22.5
&lt;/ex:ItemWeightMeasure&gt;                                                      | }</code></pre>
  <figcaption><a name="ex4-17">Example 4-17: Instance of a class in XML and JSON</a></figcaption>

  <p>These classes are represented in XSD as a complex type with complex
  content ("CCC type"); that is, a type with child elements. <a
  href="#ex4-18">Example 4-18</a> below shows a ordinary Class object
  defining the class of the <code>ItemWeightMeasure</code> property in
  the example above, represented first in CMF, and then in XSD as a
  complex type with child elements.</p>
  <pre><code>&lt;Class structures:id=&quot;ex.WeightMeasureType&quot;&gt;
  &lt;Name&gt;WeightMeasureType&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;ex&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;ChildPropertyAssociation&gt;
    &lt;DataProperty structures:ref=&quot;ex.MassUnitCode&quot; xsi:nil=&quot;true&quot;/&gt;
    &lt;MinOccursQuantity&gt;1&lt;/MinOccursQuantity&gt;
    &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;
  &lt;/PropertyAssociation}&gt;
  &lt;ChildPropertyAssociation&gt;
    &lt;DataProperty structures:ref=&quot;ex.MeasureDecimalValue&quot; xsi:nil=&quot;true&quot;/&gt;
    &lt;MinOccursQuantity&gt;1&lt;/MinOccursQuantity&gt;
    &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;
  &lt;/PropertyAssociation&gt;
&lt;/Class&gt;
---------------
&lt;xs:complexType name=&quot;WeightMeasureType&quot;&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base=&quot;structures:ObjectType&quot;&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref=&quot;ex:MassUnitCode&quot;/&gt;
        &lt;xs:element ref=&quot;ex:MeasureDecimalValue&quot;/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;</code></pre>
  <figcaption><a name="ex4-18">Example 4-18: A Class object in CMF and XSD (CCC type)</a></figcaption>

  <p>The following table shows the mapping between Class object
  representations in CMF and XSD.</p>
  <table>
  <thead>
  <tr>
  <th>CMF</th>
  <th>XSD</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>AbstractIndicator</td>
  <td><code>xs:complexType/@abstract</code></td>
  </tr>
  <tr>
  <td>ReferenceCode</td>
  <td><code>xs:complexType/@appinfo:referenceCode</code></td>
  </tr>
  <tr>
  <td>SubClassOf</td>
  <td><code>xs:complexType/xs:complexContent/xs:extension/@base</code></td>
  </tr>
  <tr>
  <td>ChildPropertyAssociation</td>
  <td><code>xs:complexType/xs:complexContent/xs:extension/xs:sequence/xs:element</code>
  or
  <code>xs:complexType/xs:complexContent/xs:extension/xs:attribute</code></td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-19">Table 4-19: Class object object properties in CMF and XSD</a></figcaption>

  <p>Instances of a <a
  href="#def-literal-class"><span class="termRef">literal
  class</span></a> are represented as an element with simple content and
  attributes in XML. <a href="#ex4-20">Example 4-20</a> below shows an
  XML and JSON instance of a literal class.</p>
  <pre><code>&lt;ex:ItemWeightMeasure ex:massUnitCode=&quot;KGM&quot;&gt;                           | &quot;ex:ItemWeightMeasure&quot;: {
  22.5                                                                 |   &quot;ex:massUnitCode&quot;: &quot;KGM&quot;,
&lt;/ex:ItemWeightMeasure&gt;                                                |   &quot;ex:WeightMeasureLiteral&quot;: 22.5
                                                                       | }</code></pre>
  <figcaption><a name="ex4-20">Example 4-20: Instance of a literal class in XML and JSON</a></figcaption>

  <p>A literal class is represented in XSD as a complex type with simple
  content ("CSC type") and attributes. This is illustrated in <a
  href="#ex4-21">example 4-21</a> below, which shows a <a
  href="#def-literal-class"><span class="termRef">literal
  class</span></a> defining the class of the
  <code>ItemWeightMeasure</code> property in <a href="#ex4-20">example
  4-20</a> above.</p>
  <pre><code>  &lt;Class structures:id=&quot;ex.WeightMeasureType&quot;&gt;
    &lt;Name&gt;WeightMeasureType&lt;/Name&gt;
    &lt;Namespace structures:ref=&quot;ex&quot; xsi:nil=&quot;true&quot;/&gt;
    &lt;ChildPropertyAssociation&gt;
      &lt;DataProperty structures:ref=&quot;ex.massUnitCode&quot; xsi:nil=&quot;true&quot;/&gt;
      &lt;MinOccursQuantity&gt;1&lt;/MinOccursQuantity&gt;
      &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;
    &lt;/ChildPropertyAssociation&gt;
    &lt;ChildPropertyAssociation&gt;
      &lt;DataProperty structures:ref=&quot;ex.WeightMeasureLiteral&quot; xsi:nil=&quot;true&quot;/&gt;
      &lt;MinOccursQuantity&gt;1&lt;/MinOccursQuantity&gt;
      &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;
    &lt;/ChildPropertyAssociation&gt;
  &lt;/Class&gt;
---------------
&lt;xs:complexType name=&quot;WeightMeasureType&quot;&gt;
  &lt;xs:simpleContent&gt;
    &lt;xs:extension base=&quot;xs:decimal&quot;&gt;
      &lt;xs:attribute ref=&quot;ex:massUnitCode&quot; use=&quot;required&quot;/&gt;
      &lt;xs:attributeGroup ref=&quot;structures:SimpleObjectAttributeGroup&quot;/&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;</code></pre>
  <figcaption><a name="ex4-21">Example 4-21: A literal class object in CMF and XSD (CSC type)</a></figcaption>

  <p>A <a href="#def-literal-class"><span class="termRef">literal
  class</span></a> always has one DataProperty that is not an <a
  href="#def-attribute-property"><span class="termRef">attribute
  property</span></a>. This property is named after the class, with
  "Type" replaced by "Literal" The property does not appear in the XSD
  representation of the literal class, or as a separate element in the
  XML message.</p>
  <p>A <a href="#def-literal-class"><span class="termRef">literal
  class</span></a> always has at least one <a
  href="#def-attribute-property"><span class="termRef">attribute
  property</span></a>. In XSD, a complex type with simple content and no
  attributes represents a <a href="#49-datatype">Datatype</a>, not a
  Class.</p>
  <h2 id="45-childpropertyassociation">4.5 ChildPropertyAssociation</h2>
  <p>An instance of the ChildPropertyAssociation class represents an
  association between a class and a child property of that class. For
  example, <code>nc:PersonMiddleName</code> property and
  <code>nc:personNameCommentText</code> are two child properties of the
  <code>nc:PersonType</code> class.</p>
  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>ChildPropertyAssociation</td>
  <td>A data type for an occurrence of a property as content of a
  class.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>MinOccursQuantity</td>
  <td>The minimum number of times a property may occur within an object
  of a class.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>xs:integer</td>
  </tr>
  <tr>
  <td>MaxOccursQuantity</td>
  <td>The maximum number of times a property may occur within an object
  of a class.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>MaxOccursType</td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td>A human-readable documentation of the association between a class
  and a child property content of that class.</td>
  <td style="text-align: center;">0..*</td>
  <td style="text-align: center;">Y</td>
  <td>TextType</td>
  </tr>
  <tr>
  <td>Property</td>
  <td>The property that occurs in the class.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>PropertyType</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-22">Table 4-22: Properties of the ChildPropertyAssociation object class</a></figcaption>

  <p>A ChildPropertyAssociation object is represented in XSD as an
  element or attribute reference within a complex type definition. <a
  href="#ex4-23">Example 4-23</a> shows the representation of two
  PropertyAssociation objects, first in CMF, and then in XSD.</p>
  <pre><code>&lt;ChildPropertyAssociation&gt;
  &lt;ObjectProperty structures:ref=&quot;nc.PersonMiddleName&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;MinOccursQuantity&gt;0&lt;/MinOccursQuantity&gt;
  &lt;MaxOccursQuantity&gt;unbounded&lt;/MaxOccursQuantity&gt;
  &lt;DocumentationText&gt;
    Documentation here is unusual; it refers to the association between the object and this property.
  &lt;/DocumentationText&gt;
&lt;/ChildPropertyAssociation&gt;
&lt;ChildPropertyAssociation&gt;
  &lt;DataProperty structures:ref=&quot;nc:personNameCommentText&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;MinOccursQuantity&gt;0&lt;/MinOccursQuantity&gt;
  &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;
&lt;/ChildPropertyAssociation&gt;
---------------
&lt;xs:sequence&gt;
  &lt;xs:element ref=&quot;nc:PersonMiddleName&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        Documentation here is unusual; it refers to the relationship between the object and this property.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
  &lt;/xs:element&gt;
&lt;/xs:sequence&gt;
&lt;xs:attribute ref=&quot;nc:personNameCommentText&quot; use=&quot;optional&quot;/&gt;</code></pre>
  <figcaption><a name="ex4-23">Example 4-23: ChildPropertyAssociation object in CMF and XSD</a></figcaption>

  <p>The following table shows the mapping between
  ChildPropertyAssociation representations in CMF and XSD.</p>
  <table>
  <thead>
  <tr>
  <th>CMF</th>
  <th>XSD</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Property</td>
  <td>The property object for <code>xs:element/@ref</code> or
  <code>xs:attribute/@ref</code>.</td>
  </tr>
  <tr>
  <td>MinOccursQuantity</td>
  <td><code>xs:element/@minOccurs</code> or
  <code>xs:attribute/@use</code></td>
  </tr>
  <tr>
  <td>MaxOccursQuantity</td>
  <td><code>xs:element/@maxOccurs</code></td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td><code>xs:element/xs:annotation/xs:documentation</code> or
  <code>xs:attribute/xs:annotation/xs:documentation</code></td>
  </tr>
  <tr>
  <td>OrderedPropertyIndicator</td>
  <td><code>xs:element/@appinfo:orderedPropertyIndicator</code></td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-24">Table 4-24: ChildPropertyAssociation object properties in CMF and XSD</a></figcaption>

  <h2 id="46-anypropertyassociation">4.6 AnyPropertyAssociation</h2>
  <p>An instance of the AnyPropertyAssociation class represents an
  association between a class and a "wildcard" set of possible
  properties that are not fully specified by the model. It is an exact
  analogue of the <code>xs:any</code> and <code>xs:anyAttribute</code>
  constructs in XSD.</p>
  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>AnyPropertyAssociation</td>
  <td>A data type for a set of partially specified properties of a
  class.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>MinOccursQuantity</td>
  <td>The minimum number of times the properties from the set may occur
  within an object of a class.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>xs:integer</td>
  </tr>
  <tr>
  <td>MaxOccursQuantity</td>
  <td>The maximum number of times the properties from the set may occur
  within an object of a class.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>MaxOccursType</td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td>A human-readable documentation of the association between a class
  and the set of unspecified properties.</td>
  <td style="text-align: center;">0..*</td>
  <td style="text-align: center;">Y</td>
  <td>TextType</td>
  </tr>
  <tr>
  <td>AttributeIndicator</td>
  <td>True for a set of partially specified properties represented as
  attributes in XML.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>xs:boolean</td>
  </tr>
  <tr>
  <td>NamespaceConstraintText</td>
  <td>A description of the namespace constraints on a partially
  specified property of a class.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>xs:string</td>
  </tr>
  <tr>
  <td>ProcessingCode</td>
  <td>A code describing the validation required for each partially
  specified property in the set.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>ProcessingCodeType</td>
  </tr>
  </tbody>
  </table>
  <p>An AnyPropertyAssociation object is represented in XSD as a schema
  wildcard. <a href="#ex4-25">Example 4-25</a> shows the representation
  of two AnyPropertyAssociation objects, first in CMF and then in
  XSD.</p>
  <pre><code>&lt;Class&gt;
  &lt;Name&gt;RequestType&lt;/Name&gt;
  &lt;Namespace structures.ref=&quot;msg&quot;/&gt;
  &lt;ChildPropertyAssociation&gt;
    &lt;Property structures:ref=&quot;msg.RequestID/&gt;
    &lt;MinOccursQuantity&gt;1&lt;/MinOccursQuantity&gt;
    &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;
  &lt;/ChildPropertyAssociation&gt;
  &lt;ChildPropertyAssociation&gt;
    &lt;Property structures:ref=&quot;msg.RequestedItem/&gt;
    &lt;MinOccursQuantity&gt;1&lt;/MinOccursQuantity&gt;
    &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;
  &lt;/ChildPropertyAssociation&gt;
  &lt;AnyPropertyAssociation&gt;
    &lt;MinOccursQuantity&gt;1&lt;/MinOccursQuantity&gt;
    &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;
    &lt;NamespaceConstraintText&gt;https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/&lt;/NamespaceConstraintText&gt;
    &lt;ProcessingCode&gt;strict&lt;/ProcessingCode&gt;
  &lt;/AnyPropertyAssociation&gt;
  &lt;AnyPropertyAssociation&gt;
    &lt;AttributeIndicator&gt;true&lt;/AttributeIndicator&gt;
    &lt;NamespaceConstraintText&gt;##targetNamespace&lt;/NamespaceConstraintText&gt;
    &lt;ProcessingCode&gt;lax&lt;/ProcessingCode&gt;
  &lt;/AnyPropertyAssociation&gt;
&lt;/Class&gt;
----------
&lt;xs:schema
  targetNamespace=&quot;http://example.com/ReqRes/1.0/&quot;
  xmlns:msg=&quot;ttp://example.com/ReqRes/1.0/&quot;
  xmlns:nc=&quot;https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/&quot; ... &gt;
  &lt;xs:complexType name=&quot;RequestType&quot;&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base=&quot;structures:ObjectType&quot;&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref=&quot;msg:RequestID&quot;/&gt;
          &lt;xs:element ref=&quot;msg:RequestedItem&quot;/&gt;
          &lt;xs:any namespace=&quot;https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/&quot; processContents=&quot;strict&quot;/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:anyAttribute namespace=&quot;##targetNamespace&quot; processContents=&quot;lax&quot;/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;</code></pre>
  <figcaption><a name="ex4-25">Example 4-25:  AnyPropertyAssociation objects in CMF and XSD</a></figcaption>

  <p>The meaning and valid values of NamespaceConstraintText and
  ProcessingCode are copied from <a href="#xml-schema"><b>[XML
  Schema]</b></a>. The following table shows the mapping between
  AnyPropertyAssociation representations in CMF and XSD.</p>
  <table>
  <thead>
  <tr>
  <th>CMF</th>
  <th>XSD</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Property</td>
  <td>The property object for <code>xs:element/@ref</code> or
  <code>xs:attribute/@ref</code>.</td>
  </tr>
  <tr>
  <td>MinOccursQuantity</td>
  <td><code>xs:element/@minOccurs</code> or
  <code>xs:attribute/@use</code></td>
  </tr>
  <tr>
  <td>MaxOccursQuantity</td>
  <td><code>xs:element/@maxOccurs</code></td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td><code>xs:element/xs:annotation/xs:documentation</code> or
  <code>xs:attribute/xs:annotation/xs:documentation</code></td>
  </tr>
  <tr>
  <td>AttributeIndicator</td>
  <td><code>xs:any</code> or <code>xs:anyAttribute</code></td>
  </tr>
  <tr>
  <td>NamespaceConstraintText</td>
  <td><code>@namespace</code></td>
  </tr>
  <tr>
  <td>ProcessingCode</td>
  <td><code>@processContents</code></td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-26">Table 4-26: ChildPropertyAssociation object properties in CMF and XSD</a></figcaption>

  <h2 id="47-property">4.7 Property</h2>
  <p>A Property object in a NIEM model is either an ObjectProperty or a
  DataProperty. This abstract class defines the common properties of
  those two concrete subclasses.</p>
  <figure class="image">
    <img src="images/property.png" style="zoom:100%"/>
    <figcaption><a name="fig4-27">Figure 4-27: Property class diagram</a></figcaption>
  </figure>

  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Property</td>
  <td>A data type for a property.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>AbstractIndicator</td>
  <td>True if a property must be specialized; false if a property may be
  used directly.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>xs:boolean</td>
  </tr>
  <tr>
  <td>OrderedPropertyIndicator</td>
  <td>True if the order of a repeated property within an object is
  significant.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>xs:boolean</td>
  </tr>
  <tr>
  <td>RelationshipIndicator</td>
  <td>True for a <a
  href="#def-relationship-property"><span class="termRef">relationship
  property</span></a>, a property that applies to the relationship
  between its parent and grandparent objects.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>xs:boolean</td>
  </tr>
  <tr>
  <td>SubPropertyOf</td>
  <td>A property of which a property is a subproperty.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>PropertyType</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-28">Table 4-28: Properties of the Property abstract class</a></figcaption>

  <p>Apart from the <a
  href="#def-message-object"><span class="termRef">message
  object</span></a>, every object in a message is a child property of
  another object, and typically provides information about that object.
  A <a
  href="#def-relationship-property"><span class="termRef">relationship
  property</span></a> instead provides information about the
  relationship between its parent and grandparent objects. <a
  href="#53-relationship-properties">Section 5.3</a> provides an
  example.</p>
  <p>The examples of a Property object in CMF and XSD, and the table
  showing the mapping between the CMF and XSD representations, are shown
  below in the definitions of the concrete subclasses, <a
  href="#48-objectproperty">ObjectProperty</a> and <a
  href="#49-dataproperty">DataProperty</a>.</p>
  <h2 id="48-objectproperty">4.8 ObjectProperty</h2>
  <p>An instance of the ObjectProperty class represents a property in a
  NIEM model with a range that is a class. For example, the
  <code>nc:PersonMiddleName</code> object in the NIEM core model is an
  object property with a range of the <code>nc:PersonNameTextType</code>
  class.</p>
  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>ObjectProperty</td>
  <td>A data type for an object property.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>ReferenceCode</td>
  <td>A code describing how a property may be referenced (or must appear
  inline).</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>ReferenceCodeType</td>
  </tr>
  <tr>
  <td>Class</td>
  <td>The class of this object property.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>ClassType</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-29">Table 4-29: Properties of the ObjectProperty object class</a></figcaption>

  <p>An ObjectProperty object is represented in XSD as an element
  declaration with a type that is a Class object. <a
  href="#ex4-30">Example 4-30</a> shows an ObjectProperty object,
  represented first in CMF, and then in XSD.</p>
  <pre><code>&lt;ObjectProperty structures:id=&quot;ex.ExampleObjectProperty&quot;&gt;
  &lt;Name&gt;ExampleObjectProperty&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;ex&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;DocumentationText&gt;Documentation text for ExampleObjectProperty.&lt;/DocumentationText&gt;
  &lt;DeprecatedIndicator&gt;false&lt;/DeprecatedIndicator&gt;
  &lt;AbstractIndicator&gt;true&lt;/AbstractIndicator&gt;
  &lt;ReferenceCode&gt;URI&lt;/ReferenceCode&gt;
  &lt;Class structures:ref=&quot;ex.ExType&quot; xsi:nil=&quot;true&quot;/&gt;
&lt;/ObjectProperty&gt;
---------------
&lt;xs:element name=&quot;ExampleObjectProperty&quot; type=&quot;ex:ExType&quot; abstract=&quot;true&quot; appinfo:referenceCode=&quot;URI&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;Documentation text for ExampleObjectProperty.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;</code></pre>
  <figcaption><a name="ex4-30">Example 4-30: ObjectProperty object in CMF and XSD</a></figcaption>

  <p>The following table shows the mapping between ObjectProperty object
  representations in CMF and XSD.</p>
  <table>
  <thead>
  <tr>
  <th>CMF</th>
  <th>XSD</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Namespace</td>
  <td>The namespace object for the containing schema document.</td>
  </tr>
  <tr>
  <td>Name</td>
  <td><code>xs:complexType/@name</code></td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td><code>xs:complexType/xs:annotation/xs:documentation</code></td>
  </tr>
  <tr>
  <td>DeprecatedIndicator</td>
  <td><code>xs:complexType/@appinfo:deprecated</code></td>
  </tr>
  <tr>
  <td>AbstractIndicator</td>
  <td><code>xs:complexType/@abstract</code></td>
  </tr>
  <tr>
  <td>SubPropertyOf</td>
  <td>The property object for
  <code>xs:element/@substitutionGroup</code></td>
  </tr>
  <tr>
  <td>RelationshipPropertyIndicator</td>
  <td><code>xs:element/@appinfo:relationshipPropertyIndicator</code></td>
  </tr>
  <tr>
  <td>Class</td>
  <td>The class object for <code>xs:element/@type</code></td>
  </tr>
  <tr>
  <td>ReferenceCode</td>
  <td><code>xs:complexType/@appinfo:referenceCode</code></td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-31">Table 4-31: ObjectProperty object properties in CMF and XSD</a></figcaption>

  <h2 id="49-dataproperty">4.9 DataProperty</h2>
  <p>An instance of the DataProperty class represents a property in a
  NIEM model with a range that is a datatype. For example, the
  <code>nc:personNameCommentText</code> property in the NIEM core model
  is a data property with a range of the <code>xs:string</code>
  datatype.</p>
  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>DataProperty</td>
  <td>A data type for a data property.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>AttributeIndicator</td>
  <td>True for a property that is represented as attributes in XML.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>xs:boolean</td>
  </tr>
  <tr>
  <td>RefAttributeIndicator</td>
  <td>True for a property that is an <a
  href="#def-reference-attribute-property"><span class="termRef">reference
  attribute property</span></a>.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>xs:boolean</td>
  </tr>
  <tr>
  <td>Datatype</td>
  <td>The datatype of this data property.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>DatatypeType</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-32">Table 4-32: Properties of the DataProperty object class</a></figcaption>

  <p>An <a
  href="#def-attribute-property"><span class="termRef">attribute
  property</span></a> is a data property in which
  <code>AttributeIndicator</code> is true. These are represented in XSD
  as an attribute declaration.</p>
  <p>A DataProperty object is represented in XSD as an attribute
  declaration, or as an element declaration with a type that is a
  Datatype object. <a href="#ex4-33">Example 4-33</a> shows the
  representations of two DataProperty objects, first in CMF, and then in
  the corresponding XSD.</p>
  <pre><code>&lt;DataProperty structures:id=&quot;ex.ExampleDataProperty&quot;&gt;
  &lt;Name&gt;ExampleDataProperty&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;ex&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;DocumentationText&gt;Documentation text for ExampleDataProperty.&lt;/DocumentationText&gt;
  &lt;DeprecatedIndicator&gt;true&lt;/DeprecatedIndicator&gt;
  &lt;AbstractIndicator&gt;true&lt;/AbstractIndicator&gt;
  &lt;SubPropertyOf structures:ref=&quot;ex.PropertyAbstract&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;Datatype structures:ref=&quot;ex.ExType&quot; xsi:nil=&quot;true&quot;/&gt;
&lt;/DataProperty&gt;
&lt;DataProperty structures:id=&quot;ex.exampleAttributeProperty&quot;&gt;
  &lt;Name&gt;exampleAttributeProperty&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;ex&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;DocumentationText&gt;Documentation text for AttributeProperty.&lt;/DocumentationText&gt;
  &lt;DeprecatedIndicator&gt;true&lt;/DeprecatedIndicator&gt;
  &lt;Datatype structures:ref=&quot;xs.string&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;AttributeIndicator&gt;true&lt;/AttributeIndicator&gt;
  &lt;RefAttributeIndicator&gt;true&lt;/RefAttributeIndicator&gt;
&lt;/DataProperty&gt;
---------------
&lt;xs:element name=&quot;ExampleDataProperty&quot; type=&quot;ex:ExType&quot; substitutionGroup=&quot;ex:PropertyAbstract&quot; appinfo:deprecated=&quot;true&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;Documentation text for ExampleDataProperty.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;
&lt;xs:attribute name=&quot;exampleAttributeProperty&quot; type=&quot;xs:string&quot; appinfo:referenceAttributeIndicator=&quot;true&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;Documentation text for ExampleDataProperty.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:attribute&gt;</code></pre>
  <figcaption><a name="ex4-33">Example 4-33: DataProperty object in CMF and XSD</a></figcaption>

  <p>The following table shows the mapping between DataProperty
  representations in CMF and XSD.</p>
  <table>
  <thead>
  <tr>
  <th>CMF</th>
  <th>XSD</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Namespace</td>
  <td>The namespace object for the containing schema document.</td>
  </tr>
  <tr>
  <td>Name</td>
  <td><code>xs:complexType/@name</code></td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td><code>xs:complexType/xs:annotation/xs:documentation</code></td>
  </tr>
  <tr>
  <td>DeprecatedIndicator</td>
  <td><code>xs:complexType/@appinfo:deprecated</code></td>
  </tr>
  <tr>
  <td>AbstractIndicator</td>
  <td><code>xs:complexType/@abstract</code></td>
  </tr>
  <tr>
  <td>SubPropertyOf</td>
  <td>The property object for
  <code>xs:element/@substitutionGroup</code></td>
  </tr>
  <tr>
  <td>RelationshipPropertyIndicator</td>
  <td><code>xs:element/@appinfo:relationshipPropertyIndicator</code></td>
  </tr>
  <tr>
  <td>Datatype</td>
  <td>The datatype object for <code>xs:element/@type</code></td>
  </tr>
  <tr>
  <td>AttributeIndicator</td>
  <td>True for an attribute declaration.</td>
  </tr>
  <tr>
  <td>RefAttributeIndicator</td>
  <td><code>xs:attribute/@appinfo:referenceAttributeIndicator</code></td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-34">Table 4-34: DataProperty object properties in CMF and XSD</a></figcaption>

  <h2 id="410-datatype">4.10 Datatype</h2>
  <figure class="image">
    <a name="fig4-13"/></a>
    <img src="images/datatype.png" style="zoom:100%"/>
    <figcaption><a name="fig4-35">Figure 4-35: Datatype classes</a></figcaption>
  </figure>

  <p>An instance of the Datatype class defines the allowed values of a
  data property in a <a
  href="#def-message"><span class="termRef">message</span></a>. Objects
  for primitive data types, corresponding to the XSD data types, have
  only the <em>name</em>, <em>namespace</em>, and <em>documentation</em>
  properties inherited from the Component class. For example, <a
  href="#ex4-38">example 4-38</a> shows the CMF representation of the
  <code>xs:string</code> primitive data type. Datatypes that are not
  built into XSD are represented by either a Restriction, List, or Union
  object.</p>
  <pre><code>&lt;Datatype&gt;
  &lt;Name&gt;string&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;xs&quot; xsi:nil=&quot;true&quot;/&gt;
&lt;/Datatype&gt;</code></pre>
  <figcaption><a name="ex4-36">Example 4-36: Plain CMF datatype object for `xs:string`</a></figcaption>

  <h2 id="411-list">4.11 List</h2>
  <p>An instance of the List class represents a NIEM model datatype with
  values that are a whitespace-separated list of literal values.</p>
  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>List</td>
  <td>A data type for a NIEM model datatype that is a
  whitespace-separated list of literal values.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>ListItemDatatype</td>
  <td>The datatype of the literal values in a list.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>DatatypeType</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-37">Table 4-37: Properties of the List object class </a></figcaption>

  <p>A List object is represented in XSD as a complex type definition
  that extends a simple type definition that has an <code>xs:list</code>
  element. <a href="#ex4-38">Example 4-38</a> shows the CMF and XSD
  representation of a List object.</p>
  <pre><code>&lt;List structures:id=&quot;ex.ExListType&quot;&gt;
  &lt;Name&gt;ExListType&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;ex&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;DocumentationText&gt;A data type for a list of integers.&lt;/DocumentationText&gt;
  &lt;ListItemDatatype structures:ref=&quot;xs.integer&quot; xsi:nil=&quot;true&quot;/&gt;
&lt;/List&gt;
---------------
&lt;xs:simpleType name=&quot;ExListSimpleType&quot;&gt;
  &lt;xs:list itemType=&quot;xs:integer&quot;/&gt;
&lt;/xs:simpleType&gt;
&lt;xs:complexType name=&quot;ExListType&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;A data type for a list of integers.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:simpleContent&gt;
    &lt;xs:extension base=&quot;ex:ExListSimpleType&quot;&gt;
      &lt;xs:attributeGroup ref=&quot;structures:SimpleObjectAttributeGroup&quot;/&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;</code></pre>
  <figcaption><a name="ex4-38">Example 4-38: List object in CMF and XSD</a></figcaption>

  <p>The following table shows the mapping between List object
  representations in CMF and XSD.</p>
  <table>
  <thead>
  <tr>
  <th>CMF</th>
  <th>XSD</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Namespace</td>
  <td>The namespace object for the containing schema document.</td>
  </tr>
  <tr>
  <td>Name</td>
  <td><code>xs:complexType/@name</code></td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td><code>xs:complexType/xs:annotation/xs:documentation</code></td>
  </tr>
  <tr>
  <td>DeprecatedIndicator</td>
  <td><code>xs:complexType/@appinfo:deprecated</code></td>
  </tr>
  <tr>
  <td>ListItemDatatype</td>
  <td><code>xs:simpleType/xs:list/@itemType</code></td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-39">Table 4-39: List object properties in CMF and XSD</a></figcaption>

  <h2 id="412-union">4.12 Union</h2>
  <p>An instance of the Union class represents a NIEM model datatype
  that is the union of one or more datatypes.</p>
  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Union</td>
  <td>A data type for a NIEM model datatype that is a union of
  datatypes.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>UnionMemberDatatype</td>
  <td>A NIEM model datatype that is a member of a union datatype.</td>
  <td style="text-align: center;">1..*</td>
  <td style="text-align: center;">-</td>
  <td>DatatypeType</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-40">Table 4-40: Properties of the Union object class</a></figcaption>

  <p>A Union object is represented in XSD as a complex type definition
  that extends a simple type definition that has an
  <code>xs:union</code> element. <a href="#ex4-41">Example 4-41</a>
  shows the XSD and CMF representations of a Union object.</p>
  <pre><code>&lt;Union structures:id=&quot;ex.UnionType&quot;&gt;
  &lt;Name&gt;UnionType&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;test&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;DocumentationText&gt;A data type for a union of integer and float datatypes.&lt;/DocumentationText&gt;
  &lt;UnionMemberDatatype structures:ref=&quot;xs.integer&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;UnionMemberDatatype structures:ref=&quot;xs.float&quot; xsi:nil=&quot;true&quot;/&gt;
&lt;/Union&gt;
---------------
&lt;xs:simpleType name=&quot;UnionSimpleType&quot;&gt;
  &lt;xs:union memberTypes=&quot;xs:integer xs:float&quot;/&gt;
&lt;/xs:simpleType&gt;
&lt;xs:complexType name=&quot;UnionType&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;A data type for a union of integer and float datatypes.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;  &lt;xs:simpleContent&gt;
    &lt;xs:extension base=&quot;ex:UnionSimpleType&quot;&gt;
      &lt;xs:attributeGroup ref=&quot;structures:SimpleObjectAttributeGroup&quot;/&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;</code></pre>
  <figcaption><a name="ex4-41">Example 4-41: Union object in CMF and XSD</a></figcaption>

  <p>The following table shows the mapping between UnionDatatype object
  representations in CMF and XSD.</p>
  <table>
  <thead>
  <tr>
  <th>CMF</th>
  <th>XSD</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Namespace</td>
  <td>The namespace object for the containing schema document.</td>
  </tr>
  <tr>
  <td>Name</td>
  <td><code>xs:complexType/@name</code></td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td><code>xs:complexType/xs:annotation/xs:documentation</code></td>
  </tr>
  <tr>
  <td>DeprecatedIndicator</td>
  <td><code>xs:complexType/@appinfo:deprecated</code></td>
  </tr>
  <tr>
  <td>UnionMemberDatatype</td>
  <td><code>xs:simpleType/xs:union/@memberTypes</code></td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-42">Table 4-42: Union object properties in CMF and XSD</a></figcaption>

  <h2 id="413-restriction">4.13 Restriction</h2>
  <p>An instance of the Restriction class represents a NIEM model
  datatype as a base datatype plus zero or more constraining facets.</p>
  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Restriction</td>
  <td>A data type for a restriction of a data type.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>RestrictionBase</td>
  <td>The NIEM model datatype that is restricted by this datatype.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>DatatypeType</td>
  </tr>
  <tr>
  <td>Facet</td>
  <td>A constraint on an aspect of a data type.</td>
  <td style="text-align: center;">0..*</td>
  <td style="text-align: center;">-</td>
  <td>FacetType</td>
  </tr>
  <tr>
  <td>CodeListBinding</td>
  <td>A property for connecting literal values defined by a data type to
  a a column of a <a href="#def-code-list"><span class="termRef">code
  list</span></a>.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>CodeListBindingType</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-43">Table 4-43: Properties of the Restriction object class</a></figcaption>

  <p>A Restriction object is represented in XSD as a complex type with
  simple content that contains an <code>xs:restriction</code> element.
  <a href="#ex4-44">Example 4-44</a> shows the CMF and XSD
  representations of a Restriction object.</p>
  <pre><code>&lt;Restriction structures:id=&quot;test.RestrictionType&quot;&gt;
  &lt;Name&gt;RestrictionType&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;test&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;DocumentationText&gt;Exercise code list binding&lt;/DocumentationText&gt;
  &lt;RestrictionBase structures:ref=&quot;xs.token&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;Facet&gt;
    &lt;FacetCategoryCode&gt;enumeration&lt;/FacetCategoryCode&gt;
    &lt;FacetValue&gt;GB&lt;/StringValue&gt;
  &lt;/Facet&gt;
  &lt;Facet&gt;
    &lt;FacetCategoryCode&gt;enumeration&lt;/FacetCategoryCode&gt;
    &lt;FacetValue&gt;US&lt;/StringValue&gt;
  &lt;/Facet&gt;
  &lt;CodeListBinding&gt;
    &lt;CodeListURI&gt;http://api.nsgreg.nga.mil/geo-political/GENC/2/3-11&lt;/CodeListURI&gt;
    &lt;CodeListColumnName&gt;foo&lt;/CodeListColumnName&gt;
    &lt;CodeListConstrainingIndicator&gt;true&lt;/CodeListConstrainingIndicator&gt;
  &lt;/CodeListBinding&gt;
&lt;/Restriction&gt;
---------------
&lt;xs:complexType name=&quot;RestrictionType&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:appinfo&gt;
      &lt;clsa:SimpleCodeListBinding codeListURI=&quot;http://api.nsgreg.nga.mil/geo-political/GENC/2/3-11&quot;
        columnName=&quot;foo&quot; constrainingIndicator=&quot;true&quot;/&gt;
    &lt;/xs:appinfo&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:simpleContent&gt;
    &lt;xs:restriction base=&quot;niem-xs:token&quot;&gt;
      &lt;xs:enumeration value=&quot;GB&quot;/&gt;
      &lt;xs:enumeration value=&quot;US&quot;/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;</code></pre>
  <figcaption><a name="ex4-44">Example 4-44: Restriction object in CMF and XSD</a></figcaption>

  <p>The following table shows the mapping between Restriction object
  representations in CMF and XSD.</p>
  <table>
  <thead>
  <tr>
  <th>CMF</th>
  <th>XSD</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Namespace</td>
  <td>The namespace object for the containing schema document.</td>
  </tr>
  <tr>
  <td>Name</td>
  <td><code>xs:complexType/@name</code></td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td><code>xs:complexType/xs:annotation/xs:documentation</code></td>
  </tr>
  <tr>
  <td>DeprecatedIndicator</td>
  <td><code>xs:complexType/@appinfo:deprecated</code></td>
  </tr>
  <tr>
  <td>RestrictionBase</td>
  <td>The datatype object for
  <code>xs:complexType/xs:simpleContent/xs:restriction/@base</code></td>
  </tr>
  <tr>
  <td>Facet</td>
  <td><code>xs:complexType/xs:simpleContent/xs:restriction/</code><em>facet-element</em></td>
  </tr>
  <tr>
  <td>CodeListBinding</td>
  <td><code>xs:complexType/xs:annotation/xs:appinfo/clsa:SimpleCodeListBinding</code></td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-45">Table 4-45: Restriction object properties in CMF and XSD</a></figcaption>

  <p>A <a href="#def-code-list"><span class="termRef">code
  list</span></a> is a set of string values, each having a known meaning
  beyond its value, each representing a distinct conceptual entity.
  These code values may be meaningful text or may be a string of
  alphanumeric identifiers that represent abbreviations for
  literals.</p>
  <p>A <a href="#def-code-list-datatype"><span class="termRef">code list
  datatype</span></a> is a Restriction in which each value that is valid
  for the datatype corresponds to a code value in a <a
  href="#def-code-list"><span class="termRef">code list</span></a>.</p>
  <p>Many <a href="#def-code-list-datatype"><span class="termRef">code
  list datatypes</span></a> have an XSD representation composed of
  <code>xs:enumeration</code> values. Code list datatypes may also be
  constructed using the <em>NIEM Code Lists Specification</em>
  <a href="#code-lists"><b>[Code Lists]</b></a>, which supports <a
  href="#def-code-list"><span class="termRef">code lists</span></a>
  defined using a variety of methods, including CSV spreadsheets; these
  are represented by a <a
  href="#415-codelistbinding">CodeListBinding</a> object, described in
  <a href="#415-codelistbinding">section 4.15</a> below.</p>
  <h2 id="414-facet">4.14 Facet</h2>
  <p>An instance of the Facet class specifies a constraint on the base
  datatype of a Restriction object.</p>
  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Facet</td>
  <td>A data type for a constraint on an aspect of a data type.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>FacetCategoryCode</td>
  <td>A kind of constraint on a restriction datatype.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>FacetCategoryCodeType</td>
  </tr>
  <tr>
  <td>FacetValue</td>
  <td>A value of a constraint on a restriction datatype.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>xs:string</td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td>A human-readable documentation of a constraint on a restriction
  datatype.</td>
  <td style="text-align: center;">0..*</td>
  <td style="text-align: center;">Y</td>
  <td>TextType</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-46">Table 4-46: Properties of the Facet object class</a></figcaption>

  <p>The range of the <code>FacetCategoryCode</code> property is a <a
  href="#def-code-list"><span class="termRef">code list</span></a>. The
  twelve codes correspond to the twelve constraining facets in
  <a href="#xml-schema-structures"><b>[XML Schema Structures]</b></a>;
  that is, the code <code>length</code> corresponds to the
  <code>xs:length</code> constraining facet in XSD, and constrains the
  valid values of the base datatype in the same way as the XSD
  facet.</p>
  <p>A Facet object is represented in XSD as a constraining facet on a
  simple type. <a href="#ex4-47">Example 4-47</a> shows the
  representation of two Facet objects, first in CMF, then in XSD:</p>
  <pre><code>&lt;Facet&gt;
  &lt;FacetCategoryCode&gt;minInclusive&lt;/FacetCategoryCode&gt;
  &lt;FacetValue&gt;0&lt;/FacetValue&gt;
&lt;/Facet&gt;
&lt;Facet&gt;
  &lt;FacetCategoryCode&gt;maxExclusive&lt;/FacetCategoryCode&gt;
  &lt;FacetValue&gt;360&lt;/FacetValue&gt;
&lt;/Facet&gt;
---------------
&lt;xs:restriction base=&quot;niem-xs:decimal&quot;&gt;
  &lt;xs:minInclusive value=&quot;0&quot;/&gt;
  &lt;xs:maxExclusive value=&quot;360&quot;/&gt;
&lt;/xs:restriction&gt;</code></pre>
  <figcaption><a name="ex4-47">Example 4-47: Facet object in CMF and XSD</a></figcaption>

  <p>The following table shows the mapping between Facet representations
  in CMF and XSD:</p>
  <table>
  <thead>
  <tr>
  <th>CMF</th>
  <th>XSD</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>FacetCategoryCode</td>
  <td><em>the local name of the facet element;
  e.g.</em><code>minInclusive</code></td>
  </tr>
  <tr>
  <td>FacetValue</td>
  <td><code>@value</code></td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td><code>xs:annotation/xs:documentation</code></td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-48">Table 4-48: Facet object properties in CMF and XSD</a></figcaption>

  <h2 id="415-codelistbinding">4.15 CodeListBinding</h2>
  <p>An instance of the CodeListBinding class establishes a relationship
  between a Restriction object and a <a
  href="#def-code-list"><span class="termRef">code list</span></a>
  specification. The detailed meaning of the object properties is
  provided in <a href="#code-lists"><b>[Code Lists]</b></a>.</p>
  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>CodeListBinding</td>
  <td>A data type for connecting simple content defined by an XML Schema
  component to a a column of a code list.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>CodeListURI</td>
  <td>A universal identifier for a code list.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>xs:anyURI</td>
  </tr>
  <tr>
  <td>CodeListColumnName</td>
  <td>A local name for a code list column within a code list.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>xs:string</td>
  </tr>
  <tr>
  <td>CodeListConstrainingIndicator</td>
  <td>True when a code list binding constrains the validity of a code
  list value, false otherwise.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>xs:boolean</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-49">Table 4-49: Properties of the CodeListBinding object class</a></figcaption>

  <p>A CodeListBinding object is represented in XSD as a
  <code>clsa:SimpleCodeListBinding</code> element in an
  <code>xs:appinfo</code> element. <a href="#ex4-50">Example 4-50</a>
  shows the representation of a CodeListBinding object, first in CMF,
  then in XSD.</p>
  <pre><code>&lt;CodeListBinding&gt;
  &lt;CodeListURI&gt;http://api.nsgreg.nga.mil/geo-political/GENC/2/3-11&lt;/CodeListURI&gt;
  &lt;CodeListConstrainingIndicator&gt;false&lt;/CodeListConstrainingIndicator&gt;
&lt;/CodeListBinding&gt;
---------------
&lt;xs:simpleType name=&quot;CountryAlpha2CodeSimpleType&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;A data type for country codes.&lt;/xs:documentation&gt;
    &lt;xs:appinfo&gt;
      &lt;clsa:SimpleCodeListBinding codeListURI=&quot;http://api.nsgreg.nga.mil/geo-political/GENC/2/3-11&quot;constrainingIndicator=&quot;false&quot;/&gt;
    &lt;/xs:appinfo&gt;</code></pre>
  <figcaption><a name="ex4-50">Example 4-50: CodeListBinding object in CMF and XSD</a></figcaption>

  <p>The following table shows the mapping between CodeListBinding
  representations in CMF and XSD.</p>
  <table>
  <thead>
  <tr>
  <th>CMF</th>
  <th>XSD</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>CodeListURI</td>
  <td><code>clsa:SimpleCodeListBinding/@codeListURI</code></td>
  </tr>
  <tr>
  <td>CodeListColumnName</td>
  <td><code>clsa:SimpleCodeListBinding/@columnName</code></td>
  </tr>
  <tr>
  <td>CodeListConstrainingIndicator</td>
  <td><code>clsa:SimpleCodeListBinding/@constrainingIndicator</code></td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-51">Table 4-51: CodeListBinding object properties in CMF and XSD</a></figcaption>

  <h2 id="416-augmentation-class">4.16 Augmentation class</h2>
  <figure class="image">
    <a name="fig4-18"/></a>
    <img src="images/augment.png" style="zoom:100%"/>
    <figcaption><a name="fig4-52">Figure 4-52: Augmentation class diagram</a></figcaption>
  </figure>

  <p>Augmentation is the NIEM mechanism allowing the author of one
  namespace (the <em>augmenting namespace</em>) to add a property to a
  class in another namespace (the <em>augmented namespace</em>) —
  without requiring any change to the augmented namespace. For example,
  the model designers for the NIEM Justice domain augmented the
  <code>nc:PersonType</code> class with the
  <code>j:PersonSightedIndicator</code> property. Then:</p>
  <ul>
  <li><code>https://docs.oasis-open.org/niemopen/ns/model/domains/justice/6.0/</code>
  is the augmenting namespace</li>
  <li><code>https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/</code>
  is the augmented namespace</li>
  <li><code>j:PersonSightedIndicator</code> is an <em><a
  href="#def-augmentation-property"><span class="termRef">augmentation
  property</span></a></em></li>
  <li><code>nc:PersonType</code> is the <em>augmented class</em></li>
  </ul>
  <p>If a message model includes this augmentation, then a conforming
  message may contain instances of the <code>nc:PersonType</code> class
  that have the <code>j:PersonSightedProperty</code> property. Without
  an augmentation, <code>j:PersonSightedProperty</code> may not appear
  in <code>nc:PersonType</code> message objects.</p>
  <h3 id="4161-augmentations-in-cmf">4.16.1 Augmentations in CMF</h3>
  <p>In CMF, an augmentation is represented as an AugmentationRecord
  object belonging to the augmenting namespace. In this way, each
  namespace contains a complete list of all the augmentations it
  makes.</p>
  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>AugmentationRecord</td>
  <td>A data type for a class that is augmented with a property by a
  namespace.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>MinOccursQuantity</td>
  <td>The minimum number of times a property may occur within a message
  object of this class.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>xs:integer</td>
  </tr>
  <tr>
  <td>MaxOccursQuantity</td>
  <td>The maximum number of times a property may occur within a message
  object of this class.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>MaxOccursType</td>
  </tr>
  <tr>
  <td>AugmentationIndex</td>
  <td>The ordinal position of this <a
  href="#def-augmentation-property"><span class="termRef">augmentation
  property</span></a> within an <a
  href="#def-augmentation-type"><span class="termRef">augmentation
  type</span></a>.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>xs:integer</td>
  </tr>
  <tr>
  <td>GlobalClassCode</td>
  <td>A code for a kind of class (object class, association class, or
  literal class), such that every class of that kind in a model is
  augmented with the augmentation property</td>
  <td style="text-align: center;">0..*</td>
  <td style="text-align: center;">-</td>
  <td>GlobalClassCodeType</td>
  </tr>
  <tr>
  <td>Class</td>
  <td>The augmented class.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>ClassType</td>
  </tr>
  <tr>
  <td>Property</td>
  <td>The augmentation property .</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>PropertyType</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-53">Table 4-53: Properties of the Augmentation object class</a></figcaption>

  <p>For example, augmentation of <code>nc:PersonType</code> with
  <code>j:PersonAdultIndicator</code> and
  <code>j:PersonSightedIndicator</code> by the NIEM Justice namespace is
  done with the following CMF:</p>
  <pre><code>&lt;Namespace&gt;
  &lt;NamespaceURI&gt;https://docs.oasis-open.org/niemopen/ns/model/domains/justice/6.0/&lt;/NamespaceURI&gt;
  &lt;NamespacePrefix&gt;j&lt;/NamespacePrefix&gt;
  &lt;AugmentationRecord&gt;
    &lt;Class structures:ref=&quot;nc.PersonType&quot; xsi:nil=&quot;true&quot;/&gt;
    &lt;Property structures:ref=&quot;j.PersonAdultIndicator&quot; xsi:nil=&quot;true&quot;/&gt;
    &lt;MinOccursQuantity&gt;0&lt;/MinOccursQuantity&gt;
    &lt;MaxOccursQuantity&gt;unbounded&lt;/MaxOccursQuantity&gt;
    &lt;AugmentationIndex&gt;0&lt;/AugmentationIndex&gt;
  &lt;/AugmentationRecord&gt;
  &lt;AugmentationRecord&gt;
    &lt;Class structures:ref=&quot;nc.PersonType&quot; xsi:nil=&quot;true&quot;/&gt;
    &lt;Property structures:ref=&quot;j.PersonSightedIndicator&quot; xsi:nil=&quot;true&quot;/&gt;
    &lt;MinOccursQuantity&gt;0&lt;/MinOccursQuantity&gt;
    &lt;MaxOccursQuantity&gt;unbounded&lt;/MaxOccursQuantity&gt;
    &lt;AugmentationIndex&gt;1&lt;/AugmentationIndex&gt;
  &lt;/AugmentationRecord&gt;
&lt;/Namespace&gt;</code></pre>
  <figcaption><a name="ex4-54">Example 4-54: Augmenting a single class in CMF</a></figcaption>

  <p>A <em>global augmentation</em> adds a property to every class of a
  specified kind in the model. In CMF, a global augmentation is
  represented by an AugmentationRecord object with a GlobalClassCode
  property and no Class property. For example, a global augmentation
  adding <code>my:PrivacyAssertion</code> to every every <a
  href="#def-object-class"><span class="termRef">object class</span></a>
  and <a href="#def-association-class"><span class="termRef">association
  class</span></a> is done with the following CMF:</p>
  <pre><code>&lt;Namespace&gt;
  &lt;NamespaceURI&gt;http://example.com/MyNamespace/&lt;/NamespaceURI&gt;
  &lt;NamespacePrefix&gt;my&lt;/NamespacePrefix&gt;
  &lt;AugmentationRecord&gt;
    &lt;Property structures:ref=&quot;my.PrivacyAssertion&quot;/&gt;
    &lt;MinOccursQuantity&gt;1&lt;/MinOccursQuantity&gt;
    &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;
    &lt;AugmentationIndex&gt;0&lt;/AugmentationIndex&gt;
    &lt;GlobalClassCode&gt;OBJECT&lt;/GlobalClassCode&gt;
    &lt;GlobalClassCode&gt;ASSOCIATION&lt;/GlobalClassCode&gt;
  &lt;/AugmentationRecord&gt;
&lt;/Namespace&gt;</code></pre>
  <figcaption><a name="ex4-55">Example 4-55: Global augmentation in CMF</a></figcaption>

  <p>The range of the <code>GlobalClassCode</code> property is a code
  list with the following codes and meanings:</p>
  <table>
  <thead>
  <tr>
  <th>Code</th>
  <th>Definition</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>OBJECT</td>
  <td>A code for an <a
  href="#def-augmentation-property"><span class="termRef">augmentation
  property</span></a> that applies to all <a
  href="#def-object-class"><span class="termRef">object
  classes</span></a> in the model.</td>
  </tr>
  <tr>
  <td>ASSOCIATION</td>
  <td>A code for an <a
  href="#def-augmentation-property"><span class="termRef">augmentation
  property</span></a> that applies to all <a
  href="#def-association-class"><span class="termRef">association
  classes</span></a> in the model.</td>
  </tr>
  <tr>
  <td>LITERAL</td>
  <td>A code for an <a
  href="#def-augmentation-property"><span class="termRef">augmentation
  property</span></a> that applies to all <a
  href="#def-datatype"><span class="termRef">datatypes</span></a> and <a
  href="#def-literal-class"><span class="termRef">literal
  classes</span></a> in the model. <em>(see <a
  href="#41624-augmenting-a-literal-class-with-an-element-property-in-xsd">§4.16.2.4</a>)</em></td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-56">Table 4-56: GlobalClassCode code list</a></figcaption>

  <h3 id="4162-augmentations-in-xsd">4.16.2 Augmentations in XSD</h3>
  <p>The XSD representation of an augmentation is complex, and varies
  based on three factors:</p>
  <ol type="1">
  <li>Whether the <a
  href="#def-augmentation-property"><span class="termRef">augmentation
  property</span></a> is an <a
  href="#def-attribute-property"><span class="termRef">attribute
  property</span></a> or an <a
  href="#def-element-property"><span class="termRef">element
  property</span></a></li>
  <li>Whether the <a
  href="#def-augmented-class"><span class="termRef">augmented
  class</span></a> is an <a
  href="#def-object-class"><span class="termRef">object
  class</span></a>, <a
  href="#def-association-class"><span class="termRef">association
  class</span></a>, or <a
  href="#def-literal-class"><span class="termRef">literal
  class</span></a>.</li>
  <li>Whether the augmentation is a global augmentation, or applies to a
  single <a href="#def-augmented-class"><span class="termRef">augmented
  class</span></a>.</li>
  </ol>
  <h4 id="41621-attribute-augmentations-in-xsd">4.16.2.1 Attribute
  augmentations in XSD</h4>
  <p>Augmenting any class with an attribute property in XSD is done
  through <code>appinfo:Augmentation</code> elements in the schema
  document for the augmenting namespace. These elements appear as
  children of <code>xs:schema/xs:annotation/xs:appinfo</code>. The
  following table shows the mapping between Augmentation object
  representations in CMF and XSD.</p>
  <table>
  <thead>
  <tr>
  <th>CMF</th>
  <th>XSD</th>
  <th>Mapping</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Class</td>
  <td><code>appinfo:Augmentation/@class</code></td>
  <td></td>
  </tr>
  <tr>
  <td>Property</td>
  <td><code>appinfo:Augmentation/@property</code></td>
  <td></td>
  </tr>
  <tr>
  <td>MinOccursQuantity</td>
  <td><code>appinfo:Augmentation/@required</code></td>
  <td><em>1 if true, otherwise 0</em></td>
  </tr>
  <tr>
  <td>MaxOccursQuantity</td>
  <td>-</td>
  <td><em>always 1</em></td>
  </tr>
  <tr>
  <td>AugmentationIndex</td>
  <td>-</td>
  <td><em>not applicable</em></td>
  </tr>
  <tr>
  <td>GlobalClassCode</td>
  <td><code>appinfo:Augmentation/@globalClassCode</code></td>
  <td><em>list of code values</em></td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-57">Table 4-57: Augmentation object properties in CMF and XSD</a></figcaption>

  <p><a href="#ex4-70">Example 4-70</a> shows XSD and corresponding CMF
  for a namespace augmenting <code>nc:PersonType</code> with an optional
  <code>my:privacyCode</code> attribute property. <a
  href="#ex4-71">Example 4-71</a> shows XML and JSON message objects
  containing that augmentation property.</p>
  <pre><code>&lt;xs:schema 
  targetNamespace=&quot;http://example.com/MyNS/&quot;
  xmlns:my=&quot;http://example.com/MyNS/&quot; ... &gt;
  &lt;xs:annotation&gt;
    &lt;xs:appinfo&gt;
      &lt;appinfo:Augmentation class=&quot;nc:PersonType&quot; property=&quot;my:privacyCode&quot;&gt;
    &lt;/xs:appinfo&gt;
  &lt;/xs:annotation&gt;
----------
&lt;AugmentationRecord&gt;
  &lt;Class structures:ref=&quot;nc.PersonType&quot;/&gt;
  &lt;Property structures:ref=&quot;my:privacyCode&quot;/&gt;
  &lt;MinOccursQuantity&gt;1&lt;/MinOccursQuantity&gt;
  &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;
&lt;/AugmentationRecord&gt;</code></pre>
  <figcaption><a name="ex4-58">Example 4-58: Attribute augmentation in XSD and CMF model representations</a></figcaption>

  <pre><code>&lt;nc:Person&gt;                                                              | &quot;nc:Person&quot;: {
  &lt;nc:PersonBirthDate my:privacyCode=&quot;SECRET&quot;&gt;                           |   &quot;nc:PersonBirthDate&quot;: {
    &lt;nc:Date&gt;2021-09-11&lt;/nc:Date&gt;                                        |     &quot;nc:Date&quot;: &quot;2021-09-11&quot;,
  &lt;/nc:PersonBirthDate&gt;                                                  |     &quot;my:privacyCode&quot;: &quot;SECRET&quot;
  &lt;nc:PersonName&gt;                                                        |   },
    &lt;nc:PersonFullName&gt;John Doe&lt;/nc:PersonFullName&gt;                      |   &quot;nc:PersonName&quot;: {
  &lt;/nc:PersonName&gt;                                                       |     &quot;nc:PersonFullName&quot;: &quot;John Doe&quot;
&lt;/nc:Person&gt;                                                             |   }
                                                                         | }</code></pre>
  <figcaption><a name="ex4-59">Example 4-59: Attribute augmentations in XML and JSON messages</a></figcaption>

  <p>Mandatory attribute augmentations in XSD include
  <code>use="required"</code> in the Appinfo element. Global attribute
  augmentations in XSD include the <code>globalClassCode</code>
  attribute containing the appropriate codes. In <a
  href="#ex4-73">Example 4-73</a>, all classes are augmented with the
  mandatory attribute <code>my:privacyCode</code>.</p>
  <pre><code>&lt;xs:schema 
  targetNamespace=&quot;http://example.com/MyNS/&quot;
  xmlns:my=&quot;http://example.com/MyNS/&quot; ... &gt;
  &lt;xs:annotation&gt;
    &lt;xs:appinfo&gt;
      &lt;appinfo:Augmentation property=&quot;my:privacyCode&quot; use=&quot;required&quot; globalClassCode=&quot;ASSOCIATION OBJECT LITERAL&quot;/&gt;
    &lt;/xs:appinfo&gt;
  &lt;/xs:annotation&gt;</code></pre>
  <figcaption><a name="ex4-60">Example 4-60: Mandatory global attribute augmentation in XSD model representation</a></figcaption>

  <h4
  id="41622-augmenting-one-object-class-or-association-class-with-an-element-property">4.16.2.2
  Augmenting one object class or association class with an element
  property</h4>
  <p>In XSD, an <a href="#def-object-class"><span class="termRef">object
  class</span></a> or an <a
  href="#def-association-class"><span class="termRef">association
  class</span></a> is represented by a complex type definition with
  complex content (a "CCC type"). For example,
  <code>nc:PersonType</code> is represented as the following CCC type
  definition (some properties are omitted for simplicity):</p>
  <pre><code>&lt;xs:complexType name=&quot;PersonType&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;A data type for a human being.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base=&quot;structures:ObjectType&quot;&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref=&quot;nc:PersonBirthDate&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
        &lt;xs:element ref=&quot;nc:PersonName&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
        &lt;xs:element ref=&quot;nc:PersonAugmentationPoint&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;</code></pre>
  <figcaption><a name="ex4-61">Example 4-61: Complex type with complex content (CCC type) defining an object class in an XSD model representation</a></figcaption>

  <p>Every object and assocation class in NIEM XSD contains an <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a>. This is an abstract element declaration in
  the same namespace, having the same name as the type which contains
  it, with the final "Type" replaced with "AugmentationPoint" <em>(see
  <a href="#rule9-94">rule 9-94</a>)</em>. In <a href="#ex4-71">example
  4-71</a>, <code>nc:PersonAugmentationPoint</code> is the <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a> for <code>nc:PersonType</code>. Because it is
  abstract, an <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a> cannot appear in a message. Instead, it is a
  placeholder for element substitution.</p>
  <pre><code>&lt;xs:element name=&quot;PersonAugmentationPoint&quot; abstract=&quot;true&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;An augmentation point for PersonType&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;</code></pre>
  <figcaption><a name="ex4-62">Example 4-62: An augmentation point element declaration</a></figcaption>

  <p>A namespace augments an object or augmentation class with an <a
  href="#def-element-property"><span class="termRef">element
  property</span></a> in XSD by defining an <a
  href="#def-augmentation-type"><span class="termRef">augmentation
  type</span></a> and an <a
  href="#def-augmentation-element"><span class="termRef">augmentation
  element</span></a>. Together these define a container element for the
  desired <a
  href="#def-augmentation-property"><span class="termRef">augmentation
  properties</span></a>, a container that substitutes for the <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a>. For example, <a href="#ex4-73">example
  4-73</a> shows the XSD for the NIEM Justice namespace augmenting
  <code>nc:PersonType</code> with two properties. (The corresponding CMF
  was shown in <a href="#ex4-54">example 4-54</a>.)</p>
  <pre><code>&lt;xs:complexType name=&quot;PersonAugmentationType&quot;&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base=&quot;structures:AugmentationType&quot;&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref=&quot;j:PersonAdultIndicator&quot; minOccurs=&quot;0&quot;/&gt;
        &lt;xs:element ref=&quot;j:PersonSightedIndicator&quot; minOccurs=&quot;0&quot;/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;
&lt;xs:element name=&quot;PersonAugmentation&quot; type=&quot;j:ExampleAugmentationType&quot; substitutionGroup=&quot;nc:PersonAugmentationPoint&quot;/&gt;</code></pre>
  <figcaption><a name="ex4-63">Example 4-63: Augmenting a class with an augmentation type and element in XSD</a></figcaption>

  <p>Example messages containing the NIEM Justice element augmentations
  are shown in <a href="#ex4-64">example 4-64</a>. Note that the
  <code>PersonAugmentation</code> container element does not appear in
  the JSON message.</p>
  <pre><code>&lt;nc:Person&gt;                                                                   | &quot;nc:Person&quot;: {
  &lt;nc:PersonBirthDate&gt;                                                        |   &quot;nc:PersonBirthDate&quot;: {
    &lt;nc:Date&gt;2021-09-11&lt;/nc:Date&gt;                                             |     &quot;nc:Date&quot;: &quot;2021-09-11&quot;,
  &lt;/nc:PersonBirthDate&gt;                                                       |   },
  &lt;nc:PersonName&gt;                                                             |   &quot;nc:PersonName&quot;: {
    &lt;nc:PersonFullName&gt;John Doe&lt;/nc:PersonFullName&gt;                           |     &quot;nc:PersonFullName&quot;: &quot;John Doe&quot;
  &lt;/nc:PersonName&gt;                                                            |   },
  &lt;j:PersonAugmentation&gt;                                                      |   &quot;j:PersonAdultIndicator&quot;: true,
    &lt;j:PersonAdultIndicator&gt;true&lt;/j:PersonAdultIndicator&gt;                     |   &quot;j:PersonSightedIndicator&quot;: true
    &lt;j:PersonSightedIndicator&gt;true&lt;/j:PersonSightedIndicator&gt;                 | }
  &lt;/j:PersonAugmentation&gt;                                                     | 
&lt;/nc:Person&gt;                                                                  | </code></pre>
  <figcaption><a name="ex4-64">Example 4-64: Element augmentation in XML and JSON messages</a></figcaption>

  <p>There is another way to augment an object or augmentation class
  with an <a href="#def-element-property"><span class="termRef">element
  property</span></a> in XSD, one that does not involve creating an
  augmentation type or element. This is done by making an ordinary <a
  href="#def-element-property"><span class="termRef">element
  property</span></a> substitutable for the <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a>. For example, the namespace
  <code>http://example.com/Characters</code> could augment
  <code>nc:PersonType</code> with a
  <code>PersonFictionalCharacterIndicator</code> property via the XSD in
  <a href="#ex4-65">example 4-65</a>. The equivalent augmentation in CMF
  is also shown. (There is no <code>AugmentationIndex</code> property in
  this CMF augmentation, because the augmentation property is not part
  of an augmentation type.)</p>
  <pre><code>&lt;xs:element name=&quot;PersonFictionalCharacterIndicator&quot;         | &lt;AugmentationRecord&gt;
    type=&quot;niem-xs:boolean&quot;                                   |   &lt;Property structures:ref=&quot;my:PersonFictionalCharacterIndicator&quot;/&gt;
    substitutionGroup=&quot;nc:PersonAugmentationPoint&quot;&gt;          |   &lt;Class structures:ref=&quot;nc:PersonType&quot;/&gt;
  &lt;xs:annotation&gt;                                            |   &lt;MinOccursQuantity&gt;0&lt;/MinOccursQuantity&gt;
    &lt;xs:documentation&gt;                                       |   &lt;MaxOccursQuantity&gt;unbounded&lt;/MaxOccursQuantity&gt;
      True if a person is a character in a work of fiction.  | &lt;/AugmentationRecord&gt;
    &lt;/xs:documentation&gt;                                      | 
  &lt;/xs:annotation&gt;                                           | 
&lt;/xs:element&gt;                                                | 
</code></pre>
  <figcaption><a name="ex4-65">Example 4-65: Augmenting a class with an element property in XSD</a></figcaption>

  <p><a href="#ex4-66">Example 4-66</a> shows an
  <code>nc:PersonType</code> object that is augmented with an element
  property.</p>
  <pre><code>&lt;nc:Person&gt;
  &lt;nc:PersonBirthDate&gt;
    &lt;nc:Date&gt;2021-09-11&lt;/nc:Date&gt;
  &lt;/nc:PersonBirthDate&gt;
  &lt;nc:PersonName&gt;
    &lt;nc:PersonFullName&gt;John Doe&lt;/nc:PersonFullName&gt;
  &lt;/nc:PersonName&gt;
  &lt;my:PersonFictionalCharacterIndicator&gt;true&lt;/nc:PersonFictionalCharacterIndicator&gt;
&lt;/nc:Person&gt;</code></pre>
  <figcaption><a name="ex4-66">Example 4-66: Augmentation with an element property in XML</a></figcaption>

  <h4
  id="41623-augmenting-every-object-class-or-association-class-with-an-element-property">4.16.2.3
  Augmenting every object class or association class with an element
  property</h4>
  <p>NIEM has two special augmentation points for global augmentations:
  <code>structures:ObjectAugmentationPoint</code> and
  <code>structures:AssociationAugmentationPoint</code>. In order to
  augment every object or association class with an element property, a
  namespace defines an augmentation type and element substitutable for
  one of those special augmentation points. For example, <a
  href="#ex4-67">example 4-67</a> shows the XSD to augment every object
  class with the property <code>my:PrivacyAssertion</code>. (Replace
  "Object" with "Association" to instead augment every association
  class.)</p>
  <pre><code>&lt;xs:complexType name=&quot;ObjectAugmentationType&quot;&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base=&quot;structures:AugmentationType&quot;&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref=&quot;my:PrivacyAssertion&quot;/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;
&lt;xs:element name=&quot;ObjectAugmentation&quot; type=&quot;my:ObjectAugmentationType&quot; substitutionGroup=&quot;structures:ObjectAugmentationPoint&quot;/&gt;</code></pre>
  <figcaption><a name="ex4-67">Example 4-67: Augmenting every object class with an element property in XSD</a></figcaption>

  <p>Global augmentation properties appear first in an XSD message. <a
  href="#ex4-68">Example 4-68</a> shows an XML message with a message
  object containing a global augmentation property.</p>
  <pre><code>&lt;nc:Person&gt;
  &lt;my:ObjectAugmentation&gt;
    &lt;my:PrivacyAssertion&gt;
      &lt;nc:Date&gt;2023-08-05&lt;/nc:Date&gt;
      &lt;my:PrivacyText&gt;PUBLIC&lt;/my:PrivacyText&gt;
    &lt;/my:PrivacyAssertion&gt;
  &lt;/my:ObjectAugmentation&gt;
  &lt;nc:PersonBirthDate&gt;
    &lt;nc:Date&gt;2021-09-11&lt;/nc:Date&gt;
  &lt;/nc:PersonBirthDate&gt;
  &lt;nc:PersonName&gt;
    &lt;nc:PersonFullName&gt;John Doe&lt;/nc:PersonFullName&gt;
  &lt;/nc:PersonName&gt;
&lt;/nc:Person&gt;  </code></pre>
  <figcaption><a name="ex4-68">Example 4-68: Global augmentation with an element property in XML</a></figcaption>

  <h4
  id="41624-augmenting-a-literal-class-with-an-element-property-in-xsd">4.16.2.4
  Augmenting a literal class with an element property in XSD</h4>
  <p>Datatypes and literal classes are represented as elements with
  simple content in XML messages. These elements may have attributes,
  but may not have child elements. Therefore they cannot be augmented
  through substitution for an augmentation point. They are instead
  augmented in CMF through AugmentationRecord objects, and in XSD
  through <code>appinfo:Augmentation</code> elements.</p>
  <blockquote>
  <p>Question: <em>How many element property augmentations can you add
  to a datatype?</em><br />
  Answer: <em>Only one. After that, it is a literal class, not a
  datatype. (See <a
  href="#51-datatypes-and-literal-classes">§5.1</a>)</em></p>
  </blockquote>
  <p><a href="#ex4-69">Example 4-69</a> shows how
  <code>ndex:PersonSexualOrientationCodeType</code> may be augmented
  with the element property <code>my:PrivacyAssertion</code>.</p>
  <pre><code>&lt;AugmentRecord&gt;                                                           | &lt;appinfo:Augmentation
  &lt;Class structures:ref=&quot;ndex.PersonSexualOrientationCodeType&quot;/&gt;          |   class=&quot;ndex:PersonSexualOrientationCodeType&quot;
  &lt;Property structures:ref=&quot;my.PrivacyAssertion&quot;/&gt;                        |   property=&quot;my:PrivacyAssertion&quot;/&gt;
  &lt;MinOccursQuantity&gt;0&lt;/MinOccursQuantity&gt;                                | 
  &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;                                | 
&lt;/AugmentRecord&gt;                                                          | </code></pre>
  <figcaption><a name="ex4-69">Example 4-69: Augmenting a literal class with an element property</a></figcaption>

  <p>These augmentations appear in XML messages as <em>reference
  attributes</em>. A reference attribute has the same name as the
  corresponding augmentation property, lower-cased, with a "Ref" suffix.
  For example, the reference attribute for
  <code>my:PrivacyAssertion</code> is
  <code>my:privacyAssertionRef</code>.</p>
  <p>A reference attribute contains a list of object references. Each
  referenced object is a value of the augmentation property. <a
  href="#ex4-70">Example 4-70</a> shows XML and JSON messages containing
  a literal class augmented with an element property.</p>
  <pre><code>&lt;nc:Person&gt;
  &lt;nc:PersonBirthDate&gt;
    &lt;nc:Date&gt;2021-09-11&lt;/nc:Date&gt;
  &lt;/nc:PersonBirthDate&gt;
  &lt;nc:PersonName&gt;
    &lt;nc:PersonFullName&gt;John Doe&lt;/nc:PersonFullName&gt;
  &lt;/nc:PersonName&gt;
  &lt;j:PersonSexualOrientationCode my:privacyAssertionRef=&quot;PRIV01&quot;&gt;UNKNOWN&lt;/j:PersonSexualOrientationCode&gt;
&lt;/nc:Person&gt;
&lt;my:PrivacyAssertion structures:id=&quot;PRIV01&quot;&gt;
  &lt;nc:Date&gt;2023-08-05&lt;/nc:Date&gt;
  &lt;my:PrivacyText&gt;RESTRICTED&lt;/my:PrivacyText&gt;
&lt;/my:PrivacyAssertion&gt;  
----------
&quot;nc:Person&quot;: {
  &quot;nc:PersonBirthDate&quot;: {
    &quot;nc:Date&quot;: &quot;2021-09-11&quot;,
  },
  &quot;nc:PersonName&quot;: {
    &quot;nc:PersonFullName&quot;: &quot;John Doe&quot;
  },
  &quot;j:PersonSexualOrientationCode&quot;: {
    &quot;ndex:PersonSexualOrientationCodeLiteral&quot;: &quot;UNKNOWN&quot;,
    &quot;my:PrivacyAssertion&quot;: { &quot;@id&quot;: &quot;#PRIV01&quot; }
},
&quot;my:PrivacyAssertion&quot;: {
  &quot;@id&quot;: &quot;#PRIV01&quot;,
  &quot;nc:Date&quot;: &quot;2023-08-05&quot;,
  &quot;my:PrivacyText&quot;: &quot;RESTRICTED&quot;
}</code></pre>
  <figcaption><a name="ex4-70">Example 4-70: Reference attribute augmentation in XML and JSON</a></figcaption>

  <p>Augmenting every literal class with an element property is done by
  omitting the class and adding a global class code. <a
  href="#ex4-71">Example 4-71</a> shows the CMF and XSD to augment every
  literal class with <code>my:PrivacyAssertion</code>.</p>
  <pre><code>&lt;AugmentRecord&gt;                                                           | &lt;appinfo:Augmentation
  &lt;Property structures:ref=&quot;my.PrivacyAssertion&quot;/&gt;                        |   property=&quot;my:PrivacyAssertion&quot;
  &lt;MinOccursQuantity&gt;0&lt;/MinOccursQuantity&gt;                                |   globalClassCode=&quot;LITERAL&quot;/&gt;
  &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;                                | 
  &lt;GlobalClassCode&gt;LITERAL&lt;/GlobalClassCode&gt;                              |
&lt;/AugmentRecord&gt;                                                          | </code></pre>
  <figcaption><a name="ex4-71">Example 4-71: Augmenting every literal class with an element property</a></figcaption>

  <h2 id="417-localterm">4.17 LocalTerm</h2>
  <p>A <a href="#def-local-term"><span class="termRef">local
  term</span></a> is a word, phrase, acronym, or other string of
  characters that is used in the name of a namespace component, but that
  is not defined in <a href="#oed"><b>[OED]</b></a>, or that has a
  non-OED definition in this namespace, or has a word sense that is in
  some way unclear. An instance of the LocalTerm class captures the
  namespace author's definition of such a local term. For example, the
  Justice domain namespace in the NIEM model has a LocalTerm object
  defining the name "CLP" with documentation "Commercial Learners
  Permit".</p>
  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>LocalTerm</td>
  <td>A data type for the meaning of a term that may appear within the
  name of a model component.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>TermName</td>
  <td>The name of the local term.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>xs:token</td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td>A human-readable text definition of a data model component or
  term, or the documentation of a namespace.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>TextType</td>
  </tr>
  <tr>
  <td>TermLiteralText</td>
  <td>A meaning of a local term provided as a full, plain-text
  form.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>xs:string</td>
  </tr>
  <tr>
  <td>SourceURI</td>
  <td>A URI that is an identifier or locator for an originating or
  authoritative document defining a local term.</td>
  <td style="text-align: center;">0..*</td>
  <td style="text-align: center;">-</td>
  <td>xs:anyURI</td>
  </tr>
  <tr>
  <td>SourceCitationText</td>
  <td>A plain text citation of, reference to, or bibliographic entry for
  an originating or authoritative document defining a local term.</td>
  <td style="text-align: center;">0..*</td>
  <td style="text-align: center;">-</td>
  <td>xs:string</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-72">Table 4-72: Properties of the LocalTerm object class</a></figcaption>

  <p>A LocalTerm object is represented in XSD by a
  <code>appinfo:LocalTerm</code> element within <code>xs:appinfo</code>
  element in the <code>xs:schema</code> element. <a
  href="#ex4-73">Example 4-73</a> shows the representation of a
  LocalTerm object in CMF and XSD.</p>
  <pre><code>&lt;LocalTerm&gt;
  &lt;TermName&gt;2D&lt;/TermName&gt;
  &lt;TermLiteralText&gt;Two-dimensional&lt;/TermLiteralText&gt;
&lt;/LocalTerm&gt;
&lt;LocalTerm&gt;
  &lt;TermName&gt;3D&lt;/TermName&gt;
  &lt;DocumentationText&gt;Three-dimensional&lt;/DocumentationText&gt;
&lt;/LocalTerm&gt;
&lt;LocalTerm&gt;
  &lt;TermName&gt;Test&lt;/TermName&gt;
  &lt;DocumentationText&gt;only for test purposes&lt;/DocumentationText&gt;
  &lt;SourceURI&gt;http://example.com/1 http://example.com/2&lt;/SourceURI&gt;
  &lt;SourceCitationText&gt;citation #1&lt;/SourceCitationText&gt;
  &lt;SourceCitationText&gt;citation #2&lt;/SourceCitationText&gt;
&lt;/LocalTerm&gt;
---------------
&lt;xs:appinfo&gt;
  &lt;appinfo:LocalTerm term=&quot;2D&quot; literal=&quot;Two-dimensional&quot;/&gt;
  &lt;appinfo:LocalTerm term=&quot;3D&quot; definition=&quot;Three-dimensional&quot;/&gt;
  &lt;appinfo:LocalTerm term=&quot;Test&quot; definition=&quot;only for test purposes&quot; sourceURIs=&quot;http://example.com/1 http://example.com/2&quot;&gt;
    &lt;appinfo:SourceText&gt;citation #1&lt;/appinfo:SourceText&gt;
    &lt;appinfo:SourceText&gt;citation #2&lt;/appinfo:SourceText&gt;
  &lt;/appinfo:LocalTerm&gt;
&lt;/xs:appinfo&gt;</code></pre>
  <figcaption><a name="ex4-73">Example 4-73: Example LocalTerm objects in CMF and XSD</a></figcaption>

  <p>The following table shows the mapping between LocalTerm object
  representations in CMF and XSD.</p>
  <table>
  <thead>
  <tr>
  <th>CMF</th>
  <th>XSD</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>TermName</td>
  <td><code>appinfo:LocalTerm/@term</code></td>
  </tr>
  <tr>
  <td>DocumentationText</td>
  <td><code>appinfo:LocalTerm/@definition</code></td>
  </tr>
  <tr>
  <td>TermLiteralText</td>
  <td><code>appinfo:LocalTerm/@literal</code></td>
  </tr>
  <tr>
  <td>SourceURI</td>
  <td>Each URI in the <code>appinfo:LocalTerm/@sourceURIs</code>
  list</td>
  </tr>
  <tr>
  <td>SourceCitationText</td>
  <td><code>appinfo:LocalTerm/appinfo:SourceText</code></td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-74">Table 4-74: LocalTerm object properties in CMF and XSD</a></figcaption>

  <h2 id="418-texttype">4.18 TextType</h2>
  <p>An instance of the TextType class combines a string property with a
  language property.</p>
  <table>
  <thead>
  <tr>
  <th>Name</th>
  <th>Definition</th>
  <th style="text-align: center;">Card</th>
  <th style="text-align: center;">Ord</th>
  <th>Range</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>TextType</td>
  <td>A data type for a character string with a language code.</td>
  <td style="text-align: center;"></td>
  <td style="text-align: center;"></td>
  <td></td>
  </tr>
  <tr>
  <td>TextLiteral</td>
  <td>A literal value that is a character string.</td>
  <td style="text-align: center;">1</td>
  <td style="text-align: center;">-</td>
  <td>xs:string</td>
  </tr>
  <tr>
  <td>lang</td>
  <td>A name of the language of a character string.</td>
  <td style="text-align: center;">0..1</td>
  <td style="text-align: center;">-</td>
  <td>xs:language</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab4-75">Table 4-75: Properties of the TextType object class</a></figcaption>

  <hr />
  <h1 id="5-data-modeling-patterns">5. Data modeling patterns</h1>
  <p>This section is informative. It explains common patterns in NIEM
  models and messages.</p>
  <h2 id="51-datatypes-and-literal-classes">5.1 Datatypes and literal
  classes</h2>
  <p>A model component can be a datatype in one message model and a
  class in another. This occurs when a message designer creates a subset
  of a reused literal class, or augments a reused datatype.</p>
  <p>Removing attribute properties from a reused literal class can turn
  it into a datatype. For example, <code>nc:NumericType</code> is a
  literal class in the NIEM Core reference namespace, but in a subset
  can become a datatype in a message model. In the NIEM model,
  <code>nc:NumericType</code> has one <a
  href="#def-element-property"><span class="termRef">element
  property</span></a> and one <a
  href="#def-attribute-property"><span class="termRef">attribute
  property</span></a>. <a href="#ex5-1">Example 5-1</a> shows the class
  representation in CMF and XSD; <a href="#ex5-2">example 5-2</a> shows
  an object of the class in an XML and JSON message.</p>
  <pre><code>&lt;Class structures:id=&quot;nc.NumericType&quot;&gt;                       | &lt;xs:complexType name=&quot;NumericType&quot;&gt;
  &lt;Name&gt;NumericType&lt;/Name&gt;                                   |   &lt;xs:simpleContent&gt;
  &lt;Namespace structures:ref=&quot;nc&quot;                             |     &lt;xs:extension base=&quot;niem-xs:decimal&quot;&gt;
  &lt;ChildPropertyAssociation&gt;                                 |       &lt;xs:attribute ref=&quot;nc:toleranceNumeric&quot; use=&quot;optional&quot;/&gt;
    &lt;DataProperty structures:ref=&quot;nc.NumericLiteral&quot;/&gt;       |     &lt;/xs:extension&gt;
    &lt;MinOccursQuantity&gt;1&lt;/MinOccursQuantity&gt;                 |   &lt;/xs:simpleContent&gt;
    &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;                 | &lt;/xs:complexType&gt;
  &lt;/ChildPropertyAssociation&gt;                                |
  &lt;ChildPropertyAssociation&gt;                                 |
    &lt;DataProperty structures:ref=&quot;nc.toleranceNumeric&quot;/&gt;     |
    &lt;MinOccursQuantity&gt;0&lt;/MinOccursQuantity&gt;                 |
    &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;                 |
  &lt;/ChildPropertyAssociation&gt;                                |
&lt;/Class&gt;                                                     |</code></pre>
  <figcaption><a name="ex5-1">Example 5-1: A literal class in CMF and XSD</a></figcaption>

  <pre><code>&lt;my:Message&gt;                                                        | &quot;my:Message&quot;: {
  &lt;my:MaximumNumber nc:toleranceNumeric=&quot;2&quot;&gt;7&lt;my:MaximumNumber&gt;     |   &quot;my:MaximumNumber&quot;: {
&lt;/my:Message&gt;                                                       |     &quot;nc:NumericLiteral&quot;: &quot;7&quot;,
                                                                    |     &quot;nc:toleranceNumeric&quot;: &quot;2&quot;
                                                                    |   }
                                                                    | }</code></pre>
  <figcaption><a name="ex5-2">Example 5-2: Objects of a literal class in an XML and JSON message</a></figcaption>

  <p>If a message designer decides to reuse <code>nc:NumericType</code>,
  and to remove <code>nc:toleranceNumeric</code> from the class in his
  model subset, then <code>nc:NumericType</code> becomes a datatype in
  the subset. <a href="#ex5-3">Example 5-3</a> shows the CMF and XSD
  representations of that subset; <a href="#ex5-4">example 5-4</a> shows
  the resulting data property in an XML and JSON message.</p>
  <pre><code>&lt;Restriction structures:id=&quot;nc.NumericType&quot;&gt;         | &lt;xs:complexType name=&quot;NumericType&quot;&gt;
  &lt;Name&gt;NumericType&lt;/Name&gt;                           |   &lt;xs:simpleContent&gt;
  &lt;Namespace structures:ref=&quot;nc&quot;                     |     &lt;xs:extension base=&quot;niem-xs:decimal&quot;/&gt;
  &lt;RestrictionBase structures:ref=&quot;xs:decimal&quot;/&gt;     |   &lt;/xs:simpleContent&gt;
&lt;/Restriction&gt;                                       | &lt;/xs:complexType&gt;</code></pre>
  <figcaption><a name="ex5-3">Example 5-3: A restriction datatype in a CMF and XSD model subset</a></figcaption>

  <pre><code>&lt;my:Message&gt;                                         | &quot;my:Message&quot;: {
  &lt;my:MaximumNumber&gt;7&lt;my:MaximumNumber&gt;              |   &quot;my:MaximumNumber&quot;: &quot;7&quot;
&lt;/my:Message&gt;                                        | }</code></pre>
  <figcaption><a name="ex5-4">Example 5-4: A data property in an XML and JSON message</a></figcaption>

  <p>Going the other way, augmenting a reused datatype with an attribute
  property turns it into a literal class. For example,
  <code>nc:PersonUnionCategoryCodeType</code> is a datatype in the NIEM
  model, and <code>nc:PersonUnionCategoryCode</code> is a data property
  with that datatype. <a href="#ex5-5">Example 5-5</a> shows the
  datatype representation in CMF and XSD; <a href="#ex5-6">example
  5-6</a> shows the data property in an XML and JSON message.</p>
  <pre><code>&lt;Restriction structures:id=&quot;nc.PersonUnionCategoryCodeType&quot;&gt;      | &lt;xs:complexType name=&quot;PersonUnionCategoryCodeType&quot;&gt;
  &lt;Name&gt;PersonUnionCategoryCodeType&lt;/Name&gt;                        |   &lt;xs:simpleContent&gt;
  &lt;Namespace structures:ref=&quot;nc&quot; xsi:nil=&quot;true&quot;/&gt;                 |     &lt;xs:restriction base=&quot;niem-xs:token&quot;&gt;
  &lt;RestrictionBase structures:ref=&quot;xs.token&quot; xsi:nil=&quot;true&quot;/&gt;     |       &lt;xs:enumeration value=&quot;civil union&quot;/&gt;
  &lt;Enumeration&gt;                                                   |       &lt;xs:enumeration value=&quot;common law&quot;/&gt;
    &lt;StringValue&gt;civil union&lt;/StringValue&gt;                        |       &lt;xs:enumeration value=&quot;domestic partnership&quot;/&gt;
  &lt;/Enumeration&gt;                                                  |       &lt;xs:enumeration value=&quot;married&quot;/&gt;
  &lt;Enumeration&gt;                                                   |       &lt;xs:enumeration value=&quot;unknown&quot;/&gt;
    &lt;StringValue&gt;common law&lt;/StringValue&gt;                         |     &lt;/xs:restriction&gt;
  &lt;/Enumeration&gt;                                                  |   &lt;/xs:simpleContent&gt;
  &lt;Enumeration&gt;                                                   | &lt;/xs:complexType&gt;
    &lt;StringValue&gt;domestic partnership&lt;/StringValue&gt;               | 
  &lt;/Enumeration&gt;                                                  | 
  &lt;Enumeration&gt;                                                   | 
    &lt;StringValue&gt;married&lt;/StringValue&gt;                            | 
  &lt;/Enumeration&gt;                                                  | 
  &lt;Enumeration&gt;                                                   | 
    &lt;StringValue&gt;unknown&lt;/StringValue&gt;                            | 
  &lt;/Enumeration&gt;                                                  | 
&lt;/Restriction&gt;                                                    | </code></pre>
  <figcaption><a name="ex5-5">Example 5-5: A datatype in CMF and XSD</a></figcaption>

  <pre><code>&lt;nc:Person&gt;                                                            | &quot;nc:Person&quot;: {
  &lt;nc:PersonUnionCategoryCode&gt;married&lt;/nc:PersonUnionCategoryCode&gt;     |   &quot;nc:PersonUnionCategoryCode&quot;: &quot;married&quot;
&lt;/nc:Person&gt;                                                           | }</code></pre>
  <figcaption><a name="ex5-6">Example 5-6: A data property in an XML and JSON message</a></figcaption>

  <p>A message designer might decide to augment
  <code>nc:PersonUnionCategoryCodeType</code> with metadata to indicate
  this information is sometimes privileged. Doing so turns it into a
  literal class in his model subset. <a href="#ex5-7">Example 5-7</a>
  shows the CMF and XSD representations of that subset; <a
  href="#ex5-8">example 5-8</a> shows the resulting object in an XML and
  JSON message.</p>
  <pre><code>&lt;Restriction structures:id=&quot;nc.PersonUnionCategoryCodeSimpleType&quot;&gt;
  &lt;Name&gt;PersonUnionCategoryCodeSimpleType&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;nc&quot;/&gt;
  &lt;RestrictionBase structures:ref=&quot;xs.token&quot; xsi:nil=&quot;true&quot;/
  &lt;Enumeration&gt;
    &lt;StringValue&gt;civil union&lt;/StringValue&gt;
  &lt;/Enumeration&gt;
  &lt;Enumeration&gt;
    &lt;StringValue&gt;common law&lt;/StringValue&gt;
  &lt;/Enumeration&gt;
  &lt;Enumeration&gt;
    &lt;StringValue&gt;domestic partnership&lt;/StringValue&gt;
  &lt;/Enumeration&gt;
  &lt;Enumeration&gt;
    &lt;StringValue&gt;married&lt;/StringValue&gt;
  &lt;/Enumeration&gt;
  &lt;Enumeration&gt;
    &lt;StringValue&gt;unknown&lt;/StringValue&gt;
  &lt;/Enumeration&gt;
&lt;/Restriction&gt;
&lt;DataProperty structures:id=&quot;nc.PersonCategoryCodeLiteral&quot;&gt;
  &lt;Name&gt;PersonUnionCategoryCodeLiteral&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;nc&quot;/&gt;
  &lt;Datatype structures:ref=&quot;nc.PersonUnionCategoryCodeSimpleType/&gt;
&lt;/DataProperty&gt;
&lt;Class&gt;
  &lt;Name&gt;PersonUnionCategoryCodeType&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;nc&quot;/&gt;
  &lt;ChildPropertyAssociation&gt;
    &lt;DataProperty structures:ref=&quot;nc.PersonCategoryCodeLiteral&quot;/&gt;
    &lt;MinOccursQuantity&gt;1&lt;/MinOccursQuantity&gt;
    &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;
  &lt;/ChildPropertyAssociation&gt;
  &lt;ChildPropertyAssociation&gt;
    &lt;DataProperty structures:ref=&quot;my.privileged&quot;/&gt;
    &lt;MinOccursQuantity&gt;0&lt;/MinOccursQuantity&gt;
    &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;
    &lt;AugmentingNamespace&gt;my&lt;/AugmentingNamespace&gt;
  &lt;/ChildPropertyAssociation&gt;
&lt;/Class&gt;
----------
&lt;xs:simpleType name=&quot;PersonUnionCategoryCodeSimpleType&quot;&gt;
  &lt;xs:restriction base=&quot;xs:token&quot;&gt;
    &lt;xs:enumeration value=&quot;civil union&quot;/&gt;
    &lt;xs:enumeration value=&quot;common law&quot;/&gt;
    &lt;xs:enumeration value=&quot;domestic partnership&quot;/&gt;
    &lt;xs:enumeration value=&quot;married&quot;/&gt;
    &lt;xs:enumeration value=&quot;unknown&quot;/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;
&lt;xs:complexType name=&quot;PersonUnionCategoryCodeType&quot;&gt;
  &lt;xs:simpleContent&gt;
    &lt;xs:extension base=&quot;nc:PersonUnionCategoryCodeSimpleType&quot;&gt;
      &lt;xs:attribute ref=&quot;my:privileged&quot;/&gt;
      &lt;xs:attributeGroup ref=&quot;structures:SimpleObjectAttributeGroup&quot;/&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;</code></pre>
  <figcaption><a name="ex5-7">Example 5-7: A literal class in a CMF and XSD model subset</a></figcaption>

  <pre><code>&lt;nc:Person&gt;                                                      | &quot;nc:Person&quot;: {
  &lt;nc:PersonUnionCategoryCode my:privileged=&quot;true&quot;&gt;              |   &quot;nc:PersonUnionCategoryCode&quot;: {
    married                                                      |     &quot;nc:PersonUnionCategoryCodeLiteral&quot;: &quot;married&quot;,
  &lt;/nc:PersonUnionCategoryCode&gt;                                  |     &quot;my:privileged&quot;: &quot;true&quot;
&lt;/nc:Person&gt;                                                     |   }
                                                                 | }</code></pre>
  <figcaption><a name="ex5-8">Example 5-8: An object property with a code list class in an XML and JSON message</a></figcaption>

  <p>The representation of a literal class is complex when compared to
  the datatype. The JSON message is likewise complicated. Best practice
  is therefore to avoid augmenting a datatype whenever possible.</p>
  <h2 id="52-metadata-and-augmentation">5.2 Metadata and
  augmentation</h2>
  <p>Metadata is data about data. The distinction is created by intended
  use. To the person editing an image, the creation timestamp is
  metadata, something he does not need. To the person writing software
  to sort photos into creation order, the timestamp is the data for his
  code. One man's metadata is another man's data.</p>
  <p>The NIEM model contains a number of classes and properties that are
  suitable for metadata representations, and any model designer is free
  to invent new components for this purpose, as needed. A message
  designer may use these components in his message model, in the same
  way as any other component. For example, a message designer might,
  within the components he creates, use <code>nc:Metadata</code> to
  represent a source of information and the level of confidence in that
  information. <a href="fig5-9">Example 5-9</a> shows an example of a
  message in which the designer chose to use <code>nc:Metadata</code> as
  a property within his own <code>my:ThingType</code> class.</p>
  <pre><code>&lt;my:Thing&gt;
  &lt;my:ThingName&gt;The Snark&lt;/my:ThingName&gt;
  &lt;my:ThingLocation&gt;Dismal Valley&lt;/my:ThingLocation&gt;
  &lt;nc:Metadata&gt;
    &lt;nc:ConfidencePercent&gt;75&lt;/nc:ConfidencePercent&gt;
    &lt;nc:SourceIDText&gt;Bingo-7&lt;/nc:SourceIDText&gt;</code></pre>
  <figcaption><a name="ex5-9">Example 5-9: Metadata properties used in a designer's own class</a></figcaption>

  <p>A message designer might also want to record source and confidence
  in a class reused from another namespace. This is done through
  augmentation. <a href="#ex5-10">Example 5-10</a> shows a message
  example in which <code>nc:PersonType</code> is augmented with
  <code>nc:Metadata</code>.</p>
  <pre><code>&lt;nc:Person&gt;                                             | &quot;nc:Person&quot;: {
  &lt;nc:PersonBirthDate&gt;                                  |   &quot;nc:PersonBirthDate&quot;: {
    &lt;nc:Date&gt;2021-09-11&lt;/nc:Date&gt;                       |     &quot;nc:Date&quot;: &quot;2021-09-11&quot;
  &lt;/nc:PersonBirthDate&gt;                                 |   },
  &lt;nc:PersonName&gt;                                       |   &quot;nc:PersonName&quot;: {
    &lt;nc:PersonFullName&gt;John Doe&lt;/nc:PersonFullName&gt;     |     &quot;nc:PersonFullName&quot;: &quot;John Doe&quot;
  &lt;/nc:PersonName&gt;                                      |   },
  &lt;my:PersonAugmentation&gt;                               |   &quot;nc:Metadata&quot;: {
    &lt;nc:Metadata&quot;&gt;                                      |     &quot;nc:SourceIDText&quot;: &quot;Tango-7&quot;
      &lt;nc:SourceIDText&gt;Tango-7&lt;/nc:SourceIDText&gt;        |   }
    &lt;/nc:Metadata&gt;                                      | }
  &lt;/my:PersonAugmentation&gt;                              | 
&lt;/nc:Person&gt;                                            | </code></pre>
  <figcaption><a name="ex5-10">Example 5-10: Metadata object property augmenting a reused class</a></figcaption>

  <h2 id="53-relationship-properties">5.3 Relationship properties</h2>
  <p>The value of a property usually provides information about its
  parent object. For example, the value of
  <code>nc:personNameCommentText</code> in <a href="#ex5-11">example
  5-11</a> tells us something about the parent object; namely, that this
  name is a silly name.</p>
  <pre><code>&lt;nc:Person&gt;                                                          | &quot;nc:Person&quot;: {
  &lt;nc:PersonName nc:personNameCommentText=&quot;This is a silly name&quot;&gt;    |   &quot;nc:PersonName&quot;: {
    &lt;nc:PersonFullName&gt;Bozo the Clown&lt;/nc:PersonFullName&gt;            |     &quot;nc:personNameCommentText&quot;: &quot;This is a silly name&quot;,
  &lt;/nc:PersonName&gt;                                                   |     &quot;nc:PersonFullName&quot;: &quot;Bozo the Clown&quot;
&lt;/nc:Person&gt;                                                         |   }
                                                                     | }</code></pre>
  <figcaption><a name="ex5-11">Example 5-11: Example of an ordinary property</a></figcaption>

  <p>Sometimes information about the parent object is not what is
  needed. For example, in <a href="#ex5-12">example 5-12</a>, the <a
  href="#def-relationship-property"><span class="termRef">relationship
  property</span></a> <code>my:isSecret</code> is not telling us the
  name "Clark Kent" is a secret. That name appears on many bylines
  published by the <em>Daily Planet</em>! Instead,
  <code>my:isSecret</code> is telling us something about the
  <em>relationship</em> between the name "Clark Kent" and the person
  object that also has the name "Superman". That relationship --
  Superman's secret identity -- is the thing to be kept secret.</p>
  <pre><code>&lt;nc:Person&gt;                                                             | &quot;nc:Person&quot;: {
  &lt;nc:PersonName&gt;                                                       |   &quot;nc:PersonName&quot;: [
    &lt;nc:PersonFullName&gt;Superman&lt;/nc:PersonFullName&gt;                     |     {
  &lt;/nc:PersonName&gt;                                                      |       &quot;nc:PersonFullName&quot;: &quot;Superman&quot;
  &lt;nc:PersonName my:isSecret=&quot;true&quot;&gt;                                    |     },
    &lt;nc:PersonFullName&gt;Clark Kent&lt;/nc:PersonFullName&gt;                   |     {
  &lt;/nc:PersonName&gt;                                                      |       &quot;nc:PersonFullName&quot;: &quot;Clark Kent&quot;,
&lt;/nc:Person&gt;                                                            |       &quot;@annotation&quot;: {
                                                                        |         &quot;my:isSecret&quot;: &quot;true&quot;
                                                                        |       }
                                                                        |     }
                                                                        |   ]
                                                                        | }</code></pre>
  <figcaption><a name="ex5-12">Example 5-12: Example of a relationship property</a></figcaption>

  <p>A relationship property is represented in CMF by a Property object
  with RelationshipIndicator equal to true; in XSD, by an attribute or
  element declaration with
  <code>appinfo:relationshipIndicator="true"</code>. <a
  href="#ex5-13">Example 5-13</a> shows the model representation of the
  relationship property 'my:isSecret` in CMF and XSD. <em>(See also <a
  href="#1429-relationship-properties">§14.2.9</a>)</em></p>
  <pre><code>&lt;DataProperty&gt;
  &lt;Name&gt;isSecret&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;my&quot;/&gt;
  &lt;DocumentationText&gt;True if the relationship with this property is a secret.&lt;/DocumentationText&gt;
  &lt;RelationshipIndicator&gt;true&lt;/RelationshipIndicator&gt;
  &lt;AttributeIndicator&gt;true&lt;/AttributeIndicator&gt;
  &lt;Datatype structures:ref=&quot;xs:boolean&quot;/&gt;
&lt;/DataProperty&gt;
----------
&lt;xs:attribute name=&quot;isSecret&quot; appinfo:relationshipPropertyIndicator=&quot;true&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;True if the relationship with this property is a secret.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:attribute&gt;</code></pre>
  <figcaption><a name="ex5-13">Example 5-13: Relationship property in CMF and XSD</a></figcaption>

  <h2 id="54-roles">5.4 Roles</h2>
  <p>An object may have more than one role or function within a message.
  For example, the object for a person may at different points in a
  message represent the driver of a vehicle and a victim of a crash. The
  message data at each such point contributes different facts about the
  same object. For example, facts about a driver might include his
  driver's license, while facts about a victim might include details of
  his injuries. NIEM 6 uses object identifiers <em>(see <a
  href="#1423-objects-and-object-identifiers">§14.2.3</a>)</em> so that
  different parts of a message can contribute facts to a single message
  object. <a href="#ex5-14">Example 5-14</a> below shows the XML and
  JSON representations of a message in which the values of three object
  properties ()<code>nc:Person</code>, <code>j:CrashDriver</code>, and
  <code>j:CrashPerson</code>) all contribute facts about a single
  person.</p>
  <pre><code>&lt;nc:Person structures:uri=&quot;#P01&quot;&gt;                                           | &quot;nc:Person&quot;: {
  &lt;nc:PersonName&gt;                                                           |   &quot;@id&quot;: &quot;#P01&quot;,
    &lt;nc:PersonFullName&gt;Peter Wimsey&lt;/nc:PersonFullName&gt;                     |   &quot;nc:PersonName&quot;: {
  &lt;/nc:PersonName&gt;                                                          |     &quot;nc:PersonFullName&quot;: &quot;Peter Wimsey&quot;
&lt;/nc:Person&gt;                                                                |   }
&lt;j:CrashVehicle&gt;                                                            | },
  &lt;j:CrashDriver structures:uri=&quot;#P01&quot;&gt;                                     | &quot;j:CrashVehicle&quot;: {
    &lt;j:DriverLicense&gt;                                                       |   &quot;j:CrashDriver&quot;: {
      &lt;j:DriverLicenseCardIdentification&gt;                                   |     &quot;@id&quot;: &quot;#P01&quot;,
        &lt;nc:IdentificationID&gt;A1234567&lt;/nc:IdentificationID&gt;                 |     &quot;j:DriverLicense&quot;: {
      &lt;/j:DriverLicenseCardIdentification&gt;                                  |       &quot;j:DriverLicenseCardIdentification&quot;: {
    &lt;/j:DriverLicense&gt;                                                      |         &quot;nc:IdentificationID&quot;: &quot;A1234567&quot;
  &lt;/j:CrashDriver&gt;                                                          |       }
&lt;/j:CrashVehicle&gt;                                                           |     }
&lt;j:CrashPerson structures:uri=&quot;#P01&quot;&gt;                                       |   }
  &lt;j:CrashPersonInjury&gt;                                                     | },
    &lt;nc:InjuryDescriptionText&gt;Broken Arm&lt;/nc:InjuryDescriptionText&gt;         | &quot;j:CrashPerson&quot;: {
    &lt;j:InjurySeverityCode&gt;3&lt;/j:InjurySeverityCode&gt;                          |   &quot;@id&quot;: &quot;#P01&quot;,
  &lt;/j:CrashPersonInjury&gt;                                                    |   &quot;j:CrashPersonInjury&quot;: {
&lt;/j:CrashPerson&gt;                                                            |     &quot;nc:InjuryDescriptionText&quot;: &quot;Broken Arm&quot;,
                                                                            |     &quot;j:InjurySeverityCode&quot;: &quot;3&quot;
                                                                            |   }
                                                                            | }</code></pre>
  <figcaption><a name="ex5-14">Example 5-14: Roles and object identifiers</a></figcaption>

  <p>Earlier versions of NIEM used special <em>role types</em> (such as
  <code>nc:RoleOfPersonType</code>) for this purpose; see
  <a href="#ndr5"><b>[NDR5]</b></a>, section 10.2.2.</p>
  <h2 id="55-representation-pattern">5.5 Representation pattern</h2>
  <p>Model designers often need to have multiple representations for a
  single concept. For example, for a general concept of a point in time,
  there are numerous base representations, and innumerable ways to
  combine them. Modelers need both a representation of the general
  concept <em>a point in time</em>, plus a variety of concrete
  representations of that concept.</p>
  <p>NIEM has the <em>representation pattern</em> to satisfy this need.
  An abstract property represents the concept, and a number of concrete
  subproperties represent the various representations of that concept.
  For example, the NIEM model has the abstract property
  <code>nc:DateRepresentation</code> for the concept of a date in time.
  That representation property has several subproperties, each defining
  a particular concrete representation of a date. <a
  href="#ex5-15">Example 5-15</a> shows some of those properties in CMF
  and XSD.</p>
  <pre><code>&lt;DataProperty structures:id=&quot;nc.DateRepresentation&quot;&gt;                      | &lt;xs:element name=&quot;DateRepresentation&quot; abstract=&quot;true&quot;&gt;
  &lt;Name&gt;DateRepresentation&lt;/Name&gt;                                         |   &lt;xs:annotation&gt;
  &lt;Namespace structures:ref=&quot;nc&quot; xsi:nil=&quot;true&quot;/&gt;                         |     &lt;xs:documentation&gt;
  &lt;DocumentationText&gt;                                                     |       A data concept for a representation of a date.
    A data concept for a representation of a date.                        |     &lt;/xs:documentation&gt;
  &lt;/DocumentationText&gt;                                                    |   &lt;/xs:annotation&gt;
  &lt;AbstractIndicator&gt;true&lt;/AbstractIndicator&gt;                             | &lt;/xs:element&gt;
&lt;/ObjectProperty&gt;                                                         | 
                                                                          | &lt;xs:element name=&quot;Date&quot; type=&quot;niem-xs:date&quot;
&lt;DataProperty structures:id=&quot;nc.Date&quot;&gt;                                    |     substitutionGroup=&quot;nc:DateRepresentation&quot;&gt;
  &lt;Name&gt;Date&lt;/Name&gt;                                                       |   &lt;xs:annotation&gt;
  &lt;Namespace structures:ref=&quot;nc&quot; xsi:nil=&quot;true&quot;/&gt;                         |     &lt;xs:documentation&gt;A full date.&lt;/xs:documentation&gt;
  &lt;DocumentationText&gt;A full date.&lt;/DocumentationText&gt;                     |   &lt;/xs:annotation&gt;
  &lt;SubPropertyOf structures:ref=&quot;nc.DateRepresentation&quot; xsi:nil=&quot;true&quot;/&gt;  | &lt;/xs:element&gt;
  &lt;Datatype structures:ref=&quot;xs.date&quot; xsi:nil=&quot;true&quot;/&gt;                     | 
&lt;/DataProperty&gt;                                                           | &lt;xs:element name=&quot;DateTime&quot; type=&quot;niem-xs:dateTime&quot;
                                                                          |     substitutionGroup=&quot;nc:DateRepresentation&quot;&gt;
&lt;DataProperty structures:id=&quot;nc.DateTime&quot;&gt;                                |   &lt;xs:annotation&gt;
  &lt;Name&gt;DateTime&lt;/Name&gt;                                                   |     &lt;xs:documentation&gt;
  &lt;Namespace structures:ref=&quot;nc&quot; xsi:nil=&quot;true&quot;/&gt;                         |       A full date and time.
  &lt;DocumentationText&gt;                                                     |     &lt;/xs:documentation&gt;
    A full date and time.                                                 |   &lt;/xs:annotation&gt;
  &lt;/DocumentationText&gt;                                                    | &lt;/xs:element&gt;
  &lt;SubPropertyOf structures:ref=&quot;nc.DateRepresentation&quot; xsi:nil=&quot;true&quot;/&gt;  | 
  &lt;Datatype structures:ref=&quot;xs.dateTime&quot; xsi:nil=&quot;true&quot;/&gt;                 | 
&lt;/DataProperty&gt;                                                           | </code></pre>
  <figcaption><a name="ex5-15">Example 5-15: The DateRepresentation pattern in CMF and XSD</a></figcaption>

  <p>Many classes in the NIEM model use
  <code>nc:DateRepresentation</code> for the concept of a point in time.
  For example, <code>nc:PersonBirthDate</code> has the class
  <code>nc:DateType</code>, which uses
  <code>nc:DateRepresentation</code>. A message designer selects one or
  more concrete representations by choosing subproperties for his NIEM
  model subset. For example, the model subset might contain only the
  subproperty <code>nc:Date</code>, in which case
  <code>nc:PersonBirthDate</code> would be expressed only in terms of
  <code>nc:Date</code>. (See <a href="#ex5-11">example 5-11</a>.)</p>
  <h2 id="56-container-objects">5.6 Container objects</h2>
  <p>All NIEM properties establish a relationship between the object
  holding the property and the value of the property. For example, an
  activity object of type <code>nc:ActivityType</code> may have an
  property <code>nc:ActivityDescriptionText</code>. This property will
  be of the class <code>nc:TextType</code> and represents a NIEM
  property owned by that activity object. An occurrence of this property
  within an activity object establishes a relationship between the
  activity object and the text: the text is the description of the
  activity.</p>
  <p>In a NIEM-conformant message, a property establishes a relationship
  between the object that contains it and the property's value. This
  relationship between the object and the property may be semantically
  strong, such as the text description of an activity in the previous
  example, or it may be semantically weak, with its exact meaning left
  unstated. In NIEM, the contained property involved in a weakly defined
  semantic relationship is commonly referred to as a container
  property.</p>
  <p>A container property establishes a weakly defined relationship with
  its parent object. For example, an object of type
  <code>nc:ItemDispositionType</code> may have a container object
  <code>nc:Item</code> of the class <code>nc:ItemType</code>. The
  container object <code>nc:Item</code> does not establish what
  relationship exists between the object of
  <code>nc:ItemDispositionType</code> and itself. There could be any of
  a number of possible semantics between an object and the value of a
  container property. It could be a contained object, a subpart, a
  characteristic, or some other relationship. The appearance of this
  container property inside the <code>nc:ItemDispositionType</code>
  object merely establishes that the disposition has an item.</p>
  <p>The name of the container property is usually based on the NIEM
  class that defines it: <code>nc:PersonType</code> uses a container
  property <code>nc:Person</code>, while <code>nc:ActivityType</code>
  uses a container property <code>nc:Activity</code>. The concept of an
  property as a container property is a notional one.</p>
  <p>There are no formalized rules addressing what makes up a container
  property. A container property is vaguely defined and carries very
  little semantics about its context and its contents. Accordingly,
  there is no formal definition of container properties in NIEM; the
  metamodel has no special properties to represent a container.</p>
  <p>The appearance of a container property within a NIEM class carries
  no additional semantics about the relationship between the property
  and the parent class. The use of container properties indicates only
  that there is a relationship; it does not provide any semantics for
  interpreting that relationship.</p>
  <p>For example, the NIEM container property <code>nc:Person</code> has
  the NIEM class <code>nc:PersonType</code>. The use of the NIEM
  container property <code>nc:Person</code> in a containing NIEM class
  indicates that a person has some association with the instances of the
  containing NIEM class. But because the <code>nc:Person</code>
  container property is used, there is no additional meaning about the
  association of the person and the instance containing it. While there
  is a person associated with the instance, nothing is known about the
  relationship except its existence.</p>
  <p>The use of the Person container property is in contrast to a NIEM
  property named <code>nc:AssessmentPerson</code>, also of the NIEM
  class <code>nc:PersonType</code>. When the NIEM property
  <code>nc:AssessmentPerson</code> is contained within an instance of a
  NIEM class, it is clear that the person referenced by this property
  was responsible for an assessment of some kind, relevant to the
  exchange being modeled. The more descriptive name,
  <code>nc:AssessmentPerson</code>, gives more information about the
  relationship of the person with the containing instance, as compared
  with the semantic-free implications associated with the use of the
  nc:Person container property.</p>
  <p>When a NIEM model requires a new container property, it may define
  a new property with a concrete class and a general name, with general
  semantics. Any model may define a container property when it requires
  one.</p>
  <hr />
  <h1 id="6-conformance">6. Conformance</h1>
  <p>This document defines conformance for namespaces, schema documents,
  models, and messages. These are the conformance targets for NIEM; that
  is, these are the kinds of artifact for which conformance may be
  asserted. For each conformance target, this document specifies a set
  of conformance claims, called rules, which must be fulfilled by a
  conforming artifact. Rules are normative, and are written with the
  capitalized <a href="#rfc-2119"><b>[RFC 2119]</b></a> keywords MUST,
  MUST NOT, etc.</p>
  <p>NIEM does not define conformance for applications, systems,
  databases, or tools. It is therefore impossible for any of these to
  properly claim "NIEM conformance". However, they <em>may</em> properly
  claim to generate conforming messages or to employ conforming
  models.</p>
  <p>NIEM defines <em>conformance</em> with the rules in this document,
  but it does not define <em>compliance</em>. The distinction is based
  on assessment authority: Anyone may assess conformance with rules.
  Compliance is assessed by an authority who can compel change or
  withhold approval. The authoritative assessment in a compliance
  evaluation is out of scope for NIEMOpen.</p>
  <p>The rules in this document are designed to be used with or without
  the component definitions in the NIEM model. These rules define
  conformance to the <em>NIEM architecture</em>. Conformance to the
  <em>NIEM model</em> is a separate thing, and is not specified by this
  document.</p>
  <h2 id="61-conformance-targets">6.1 Conformance targets</h2>
  <p>The conformance targets specified in this document are listed
  below. The rules for each conformance target appear in the given
  sections.</p>
  <h3 id="611-namespace-conformance-target">6.1.1 Namespace conformance
  target</h3>
  <p>A <a
  href="#def-conforming-namespace"><span class="termRef">conforming
  namespace</span></a> is a namespace that satisfies all of the
  applicable rules in this document. The rules for this conformance
  target apply to both the CMF and XSD representations of a namespace.
  (In CMF, this is a Namespace object in a <a
  href="#def-model-file"><span class="termRef">model file</span></a>. In
  XSD, this is a <a
  href="#def-schema-document"><span class="termRef">schema
  document</span></a>.) The rules for all conforming namespaces are
  in:</p>
  <ul>
  <li><a href="#7-rules-for-model-components"><em>Section 7: Rules for
  model components</em></a></li>
  <li><a href="#8-rules-for-namespaces"><em>Section 8: Rules for
  namespaces</em></a></li>
  </ul>
  <h3 id="612-schema-document-conformance-target">6.1.2 Schema document
  conformance target</h3>
  <p>A <a
  href="#def-conforming-schema-document"><span class="termRef">conforming
  schema document</span></a> is a <a
  href="#def-schema-document"><span class="termRef">schema
  document</span></a> that satisfies all of the applicable rules in this
  document. The rules for this conformance target apply only to the XSD
  representation of a namespace. The rules for conforming schema
  documents are found in:</p>
  <ul>
  <li><a href="#91-rules-for-the-niem-profile-of-xsd"><em>Section 9.1:
  Rules for the NIEM profile of XSD</em></a></li>
  <li><a href="#92-rules-for-type-definitions"><em>Section 9.2: Rules
  for type definitions</em></a></li>
  <li><a
  href="#93-rules-for-attribute-and-element-declarations"><em>Section
  9.3: Rules for attribute and element declarations</em></a></li>
  <li><a
  href="#94-rules-for-adapters-and-external-components"><em>Section 9.4:
  Rules for adapters and external components</em></a></li>
  <li><a href="#95-rules-for-proxy-types"><em>Section 9.5: Rules for
  proxy types</em></a></li>
  <li><a href="#96-rules-for-augmentations"><em>Section 9.6: Rules for
  augmentations</em></a></li>
  <li><a href="#97-rules-for-machine-readable-annotations"><em>Section
  9.7: Rules for machine-readable annotations</em></a></li>
  <li><a href="#98-rules-for-reference-schema-documents"><em>Section
  9.8: Rules for reference schema documents</em></a></li>
  <li><a href="#99-rules-for-extension-schema-documents"><em>Section
  9.9: Rules for extension schema documents</em></a></li>
  </ul>
  <h3 id="613-model-conformance-target">6.1.3 Model conformance
  target</h3>
  <p>A conforming model fulfils all of the rules in <a
  href="#10-rules-for-models">section 10</a>. There are two
  representations for NIEM models, CMF and XSD.</p>
  <ul>
  <li><p><em>Model file:</em> A <a
  href="#def-model-file"><span class="termRef">model file</span></a> is
  a <a href="#def-message"><span class="termRef">message</span></a> that
  conforms to the CMF <a
  href="#def-message-type"><span class="termRef">message
  type</span></a>. Additional rules for this conformance target are in
  <a href="#101-rules-for-model-files">section 10.1</a>.</p></li>
  <li><p><em>Schema document set</em>: A <a
  href="#def-conforming-schema-document-set"><span class="termRef">conforming
  schema document set</span></a> is a <a
  href="#def-schema-document-set"><span class="termRef">schema document
  set</span></a> that fulfils all applicable rules in <a
  href="#10-rules-for-models">section 10</a>. Additional rules for this
  conformance target are in <a
  href="#102-rules-for-schema-document-sets">section 10.2</a>.</p></li>
  </ul>
  <h3 id="614-message-conformance-target">6.1.4 Message conformance
  target</h3>
  <ul>
  <li><p><em>Message type and message format</em>: Rules for these
  conformance targets are in <a
  href="#11-rules-for-message-types-and-message-formats">section
  11</a></p></li>
  <li><p><em>XML message</em>: Rules applying to a message in XML format
  are in <a href="#12-rules-for-xml-messages">section 12</a></p></li>
  <li><p><em>JSON message:</em> Rules applying to a message in JSON
  format are in <a href="#13-rules-for-json-messages">section
  13</a></p></li>
  </ul>
  <h2 id="62-conformance-target-assertions">6.2 Conformance target
  assertions</h2>
  <p>It is often helpful for an artifact to contain an assertion of the
  kind of thing it is supposed to be. These assertions can inform both
  people and tools. The <em>Conformance Targets Attribute
  Specification</em> <a href="#ctas"><b>[CTAS]</b></a> defines an
  attribute that, when it appears in an XML document, asserts the
  document conforms to one or more conformance targets. Specifically,
  this is the <a
  href="#def-effective-conformance-targets-attribute"><span class="termRef">effective
  conformance targets attribute</span></a>, which is the first
  occurrence (in document order) of the attribute
  <code>{https://docs.oasis-open.org/niemopen/ns/specification/conformanceTargets/6.0/}conformanceTargets</code>.</p>
  <p>For XSD, NIEMOpen makes use of <a href="#ctas"><b>[CTAS]</b></a> to
  indicate whether a <a
  href="#def-schema-document"><span class="termRef">schema
  document</span></a> is intended to represent a reference, extension,
  or subset namespace. For example, a <a
  href="#def-reference-schema-document"><span class="termRef">reference
  schema document</span></a> contains the conformance target assertion
  shown in <a href="#ex6-1">example 6-1</a> below:</p>
  <pre><code>&lt;xs:schema
  targetNamespace=&quot;https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/&quot;
  xmlns:ct=&quot;https://docs.oasis-open.org/niemopen/ns/specification/conformanceTargets/6.0/&quot;
  xmlns:nc=&quot;https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/&quot;
  ct:conformanceTargets=&quot;https://docs.oasis-open.org/niemopen/ns/specification/NDR/6.0/#ReferenceSchemaDocument&quot;
  version=&quot;1&quot;
  xml:lang=&quot;en-US&quot;&gt;</code></pre>
  <figcaption><a name="ex6-1">Example 6-1: Conformance target assertion in XSD</a></figcaption>

  <p>In CMF, the <code>ConformanceTargetURI</code> property indicates
  whether a Namespace object represents a reference, extension, or
  subset namespace. For example, the Namespace object equivalent to the
  namespace in <a href="#ex6-1">example 6-1</a> is shown below:</p>
  <pre><code>&lt;Namespace structures:id=&quot;nc&quot;&gt;
  &lt;NamespaceURI&gt;https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/&lt;/NamespaceURI&gt;
  &lt;NamespacePrefixText&gt;nc&lt;/NamespacePrefixText&gt;
  &lt;DocumentationText&gt;NIEM Core.&lt;/DocumentationText&gt;
  &lt;ConformanceTargetURI&gt;
    https://docs.oasis-open.org/niemopen/ns/specification/NDR/6.0/#ReferenceSchemaDocument
  &lt;/ConformanceTargetURI&gt;
  &lt;ArchitectureVersionName&gt;6&lt;/ArchitectureVersionName&gt;
  &lt;NamespaceVersionText&gt;1&lt;/NamespaceVersionText&gt;
  &lt;NamespaceLanguageName&gt;en-US&lt;/NamespaceLanguageName&gt;
&lt;/Namespace&gt;</code></pre>
  <figcaption><a name="ex6-2">Example 6-2: Conformance target assertion in CMF</a></figcaption>

  <h2 id="63-conformance-testing">6.3 Conformance testing</h2>
  <p>Automated testing of most rules is possible. Some rules require
  human evaluation.</p>
  <ul>
  <li><p>Many rules for schema documents may be tested by the Schematron
  rules provided in TODO.</p></li>
  <li><p>Messages must be valid when assessed against the schema of
  their <a href="#def-message-format"><span class="termRef">message
  format</span></a> <em>(see <a href="#312">§3.1.2</a>)</em>. Many of
  the rules applicable to all messages are encoded into these schemas
  when the schemas are generated from the <a
  href="#def-message-type"><span class="termRef">message type</span></a>
  by NIEMOpen developer tools; see
  <a href="https://github.com/niemopen/ntac-admin/tree/main/tools">https://github.com/niemopen/ntac-admin/tree/main/tools</a>.</p></li>
  <li><p>Rules in this document without automated testing are marked
  with <em>[Manual]</em>; for example:</p>
  <p><strong>Rule 7-42:</strong> Words or
  synonyms for the words within a data definition MUST NOT be reused as
  terms in the corresponding component name if those words dilute the
  semantics and understanding of, or impart ambiguity to, the entity or
  concept that the component represents. <em>[Manual]</em></p>
  </li>
  </ul>
  <!-- 
    Manual rules are marked with an "M" following the colon; for example:
    **Rule 7-42:M** 
  -->

  <hr />
  <h1 id="7-rules-for-model-components">7. Rules for model
  components</h1>
  <p>These rules apply to model components in both the CMF and XSD
  representations of <a
  href="#def-conforming-namespace"><span class="termRef">conforming
  namespaces</span></a>. In CMF, the representation is a Namespace
  object in a CMF model file. In XSD, it is a schema document.</p>
  <ul>
  <li>Rules for names of components appear in <a
  href="#71-rules-for-component-names">section 7.1</a></li>
  <li>Rules for documentation of components appear in <a
  href="#72-rules-for-component-documentation">section 7.2</a></li>
  <li>Rules for namespaces appear in <a
  href="#8-rules-for-namespaces">section 8</a></li>
  </ul>
  <h2 id="71-rules-for-component-names">7.1 Rules for component
  names</h2>
  <p>Data component names must be understood easily both by humans and
  by machine processes. These rules improve name consistency by
  restricting characters, terms, and syntax that could otherwise allow
  too much variety and potential ambiguity. These rules also improve
  readability of names for humans, facilitate parsing of individual
  terms that compose names, and support various automated tasks
  associated with dictionary and controlled vocabulary maintenance.</p>
  <p>These rules apply to all namespaces. In a CMF representation, they
  apply to the Name property of a Component object. In an XSD
  representation, they apply to the <code>{}name</code> attribute of a
  complex type definition, element declaration, or attribute
  declaration.</p>
  <p><a name="rule7-1"></a><strong>Rule 7-1:</strong> A namespace MUST
  NOT include two components with the same uncased name.</p>
  <p>For example, a namespace may not include both the attribute
  <code>commentText</code> and the element <code>CommentText</code>.
  This would cause problems in case-insensitive environments.</p>
  <h3 id="711-rules-based-on-kind-of-component">7.1.1 Rules based on
  kind of component</h3>
  <p><a name="rule7-2"></a><strong>Rule 7-2:</strong> Class and Datatype
  components MUST have a name ending in "Type"; Property components MUST
  NOT.</p>
  <p>This rule immediately distinguishes Property components from Class
  and Datatype components. In an XSD representation, it also avoids
  naming collisions between type definitions and element/attribute
  declarations.</p>
  <p><a name="rule7-3"></a><strong>Rule 7-3:</strong> A component MUST
  NOT have a name ending in "Augmentation", "AugmentationPoint", or
  "AugmentationType".</p>
  <p>XSD components with these names appear only as augmentation
  components in the XSD representation of a model. These XSD components
  are not themselves model components.</p>
  <h4 id="7111-rules-for-names-of-class-components">7.1.1.1 Rules for
  names of Class components</h4>
  <p><a name="rule7-4"></a><strong>Rule 7-4:</strong> An <a
  href="#def-adapter-class"><span class="termRef">adapter
  class</span></a> MUST have a name ending in "AdapterType"; all other
  components MUST NOT.</p>
  <p><a name="rule7-5"></a><strong>Rule 7-5:</strong> An <a
  href="#def-association-class"><span class="termRef">association
  class</span></a> MUST have a name ending in "AssociationType"; all
  other components MUST NOT.</p>
  <p><a name="rule7-6"></a><strong>Rule 7-6:</strong> A <a
  href="#def-literal-class"><span class="termRef">literal
  class</span></a> with a <a
  href="#def-literal-property"><span class="termRef">literal
  property</span></a> that has a <a
  href="#def-code-list-datatype"><span class="termRef">code list
  datatype</span></a> MUST have a name ending in "CodeType"; all other
  literal classes MUST NOT.</p>
  <p>These rules immediately distinguish special Class components from
  ordinary. <a href="#rule7-6">Rule 7-6</a> handles an unusual case in
  XSD. A code list in XSD is represented as a complex type with simple
  content. This usually corresponds to a Datatype component; however,
  when that complex type definition includes attribute properties, then
  it corresponds to a Class component.</p>
  <h4 id="7112-rules-for-names-of-datatype-components">7.1.1.2 Rules for
  names of Datatype components</h4>
  <p><a name="rule7-7"></a><strong>Rule 7-7:</strong> A component with a
  name ending in "SimpleType" MUST be a Datatype.</p>
  <p>A Datatype with a name ending in "SimpleType" is sometimes needed
  for a <a href="#def-literal-property"><span class="termRef">literal
  property</span></a>, or for a member type in a List or Union
  component.</p>
  <p><a name="rule7-8"></a><strong>Rule 7-8:</strong> A Datatype object
  with a name that ends in "CodeSimpleType" MUST be a <a
  href="#def-code-list-datatype"><span class="termRef">code list
  datatype</span></a>.</p>
  <p><a name="rule7-9"></a><strong>Rule 7-9:</strong> A <a
  href="#def-code-list-datatype"><span class="termRef">code list
  datatype</span></a> MUST have a name ending in "CodeType" or
  "CodeSimpleType"; all other Datatype components MUST NOT.</p>
  <p>The component representing a <a
  href="#def-code-list"><span class="termRef">code list</span></a> is
  usually a Datatype object. However, when the XSD representation of a
  code list includes attributes, it is a Class object. <em>(See <a
  href="#51-datatypes-and-literal-classes">§5.1</a>)</em></p>
  <h4 id="7113-rules-for-names-of-property-components">7.1.1.3 Rules for
  names of Property components</h4>
  <p><a name="rule7-10"></a><strong>Rule 7-10:</strong> A Property
  object having an AbstractIndicator property with the value
  <code>true</code> SHOULD have a name ending in "Abstract" or
  "Representation"; all other components SHOULD NOT.</p>
  <p>A property name ending in "Abstract" reminds message designers that
  it cannot be used directly but must be specialized. A property name
  ending in "Representation" is an instance of the representation
  pattern described in <a href="#55-representation-pattern">section
  5.5</a>.</p>
  <p><a name="rule7-11"></a><strong>Rule 7-11:</strong> A Property with
  an <a href="#def-association-class"><span class="termRef">association
  class</span></a> MUST have a name ending in "Association"; all other
  components MUST NOT.</p>
  <p><a name="rule7-12"></a><strong>Rule 7-12:</strong> A Property with
  a Class or Datatype that represents a <a
  href="#def-code-list"><span class="termRef">code list</span></a> MUST
  have a name ending in "Code"; all other components MUST NOT.</p>
  <p><a name="rule7-13"></a><strong>Rule 7-13:</strong> The <a
  href="#def-literal-property"><span class="termRef">literal
  property</span></a> of a <a
  href="#def-literal-class"><span class="termRef">literal
  class</span></a> MUST have a name ending in "Literal"; all other
  components MUST NOT.</p>
  <p>Component names ending in "Literal" only occur in the CMF
  representation of a <a
  href="#def-literal-class"><span class="termRef">literal
  class</span></a>. They do not appear in the XSD representation of a
  model.</p>
  <p><a name="rule7-14"></a><strong>Rule 7-14:</strong> A Property that
  is a <a
  href="#def-reference-attribute-property"><span class="termRef">reference
  attribute property</span></a> property MUST have a name ending in
  "Ref"; all other components MUST NOT.</p>
  <h3 id="712-rules-for-composition-of-component-names">7.1.2 Rules for
  composition of component names</h3>
  <p><a name="rule7-15"></a><strong>Rule 7-15:</strong> Except as
  otherwise provided in this document, the name of a model component
  MUST be composed of words from the English language, using the
  prevalent U.S. spelling, as provided by the Oxford English Dictionary
  <a href="#oed"><b>[OED]</b></a>. <em>[Manual]</em></p>
  <p>The English language has many spelling variations for the same
  word. For example, American English program has a corresponding
  British spelling programme. This variation has the potential to cause
  interoperability problems when XML components are exchanged because of
  the different names used by the same elements. Providing users with a
  dictionary standard for spelling will mitigate this potential
  interoperability issue.</p>
  <p>NIEM supports internationalization in several ways. NIEM allows
  (but does not encourage) component names that are not from the English
  language in <a
  href="#def-extension-schema-document"><span class="termRef">extension
  schema documents</span></a>.</p>
  <p><a name="rule7-16"></a><strong>Rule 7-16:</strong> The name of a
  model component MUST be entirely composed of specified characters.</p>
  <ul>
  <li>Upper-case letters (A-Z)</li>
  <li>Lower-case letters (a-z)</li>
  <li>Digits (0-9)</li>
  <li>Underscore (_)</li>
  <li>Hyphen (-)</li>
  <li>Period (.)</li>
  </ul>
  <p>Other characters, such as unicode characters outside the ASCII
  character set, are explicitly prohibited from the name of an XML
  Schema component defined by the schema.</p>
  <p><a name="rule7-17"></a><strong>Rule 7-17:</strong> The name of a
  model component MUST use the camel case formatting convention.</p>
  <p>Camel case is the convention of writing compound words or phrases
  with no spaces and an initial lowercase or uppercase letter, with each
  remaining word element beginning with an uppercase letter.
  <em>UpperCamelCase</em> is written with an initial uppercase letter,
  and <em>lowerCamelCase</em> is written with an initial lowercase
  letter.</p>
  <p><a name="rule7-18"></a><strong>Rule 7-18:</strong> The name of an
  <a href="#def-attribute-property"><span class="termRef">attribute
  property</span></a> MUST begin with a lowercase character.</p>
  <p><a name="rule7-19"></a><strong>Rule 7-19:</strong> The name of a
  model component that is not an <a
  href="#def-attribute-property"><span class="termRef">attribute
  property</span></a> MUST begin with an uppercase character.</p>
  <p><a name="rule7-20"></a><strong>Rule 7-20:</strong> The characters
  hyphen (-), underscore (_) MUST NOT appear in a component name unless
  used as a separator between parts of a word, phrase, or value, which
  would otherwise be incomprehensible without the use of a separator.
  The character period (.) MUST NOT appear in a component name unless as
  a decimal within a numeric value, or unless used as a separator
  between parts of a word, phrase, or value, which would otherwise be
  incomprehensible without the use of a separator. <em>[Manual]</em></p>
  <p>Names of standards and specifications, in particular, tend to
  consist of series of discrete numbers. Such names require some
  explicit separator to keep the values from running together.</p>
  <h3 id="713-general-component-naming-rules-from-iso-11179-5">7.1.3
  General component naming rules from ISO 11179-5</h3>
  <p>Names are a simple but incomplete means of providing semantics to
  data components. Data definitions, structure, and context help to fill
  the gap left by the limitations of naming. The goals for data
  component names should be syntactic consistency, semantic precision,
  and simplicity. In many cases, these goals conflict and it is
  sometimes necessary to compromise or to allow exceptions to ensure
  clarity and understanding. To the extent possible, NIEM applies
  <a href="#iso-11179-5"><b>[ISO 11179-5]</b></a> to construct NIEM data
  component names.</p>
  <p><a name="rule7-21"></a><strong>Rule 7-21:</strong> A noun used as a
  term in the name of an XML Schema component MUST be in singular form
  unless the concept itself is plural. <em>[Manual]</em></p>
  <p><a name="rule7-22"></a><strong>Rule 7-22:</strong> A verb used as a
  term in the name of an XML Schema component MUST be used in the
  present tense unless the concept itself is past tense.
  <em>[Manual]</em></p>
  <p><a name="rule7-23"></a><strong>Rule 7-23:</strong> Articles,
  conjunctions, and prepositions MUST NOT be used in NIEM component
  names except where they are required for clarity or by standard
  convention. <em>[Manual]</em></p>
  <p>Articles (e.g., a, an, the), conjunctions (e.g., and, or, but), and
  prepositions (e.g., at, by, for, from, in, of, to) are all disallowed
  in NIEM component names, unless they are required. For example,
  PowerOfAttorneyCode requires the preposition. These rules constrain
  slight variations in word forms and types to improve consistency and
  reduce potentially ambiguous or confusing component names.</p>
  <h3 id="714-property-naming-rules-from-iso-11179-5">7.1.4 Property
  naming rules from ISO 11179-5</h3>
  <p>The set of NIEM data components is a collection of data
  representations for real-world objects and concepts, along with their
  associated properties and relationships. Thus, names for these
  components would consist of the terms (words) for object classes or
  that describe object classes, their characteristic properties,
  subparts, and relationships.</p>
  <p><a name="rule7-24"></a><strong>Rule 7-24:</strong> Except as
  specified elsewhere in this document, the name of a property object
  MUST be formed by the composition of object class qualifier terms,
  object class term, property qualifier terms, property term,
  representation qualifier terms, and representation term, as detailed
  in Annex A of <a href="#iso-11179-5"><b>[ISO 11179-5]</b></a>.
  <em>[Manual]</em></p>
  <p>For example, the NIEM component name
  <code>AircraftFuselageColorCode</code> is composed of the
  following:</p>
  <ul>
  <li>Object class term = Aircraft</li>
  <li>Qualifier term = Fuselage</li>
  <li>Property term = Color</li>
  <li>Representation term = Code</li>
  </ul>
  <h4 id="7141-object-class-term">7.1.4.1 Object-class term</h4>
  <p><a name="rule7-25"></a><strong>Rule 7-25:</strong> The object-class
  term of a NIEM component MUST consist of a term identifying a category
  of concepts or entities. <em>[Manual]</em></p>
  <p>NIEM adopts an object-oriented approach to representation of data.
  Object classes represent what <a href="#iso-11179-5"><b>[ISO
  11179-5]</b></a> refers to as things of interest in a universe of
  discourse that may be found in a model of that universe. An object
  class or object term is a word that represents a class of real-world
  entities or concepts. An object-class term describes the applicable
  context for a NIEM component.</p>
  <p>The object-class term indicates the object category that this data
  component describes or represents. This term provides valuable context
  and narrows the scope of the component to an actual class of things or
  concepts. An example of a concept term is Activity. An example of an
  entity term is Vehicle.</p>
  <h4 id="7142-property-term">7.1.4.2 Property term</h4>
  <p><a name="rule7-26"></a><strong>Rule 7-26:</strong> A property term
  MUST describe or represent a characteristic or subpart of an entity or
  concept. <em>[Manual]</em></p>
  <p>Objects or concepts are usually described in terms of their
  characteristic properties, data attributes, or constituent subparts.
  Most objects can be described by several characteristics. Therefore, a
  property term in the name of a data component represents a
  characteristic or subpart of an object class and generally describes
  the essence of that data component. It describes the central meaning
  of the component.</p>
  <h4 id="7143-qualifier-terms">7.1.4.3 Qualifier terms</h4>
  <p><a name="rule7-27"></a><strong>Rule 7-27:</strong> Multiple
  qualifier terms MAY be used within a component name as necessary to
  ensure clarity and uniqueness within its namespace and usage context.
  <em>[Manual]</em></p>
  <p><a name="rule7-28"></a><strong>Rule 7-28:</strong> The number of
  qualifier terms SHOULD be limited to the absolute minimum required to
  make the component name unique and understandable.
  <em>[Manual]</em></p>
  <p><a name="rule7-29"></a><strong>Rule 7-29:</strong> The order of
  qualifiers MUST NOT be used to differentiate components.
  <em>[Manual]</em></p>
  <p>Very large vocabularies may have many similar and closely related
  properties and concepts. The use of object, property, and
  representation terms alone is often not sufficient to construct
  meaningful names that can uniquely distinguish such components.
  Qualifier terms provide additional context to resolve these
  subtleties. However, swapping the order of qualifiers rarely (if ever)
  changes meaning; qualifier ordering is no substitute for meaningful
  terms.</p>
  <h4 id="7144-representation-term">7.1.4.4 Representation term</h4>
  <p>The representation terms for a property name serve several purposes
  in NIEM:</p>
  <ol type="1">
  <li><p>It can indicate the style of component. For example, types are
  clearly labeled with the representation term Type.</p></li>
  <li><p>It helps prevent name conflicts and confusion. For example,
  elements and types may not be given the same name.</p></li>
  <li><p>It indicates the nature of the value carried by element.
  Labeling elements and attributes with a notional indicator of the
  content eases discovery and comprehension.</p></li>
  </ol>
  <p>The valid value set of a data element or value domain is described
  by the representation term. NIEM uses a standard set of representation
  terms in the representation portion of a NIEM-conformant component
  name. Table 6-1, Property representation terms, below, lists the
  primary representation terms and a definition for the concept
  associated with the use of that term. The table also lists secondary
  representation terms that may represent more specific uses of the
  concept associated with the primary representation term.</p>
  <table>
  <thead>
  <tr>
  <th>Primary</br>Representation</br>Term</th>
  <th>Secondary</br>Representation</br>Term</th>
  <th>Definition</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Amount</td>
  <td>-</td>
  <td>A number of monetary units specified in a currency where the unit
  of currency is explicit or implied.</td>
  </tr>
  <tr>
  <td>BinaryObject</td>
  <td>-</td>
  <td>A set of finite-length sequences of binary octets.</td>
  </tr>
  <tr>
  <td></td>
  <td>Graphic</td>
  <td>A diagram, graph, mathematical curves, or similar
  representation</td>
  </tr>
  <tr>
  <td></td>
  <td>Picture</td>
  <td>A visual representation of a person, object, or scene</td>
  </tr>
  <tr>
  <td></td>
  <td>Sound</td>
  <td>A representation for audio</td>
  </tr>
  <tr>
  <td></td>
  <td>Video</td>
  <td>A motion picture representation; may include audio encoded
  within</td>
  </tr>
  <tr>
  <td>Code</td>
  <td></td>
  <td>A character string (i.e., letters, figures, and symbols) that for
  brevity, language independence, or precision represents a definitive
  value of an attribute.</td>
  </tr>
  <tr>
  <td>DateTime</td>
  <td></td>
  <td>A particular point in the progression of time together with
  relevant supplementary information.</td>
  </tr>
  <tr>
  <td></td>
  <td>Date</td>
  <td>A continuous or recurring period of time, of a duration greater
  than or equal to a day.</td>
  </tr>
  <tr>
  <td></td>
  <td>Time</td>
  <td>A particular point in the progression of time within an
  unspecified 24-hour day.</td>
  </tr>
  <tr>
  <td></td>
  <td>Duration</td>
  <td>An amount of time; the length of a time span.</td>
  </tr>
  <tr>
  <td>ID</td>
  <td></td>
  <td>A character string to identify and distinguish uniquely one
  instance of an object in an identification scheme from all other
  objects in the same scheme together with relevant supplementary
  information.</td>
  </tr>
  <tr>
  <td></td>
  <td>URI</td>
  <td>A string of characters used to identify (or name) a resource. The
  main purpose of this identifier is to enable interaction with
  representations of the resource over a network, typically the World
  Wide Web, using specific protocols. A URI is either a Uniform Resource
  Locator (URL) or a Uniform Resource Name (URN). The specific syntax
  for each is defined by <a href="#rfc-3986"><b>[RFC 3986]</b></a>.</td>
  </tr>
  <tr>
  <td>Indicator</td>
  <td></td>
  <td>A list of two mutually exclusive Boolean values that express the
  only possible states of a property.</td>
  </tr>
  <tr>
  <td>Measure</td>
  <td></td>
  <td>A numeric value determined by measuring an object along with the
  specified unit of measure.</td>
  </tr>
  <tr>
  <td>Numeric</td>
  <td></td>
  <td>Numeric information that is assigned or is determined by
  calculation, counting, or sequencing. It does not require a unit of
  quantity or unit of measure.</td>
  </tr>
  <tr>
  <td></td>
  <td>Value</td>
  <td>A result of a calculation.</td>
  </tr>
  <tr>
  <td></td>
  <td>Rate</td>
  <td>A relative speed of change or progress.</td>
  </tr>
  <tr>
  <td></td>
  <td>Percent</td>
  <td>A representation of a unitless ratio, expressed as parts of a
  hundred, with 100 percent representing a ratio of 1 to 1.</td>
  </tr>
  <tr>
  <td>Quantity</td>
  <td></td>
  <td>A counted number of non-monetary units possibly including
  fractions.</td>
  </tr>
  <tr>
  <td>Text</td>
  <td>-</td>
  <td>A character string (i.e., a finite sequence of characters)
  generally in the form of words of a language.</td>
  </tr>
  <tr>
  <td></td>
  <td>Name</td>
  <td>A word or phrase that constitutes the distinctive designation of a
  person, place, thing, or concept.</td>
  </tr>
  <tr>
  <td>List</td>
  <td></td>
  <td>A sequence of values. This representation term is used in tandem
  with another of the listed representation terms.</td>
  </tr>
  <tr>
  <td>Abstract</td>
  <td></td>
  <td>An element that may represent a concept, rather than a concrete
  property. This representation term may be used in tandem with another
  of the listed representation terms.</td>
  </tr>
  <tr>
  <td>Representation</td>
  <td></td>
  <td>An element that acts as a placeholder for alternative
  representations of the value of a type</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab7-1">Table 7-1: Property representation terms</a></figcaption>

  <p><a name="rule7-30"></a><strong>Rule 7-30:</strong> If any word in
  the representation term is redundant with any word in the property
  term, one occurrence SHOULD be deleted. <em>[Manual]</em></p>
  <p>This rule, carried over from 11179, is designed to prevent
  repeating terms unnecessarily within component names. For example,
  this rule allows designers to avoid naming an element
  PersonFirstNameName.</p>
  <p><a name="rule7-31"></a><strong>Rule 7-31:</strong> The name of a
  data property SHOULD use an appropriate representation term as found
  in table 6-1, Property representation terms. <em>[Manual]</em></p>
  <p><a name="rule7-32"></a><strong>Rule 7-32:</strong> The name of an
  object property that corresponds to a concept listed in table 6-1,
  Property representation terms, SHOULD use a representation term from
  that table. <em>[Manual]</em></p>
  <p><a name="rule7-33"></a><strong>Rule 7-33:</strong> The name of an
  object property that does not correspond to a concept listed in table
  6-1, Property representation terms SHOULD NOT use a representation
  term. <em>[Manual]</em></p>
  <h3 id="715-acronyms-abbreviations-and-jargon">7.1.5 Acronyms,
  abbreviations, and jargon</h3>
  <p><a name="rule7-34"></a><strong>Rule 7-34:</strong> A component name
  SHOULD use the abbreviations shown in the table below.
  <em>[Manual]</em></p>
  <table>
  <thead>
  <tr>
  <th>Abbreviation</th>
  <th>Full Meaning</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>ID</td>
  <td>Identifier</td>
  </tr>
  <tr>
  <td>URI</td>
  <td>Uniform Resource Identifier</td>
  </tr>
  </tbody>
  </table>
  <p><a name="rule7-35"></a><strong>Rule 7-35:</strong> A <a
  href="#def-local-term"><span class="termRef">local term</span></a> MAY
  be used in the name of a component within its namespace.
  <em>[Manual]</em></p>
  <p>A <a href="#def-local-term"><span class="termRef">local
  term</span></a> is a word, phrase, acronym, or other string of
  characters that is defined within a namespace by a <a
  href="#417-localterm">LocalTerm object</a>.</p>
  <p><a name="rule7-36"></a><strong>Rule 7-36:</strong> In CMF, a
  LocalTerm object MUST have a DocumentationText property, or a
  TermLiteralText property, or both. In XSD, a <code>LocalTerm</code>
  element MUST have a <code>@definition</code> attribute, or a
  <code>@literal</code> attribute, or both.</p>
  <h2 id="72-rules-for-component-documentation">7.2 Rules for component
  documentation</h2>
  <p>NIEM models are composed of data components for the purpose of
  information exchange. A major part of defining data models is the
  proper definition of the contents of the model. What does a component
  mean, and what might it contain? How should it be used?</p>
  <p><a href="#def-reference-namespace"><span class="termRef">Reference
  namespaces</span></a> and <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespaces</span></a> provide the authoritative definition of the
  components they contain. These definitions include:</p>
  <ol type="1">
  <li><p>The structural definition of each component, expressed as CMF
  objects or XSD schema components. Where possible, meaning is expressed
  in this way.</p></li>
  <li><p>A text definition of each component, describing what the
  component means. The term used in this specification for such a text
  definition is <em>data definition</em>.</p></li>
  </ol>
  <p>A <a href="#def-data-definition"><span class="termRef">data
  definition</span></a> is the DocumentText property of a CMF object, or
  the content of the first occurrence of the element
  <code>xs:documentation</code> that is an immediate child of an
  occurrence of an element <code>xs:annotation</code> that is an
  immediate child of an XSD schema component.</p>
  <p>A <a
  href="#def-documented-component"><span class="termRef">documented
  component</span></a> is a CMF object or XSD schema component that has
  an associated data definition.</p>
  <h3 id="721-rules-for-documented-components">7.2.1 Rules for
  documented components</h3>
  <p><a name="rule7-37"></a><strong>Rule 7-37:</strong> In CMF, a
  Namespace object MUST be a documented component. In XSD, the
  <code>xs:schema</code> element MUST be a documented component.</p>
  <p><a name="rule7-38"></a><strong>Rule 7-38:</strong> In CMF, a
  Component object MUST be a documented component. In XSD, a type
  definition, element declaration, or attribute declaration MUST be a
  documented component</p>
  <p><a name="rule7-39"></a><strong>Rule 7-39:</strong> In CMF, a Facet
  object with a FacetCategoryCode of <code>enumeration</code> MUST be a
  documented component. In XSD, an <code>xs:enumeration</code> facet
  MUST be a documented component.</p>
  <p><a name="rule7-40"></a><strong>Rule 7-40:</strong> In CMF, a Facet
  object with a FacetCategoryCode of <code>pattern</code> MUST be a
  documented component. In XSD, an <code>xs:pattern</code> facet MUST be
  a documented component.</p>
  <p><a name="rule7-41"></a><strong>Rule 7-41:</strong> In CMF, the
  language name for the first instance of the DocumentationText property
  in any Namespace or Component object MUST be <code>en-US</code>. In
  XSD, the first occurrence of <code>xs:documentation</code> within
  <code>xs:annotation</code> MUST be within the scope of an occurrence
  of <code>xml:lang</code> with a value of <code>en-US</code>.</p>
  <p>A model file or schema document always contains data definitions in
  US English. It may contain equivalent data definitions in other
  languages.</p>
  <h3 id="722-rules-for-data-definitions">7.2.2 Rules for data
  definitions</h3>
  <p><a name="rule7-42"></a><strong>Rule 7-42:</strong> Words or
  synonyms for the words within a data definition MUST NOT be reused as
  terms in the corresponding component name if those words dilute the
  semantics and understanding of, or impart ambiguity to, the entity or
  concept that the component represents. <em>[Manual]</em></p>
  <p><a name="rule7-43"></a><strong>Rule 7-43:</strong> An object class
  MUST have one and only one associated semantic meaning (i.e., a single
  word sense) as described in the definition of the component that
  represents that object class. <em>[Manual]</em></p>
  <p><a name="rule7-44"></a><strong>Rule 7-44:</strong> An object class
  MUST NOT be redefined within the definitions of the components that
  represent properties or subparts of that entity or class.
  <em>[Manual]</em></p>
  <p>Data definitions should be concise, precise, and unambiguous
  without embedding additional definitions of data elements that have
  already been defined once elsewhere (such as object classes).
  <a href="#iso-11179-4"><b>[ISO 11179-4]</b></a> says that definitions
  should not be nested inside other definitions. Furthermore, a data
  dictionary is not a language dictionary. It is acceptable to reuse
  terms (object class, property term, and qualifier terms) from a
  component name within its corresponding definition to enhance clarity,
  as long as the requirements and recommendations of
  <a href="#iso-11179-4"><b>[ISO 11179-4]</b></a> are not violated. This
  further enhances brevity and precision.</p>
  <p><a name="rule7-45"></a><strong>Rule 7-45:</strong> A data
  definition SHOULD NOT contain explicit representational or data typing
  information such as number of characters, classes of characters, range
  of mathematical values, etc., unless the very nature of the component
  can be described only by such information. <em>[Manual]</em></p>
  <p>A component definition is intended to describe semantic meaning
  only, not representation or structure. How a component with simple
  content is represented is indicated through the representation term,
  but the primary source of representational information should come
  from the XML Schema definition of the types themselves. A developer
  should try to keep a component's data definition decoupled from its
  representation.</p>
  <h3 id="723-data-definition-rules-from-iso-11179-4">7.2.3 Data
  definition rules from ISO 11179-4</h3>
  <p>These rules are adopted from <a href="#iso-11179-4"><b>[ISO
  11179-4]</b></a>, <em>Information technology — Metadata registries:
  Formulation of data definitions</em></p>
  <p><a name="rule7-46"></a><strong>Rule 7-46:</strong> Each data
  definition MUST conform to the requirements for data definitions
  provided by <a href="#iso-11179-4"><b>[ISO 11179-4]</b></a> Section
  5.2, <em>Requirements</em>; namely, a data definition MUST:
  <em>[Manual]</em></p>
  <ul>
  <li>be stated in the singular</li>
  <li>state what the concept is, not only what it is not</li>
  <li>be stated as a descriptive phrase or sentence(s)</li>
  <li>contain only commonly understood abbreviations</li>
  <li>be expressed without embedding definitions of other data or
  underlying concepts</li>
  </ul>
  <p><a name="rule7-47"></a><strong>Rule 7-47:</strong> Each data
  definition SHOULD conform to the recommendations for data definitions
  provided by <a href="#iso-11179-4"><b>[ISO 11179-4]</b></a> Section
  5.2, <em>Recommendations</em>; namely, a data definition SHOULD:
  <em>[Manual]</em></p>
  <ul>
  <li>state the essential meaning of the concept</li>
  <li>be precise and unambiguous</li>
  <li>be concise</li>
  <li>be able to stand alone</li>
  <li>be expressed without embedding rationale, functional usage, or
  procedural information</li>
  <li>avoid circular reasoning</li>
  <li>use the same terminology and consistent logical structure for
  related definitions</li>
  <li>be appropriate for the type of metadata item being defined</li>
  </ul>
  <h3 id="724-data-definition-opening-phrases">7.2.4 Data definition
  opening phrases</h3>
  <p>In order to provide a more consistent voice across NIEM, a model
  built from requirements from many different sources, component data
  definitions should begin with a standard opening phrase, as defined
  below.</p>
  <h4 id="7241-opening-phrases-for-properties">7.2.4.1 Opening phrases
  for properties</h4>
  <p>These rules apply to Property objects in CMF, and to element and
  attribute declarations in XSD.</p>
  <p><a name="rule7-48"></a><strong>Rule 7-48:</strong> The data
  definition for an abstract property SHOULD begin with the standard
  opening phrase "A data concept...".</p>
  <p><a name="rule7-49"></a><strong>Rule 7-49:</strong> The data
  definition for a property that has an association type and is not
  abstract SHOULD begin with the standard opening phrase "An (optional
  adjectives) (relationship|association)...".</p>
  <p><a name="rule7-50"></a><strong>Rule 7-50:</strong> The data
  definition for a property with a date representation term SHOULD begin
  with the standard opening phrase "(A|An) (optional adjectives)
  (date|month|year)...".</p>
  <p><a name="rule7-51"></a><strong>Rule 7-51:</strong> The data
  definition for a property with a quantity representation term SHOULD
  begin with the standard opening phrase "An (optional adjectives)
  (count|number)...".</p>
  <p><a name="rule7-52"></a><strong>Rule 7-52:</strong> The data
  definition for a property with a picture representation term SHOULD
  begin with the standard opening phrase "An (optional adjectives)
  (image|picture|photograph)".</p>
  <p><a name="rule7-53"></a><strong>Rule 7-53:</strong> The data
  definition for a property with an indicator representation term SHOULD
  begin with the standard opening phrase "True if ...; false
  (otherwise|if)...".</p>
  <p><a name="rule7-54"></a><strong>Rule 7-54:</strong> The data
  definition for a property with an identification representation term
  SHOULD begin with the standard opening phrase "(A|An) (optional
  adjectives) identification...".</p>
  <p><a name="rule7-55"></a><strong>Rule 7-55:</strong> The data
  definition for a property with a name representation term SHOULD begin
  with the standard opening phrase "(A|An) (optional adjectives)
  name...".</p>
  <p><a name="rule7-56"></a><strong>Rule 7-56:</strong> The data
  definition for a property SHOULD begin with the standard opening
  phrase "(A|An)".</p>
  <h4 id="7242-opening-phrases-for-classes">7.2.4.2 Opening phrases for
  classes</h4>
  <p>These rules apply to Class objects in CMF, and to complex type
  definitions in XSD.</p>
  <p><a name="rule7-57"></a><strong>Rule 7-57:</strong> The data
  definition for an <a
  href="#def-association-class"><span class="termRef">association
  class</span></a> SHOULD begin with the standard opening phrase "A data
  type for (a relationship | an association)...".</p>
  <p><a name="rule7-58"></a><strong>Rule 7-58:</strong> The data
  definition for a class SHOULD begin with the standard opening phrase
  "A data type..."</p>
  <h2 id="73-rules-for-specifications-of-components">7.3 Rules for
  specifications of components</h2>
  <p><a name="rule7-59"></a><strong>Rule 7-59:</strong> A Restriction
  object MUST NOT contain two Facet objects with a FacetCategoryCode of
  <code>enumeration</code> and the same FacetValue.</p>
  <hr />
  <h1 id="8-rules-for-namespaces">8. Rules for namespaces</h1>
  <h2 id="81-rules-for-properties-of-namespaces">8.1 Rules for
  properties of namespaces</h2>
  <p><a name="rule8-1"></a><strong>Rule 8-1:</strong> The namespace MUST
  have an identifier, which MUST match the grammar syntax
  <code>&lt;absolute-URI&gt;</code> as defined by
  <a href="#rfc-3986"><b>[RFC 3986]</b></a>. In CMF, the namespace
  identifier is the value of the NamespaceURI property in a Namespace
  object. In XSD, the namespace identifier is the value of
  <code>@targetNamespace</code> in the <code>&lt;xs:schema&gt;</code>
  element.</p>
  <p><a name="rule8-2"></a><strong>Rule 8-2:</strong> The namespace
  identifier MUST be a URI that is owned by the namespace author, as
  defined in <a href="#webarch"><b>[webarch]</b></a> <a
  href="https://www.w3.org/TR/webarch/#uri-ownership"><em>§2.2.2.1 URI
  ownership</em></a>. <em>[Manual]</em></p>
  <p>For example, the authors of a message specification must not choose
  a namespace URI beginning with
  <code>https://docs.oasis-open.org/niemopen/ns/model/</code>, because
  ownership of that URI has been delegated to the authors of the NIEM
  model.</p>
  <p><a name="rule8-3"></a><strong>Rule 8-3:</strong> A namespace
  identifier that is not a URN SHOULD end in the slash ('/')
  character.</p>
  <p><a name="rule8-4"></a><strong>Rule 8-4:</strong> A namespace
  identifer that is a URL SHOULD end in the pattern
  <code>/<span class="normal"><i>version</i></span>/</code>, where
  <em>version</em> is a version identifier. A namespace identifier that
  is a URN SHOULD end in the pattern
  <code>:<span class="normal"><i>version</i></span></code>.</p>
  <p>Examples:</p>
  <pre><code>https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/
http://example.com/myNS/1.0.1/
http://example.com/yourNS/1.1.1-alpha.7/
urn:nato:stanag:0000:specname:1.5.1</code></pre>
  <p><a name="rule8-5"></a><strong>Rule 8-5:</strong> The version
  identifier in a namespace identifier SHOULD conform to the
  <a href="#semver"><b>[SemVer]</b></a> specification.
  <em>[Manual]</em></p>
  <p>In semantic versioning, version numbers and the way they change
  convey meaning about the underlying code and what has been modified
  from one version to the next.</p>
  <p><a name="rule8-6"></a><strong>Rule 8-6:</strong> The namespace MUST
  have a defined prefix, which MUST match the grammar syntax
  <code>&lt;NCName&gt;</code> as defined by
  <a href="#xml-namespaces"><b>[XML Namespaces]</b></a>.</p>
  <p>In CMF, the prefix is the value of the NamespacePrefix property in
  a Namespace object. In XSD, the prefix is defined by a namespace
  binding for the target namespace URI.</p>
  <p><a name="rule8-7"></a><strong>Rule 8-7:</strong> The namespace MUST
  have a version, which MUST NOT be empty. In CMF, the version is the
  value of the NamespaceVersionText property in a Namespace object. In
  XSD, the version is the value of <code>@version</code> in the
  <code>&lt;xs:schema&gt;</code> element.</p>
  <p><a name="rule8-8"></a><strong>Rule 8-8:</strong> The namespace MUST
  have a default language, which MUST be a well-formed language tag as
  defined by <a href="#rfc-4646"><b>[RFC 4646]</b></a>. In CMF, the
  default language is the value of the NamespaceLanguageName property in
  a Namespace object. In XSD, the default language is the value of
  <code>@xml:lang</code> in the <code>&lt;xs:schema&gt;</code>
  element.</p>
  <h2 id="82-rules-for-reference-namespaces">8.2 Rules for reference
  namespaces</h2>
  <p><a name="rule8-9"></a><strong>Rule 8-9:</strong> A <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> MUST assert the conformance target identifier
  <code class="uri">https://docs.oasis-open.org/niemopen/ns/specification/NDR/6.0/#ReferenceSchemaDocument</code>;
  all other namespaces MUST NOT. In CMF, this is a value of the
  ConformanceTargetURI property in the Namespace object. In XSD, this is
  an <a
  href="#def-effective-conformance-target-identifier"><span class="termRef">effective
  conformance target identifier</span></a> of the schema document
  <em>(see <a
  href="#62-conformance-target-assertions">§6.2</a>)</em>.</p>
  <p>The conformance target identifier ends in "ReferenceSchemaDocument"
  instead of "ReferenceNamespace" for historical reasons.</p>
  <p><a name="rule8-10"></a><strong>Rule 8-10:</strong> In CMF, a Class
  object with a Namespace that is a <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> MUST NOT contain an AnyPropertyAssociation
  property. In XSD, the <a
  href="#def-schema-document"><span class="termRef">schema
  document</span></a> for the <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> MUST NOT contain the element <code>xs:any</code>
  or <code>xs:anyAttribute</code>.</p>
  <p>Wildcards are permitted in <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespaces</span></a>, but not in <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespaces</span></a> or in subsets of <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespaces</span></a>.</p>
  <p><a name="rule8-11"></a><strong>Rule 8-11:</strong> In CMF, if a
  Class object or an ObjectProperty object in a <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> contains a ReferenceCode property, then that
  property MUST have a value of <code>ANY</code>. In XSD, if a type
  definition or an element declaration in a <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> has the attribute
  <code>@appinfo:referenceCode</code>, then that attribute MUST have a
  value of <code>ANY</code>.</p>
  <p>To promote reuse, object properties defined in <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespaces</span></a> and <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespaces</span></a> are always referenceable. In a subset of these
  namespaces, message designers may specify that some properties must be
  referenced via IDREF, or by URI, or must appear inline.</p>
  <p><a name="rule8-12"></a><strong>Rule 8-12:</strong> A component that
  is used in a <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> MUST be defined in a <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a>.</p>
  <h2 id="83-rules-for-extension-namespaces">8.3 Rules for extension
  namespaces</h2>
  <p><a name="rule8-13"></a><strong>Rule 8-13:</strong> An <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a> MUST assert the conformance target identifier
  <code class="uri-nb">https://docs.oasis-open.org/niemopen/ns/specification/NDR/6.0/#ExtensionSchemaDocument</code>;
  all other namespaces MUST NOT. In CMF, this is a value of the
  ConformanceTargetURI property in the Namespace object. In XSD, this is
  an <a
  href="#def-effective-conformance-target-identifier"><span class="termRef">effective
  conformance target identifier</span></a> of the schema document (see
  <a href="#62-conformance-target-assertions">§6.2</a>).</p>
  <p><a name="rule8-14"></a><strong>Rule 8-14:</strong> In CMF, if a
  Class object or an ObjectProperty object in an <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a> contains a ReferenceCode property, then that
  property MUST have a value of <code>ANY</code>. In XSD, if a type
  definition or an element declaration in an <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a> has the attribute
  <code>@appinfo:referenceCode</code>, then that attribute MUST have a
  value of <code>ANY</code>.</p>
  <h2 id="84-rules-for-subset-namespaces">8.4 Rules for subset
  namespaces</h2>
  <p><a name="rule8-15"></a><strong>Rule 8-15:</strong> A <a
  href="#def-subset-namespace"><span class="termRef">subset
  namespace</span></a> must assert the conformance target identifier
  <code class="uri-nb">https://docs.oasis-open.org/niemopen/ns/specification/NDR/6.0/#SubsetSchemaDocument</code>.
  In CMF, this is a value of the ConformanceTargetURI property in the
  Namespace object. In XSD, this is an <a
  href="#def-effective-conformance-target-identifier"><span class="termRef">effective
  conformance target identifier</span></a> of the schema document (see
  <a href="#62-conformance-target-assertions">§6.2</a>).</p>
  <p><a name="rule8-16"></a><strong>Rule 8-16:</strong> A representation
  of a <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> or <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a> with the same namespace identifier as the <a
  href="#def-subset-namespace"><span class="termRef">subset
  namespace</span></a> MUST exist. <em>[Manual]</em></p>
  <p>It is helpful when a <a
  href="#def-message-specification"><span class="termRef">message
  specification</span></a> includes the representation of the <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> or <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a>, as this facilitates automated validation of
  certain rules; however, this is not required, so long as the canonical
  representation exists somewhere.</p>
  <p><a name="rule8-17"></a><strong>Rule 8-17:</strong> A subset
  namespace MUST NOT extend the valid range of a component in the
  corresponding <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> or <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a>. <em>[Manual]</em></p>
  <p><a name="rule8-18"></a><strong>Rule 8-18:</strong> With the
  exception of an <a
  href="#def-augmentation-property"><span class="termRef">augmentation
  property</span></a>, a <a
  href="#def-subset-namespace"><span class="termRef">subset
  namespace</span></a> MUST NOT contain a component not found in the
  corresponding <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> or <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a>. <em>[Manual]</em></p>
  <p><a name="rule8-19"></a><strong>Rule 8-19:</strong> The data
  definition of a component in a <a
  href="#def-subset-namespace"><span class="termRef">subset
  namespace</span></a> MUST NOT be different than the data definition of
  the component in its <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> or <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a>. <em>[Manual]</em></p>
  <p>The previous three rules together make up the <a
  href="#def-subset-rule"><span class="termRef">subset rule</span></a>:
  Any data that is valid for a <a
  href="#def-subset-namespace"><span class="termRef">subset
  namespace</span></a> must also be valid for its <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a> or <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a>, and must have the same meaning.</p>
  <hr />
  <h1 id="9-rules-for-schema-documents">9. Rules for schema
  documents</h1>
  <p>This section contains rules that apply only to the XSD
  representation of NIEM models; that is, to <a
  href="#def-reference-schema-document"><span class="termRef">reference
  schema documents</span></a>, <a
  href="#def-extension-schema-document"><span class="termRef">extension
  schema documents</span></a>, and <a
  href="#def-subset-schema-document"><span class="termRef">subset schema
  documents</span></a>.</p>
  <p><a name="rule9-1"></a><strong>Rule 9-1:</strong> The schema
  document MUST be a conformant document as defined by
  <a href="#ctas-v3.0"><b>[CTAS-v3.0]</b></a>.</p>
  <p><a name="rule9-2"></a><strong>Rule 9-2:</strong> The <a
  href="#def-document-element"><span class="termRef">document
  element</span></a> of the XML document, and only the <a
  href="#def-document-element"><span class="termRef">document
  element</span></a>, MUST own an attribute
  <code>{https://docs.oasis-open.org/niemopen/ns/specification/conformanceTargets/6.0/}conformanceTargets</code>.</p>
  <h2 id="91-rules-for-the-niem-profile-of-xsd">9.1 Rules for the NIEM
  profile of XSD</h2>
  <p>The W3C XML Schema Language provides many constructs that allow a
  developer to represent a data model in many different ways. However, a
  number of these constructs are not permitted within NIEM-conformant
  schemas. Many of these constructs provide capability that is not
  currently needed within NIEM. Some of these constructs create problems
  for interoperability, with tool support, or with clarity or precision
  of data model definition. The rules in this section establish a
  profile of XML Schema for NIEM-conformant schemas by forbidding use of
  the problematic constructs.</p>
  <p>Note that <a
  href="#def-external-schema-document"><span class="termRef">external
  schema documents</span></a> do not need to obey the rules set forth in
  this section. So long as schema components from external schema
  documents are adapted for use with NIEM according to the modeling
  rules in <a
  href="#94-rules-for-adapters-and-external-components"><em>section 9.4:
  Rules for adapters and external components</em></a>, they may be used
  as they appear in the external standard, even if the schema components
  themselves violate the rules for NIEM-conformant schemas.</p>
  <p><a name="rule9-3"></a><strong>Rule 9-3:</strong> The XSD
  representation of a namespace MUST be a <a
  href="#def-schema-document"><span class="termRef">schema
  document</span></a>, as defined by
  <a href="#xml-schema-structures"><b>[XML Schema
  Structures]</b></a>.</p>
  <p><a name="rule9-4"></a><strong>Rule 9-4:</strong> The <a
  href="#def-document-element"><span class="termRef">document
  element</span></a> of the XSD representation of a namespace MUST be
  <code>xs:schema</code>.</p>
  <p><a name="rule9-5"></a><strong>Rule 9-5:</strong> A schema document
  MUST NOT contain any of the following elements:</p>
  <ul>
  <li><code>xs:notation</code></li>
  <li><code>xs:all</code></li>
  <li><code>xs:unique</code></li>
  <li><code>xs:key</code></li>
  <li><code>xs:keyref</code></li>
  <li><code>xs:group</code></li>
  <li><code>xs:attributeGroup</code></li>
  <li><code>xs:redefine</code></li>
  <li><code>xs:include</code></li>
  </ul>
  <p><a name="rule9-6"></a><strong>Rule 9-6:</strong> A schema component
  MUST NOT have an attribute <code>{}base</code> with a value of any of
  these types:</p>
  <ul>
  <li><code>xs:ID</code></li>
  <li><code>xs:IDREF</code></li>
  <li><code>xs:IDREFS</code></li>
  <li><code>xs:anyType</code></li>
  <li><code>xs:anySimpleType</code></li>
  <li><code>xs:NOTATION</code></li>
  <li><code>xs:ENTITY</code></li>
  <li><code>xs:ENTITIES</code></li>
  <li>any type in the XML namespace
  <code>http://www.w3.org/XML/1998/namespace</code></li>
  </ul>
  <p><a name="rule9-7"></a><strong>Rule 9-7:</strong> A schema component
  MUST NOT have an attribute <code>{}itemType</code> with any of the
  following values:</p>
  <ul>
  <li><code>xs:ID</code></li>
  <li><code>xs:IDREF</code></li>
  <li><code>xs:anySimpleType</code></li>
  <li><code>xs:ENTITY</code></li>
  </ul>
  <p><a name="rule9-8"></a><strong>Rule 9-8:</strong> A schema component
  MUST NOT have an attribute <code>{}memberTypes</code> with any of the
  following values:</p>
  <ul>
  <li><code>xs:ID</code></li>
  <li><code>xs:IDREF</code></li>
  <li><code>xs:IDREFS</code></li>
  <li><code>xs:anySimpleType</code></li>
  <li><code>xs:ENTITY</code></li>
  <li><code>xs:ENTITIES</code></li>
  </ul>
  <p><a name="rule9-9"></a><strong>Rule 9-9:</strong> A schema component
  MUST NOT have an attribute <code>{}type</code> with any of the
  following types:</p>
  <ul>
  <li><code>xs:ID</code></li>
  <li><code>xs:IDREF</code></li>
  <li><code>xs:anySimpleType</code></li>
  <li><code>xs:ENTITY</code></li>
  <li><code>xs:ENTITIES</code></li>
  </ul>
  <p><a href="#rule9-94">Rule 9-94</a> also forbids the type
  <code>xs:IDREFS</code> for all schema components other than <a
  href="#def-reference-attribute-property"><span class="termRef">reference
  attribute properties</span></a>.</p>
  <p><a name="rule9-10"></a><strong>Rule 9-10:</strong> A complex type
  definition MUST NOT have mixed content.</p>
  <p>Mixed content allows the mixing of data tags with text. Languages
  such as XHTML use this syntax for markup of text. NIEM-conformant
  schemas define XML that is for data exchange, not text markup. Mixed
  content creates complexity in processing, defining, and constraining
  content. Well-defined markup languages exist outside NIEM and may be
  used with NIEM data, and so <a
  href="#def-external-schema-document"><span class="termRef"><em>external
  schema documents</em></span></a> may include mixed content and may be
  used with NIEM.</p>
  <p><a name="rule9-11"></a><strong>Rule 9-11:</strong> A complex type
  definition MUST have a <code>xs:complexContent</code> or a
  <code>xs:simpleContent</code> child element</p>
  <p>XML Schema provides shorthand to defining complex content of a
  complex type, which is to define the complex type with immediate
  children that specify elements, or other groups, and attributes. In
  the desire to normalize schema representation of types and to be
  explicit, NIEM forbids the use of that shorthand.</p>
  <p><a name="rule9-12"></a><strong>Rule 9-12:</strong> The base type of
  a complex type with complex content MUST have complex content.</p>
  <p>This rule addresses a peculiarity of the XML Schema definition
  language, which allows a complex type to be constructed using
  xs:complexContent, and yet is derived from a complex type that uses
  xs:simpleContent. These rules ensure that each type has the content
  style indicated by the schema.</p>
  <p><a name="rule9-13"></a><strong>Rule 9-13:</strong> An untyped
  element or an element of type <code>xs:anySimpleType</code> MUST be
  abstract.</p>
  <p>Untyped element declarations act as wildcards that may carry
  arbitrary data. By declaring such types abstract, NIEM allows the
  creation of type independent semantics without allowing arbitrary
  content to appear in XML instances.</p>
  <p><a name="rule9-14"></a><strong>Rule 9-14:</strong> An element type
  MUST NOT be in the XML Schema namespace or the XML namespace.</p>
  <p><a name="rule9-15"></a><strong>Rule 9-15:</strong> An element type
  that is not <code>xs:anySimpleType</code> MUST NOT be a simple
  type.</p>
  <p><a name="rule9-16"></a><strong>Rule 9-16:</strong> An attribute
  declaration MUST have a type.</p>
  <p><a name="rule9-17"></a><strong>Rule 9-17:</strong> An element
  declaration MUST NOT have an attribute <code>{}default</code> or
  <code>{}fixed</code>.</p>
  <p><a name="rule9-18"></a><strong>Rule 9-18:</strong> An element
  <code>xs:sequence</code> MUST have a <code>minOccurs</code> and
  <code>maxOccurs</code> of 1.</p>
  <p><a name="rule9-19"></a><strong>Rule 9-19:</strong> An element
  <code>xs:choice</code> MUST be a child of
  <code>xs:sequence</code>.</p>
  <p><a name="rule9-20"></a><strong>Rule 9-20:</strong> An element
  <code>xs:choice</code> MUST have a <code>minOccurs</code> and
  <code>maxOccurs</code> of 1.</p>
  <p><a name="rule9-21"></a><strong>Rule 9-21:</strong> An XML comment
  SHOULD NOT appear in the schema.</p>
  <p>Since XML comments are not associated with any specific XML Schema
  construct, there is no standard way to interpret comments. XML Schema
  annotations should be preferred for meaningful information about
  components. NIEM specifically defines how information should be
  encapsulated in NIEM-conformant schemas via xs:annotation elements.
  Comments do not correspond to any metamodel object.</p>
  <p><a name="rule9-22"></a><strong>Rule 9-22:</strong> A child of
  element <code>xs:documentation</code> MUST be text or an XML
  comment.</p>
  <p><a name="rule9-23"></a><strong>Rule 9-23:</strong> An element
  <code>xs:import</code> MUST have an attribute
  <code>{}namespace</code>.</p>
  <p>An import that does not specify a namespace is enabling references
  to components without namespaces. NIEM requires that all components
  have a defined namespace. It is important that the namespace declared
  by a schema be universally defined and unambiguous.</p>
  <p><a name="rule9-24"></a><strong>Rule 9-24:</strong> An element
  <code>xs:import</code> MUST specify a schema document, which MUST be a
  local resource.</p>
  <p>The schema document may be specified by a
  <code>{}schemaLocation</code> attribute in the <code>xs:import</code>
  element, or by XML Catalog resolution of the <code>{}namespace</code>
  attribute, or both. Requiring a local resource ensures that the
  component definitions are known and fixed. Forbidding the use of a
  remote resource eliminates certain security vulnerabilities.</p>
  <h2 id="92-rules-for-xsd-types">9.2 Rules for XSD types</h2>
  <p>This section provides rules for <em>type definitions</em> in the
  XSD representation of a model. A type definition in XML Schema can
  create a complex data type - a type for elements with child elements -
  with <code>xs:complexType</code>). It can also create a simple data
  type, a type for elements with a literal value, with
  <code>xs:simpleType</code>.</p>
  <p><a name="rule9-25"></a><strong>Rule 9-25:</strong> A type
  definition that does not define a <a
  href="#def-proxy-type"><span class="termRef">proxy type</span></a>
  MUST have a name ending in "Type"; all other XSD components MUST
  NOT.</p>
  <p>Use of the representation term Type immediately identifies XML
  types in a NIEM-conformant schema and prevents naming collisions with
  corresponding XML elements and attributes. The exception for proxy
  types ensures that simple NIEM-compatible uses of base XML Schema
  types are familiar to people with XML Schema experience. <em>(See <a
  href="#95-rules-for-proxy-types">§9.5</a>)</em>.</p>
  <p><a name="rule9-26"></a><strong>Rule 9-26:</strong> A simple type
  definition MUST have a name ending in "SimpleType"; all other XSD
  components MUST NOT.</p>
  <p>Specific uses of type definitions have similar syntax but very
  different effects on data definitions. Schemas that clearly identify
  complex and simple type definitions are easier to understand without
  tool support. This rule ensures that names of simple types end in
  "SimpleType".</p>
  <p><a name="rule9-27"></a><strong>Rule 9-27:</strong> A complex type
  definition MUST be a Class component, a Datatype component, or a <a
  href="#def-proxy-type"><span class="termRef">proxy
  type</span></a>.</p>
  <p><a name="rule9-28"></a><strong>Rule 9-28:</strong> An element
  <code>xs:sequence</code> MUST be a child of
  <code>xs:extension</code>.</p>
  <p><a name="rule9-29"></a><strong>Rule 9-29:</strong> A type
  definition MUST be top-level.</p>
  <p>All XML Schema top-level types (children of the document element)
  are required by XML Schema to be named. By requiring these components
  to be top level, they are forced to be named and are globally
  reusable.</p>
  <p><a name="rule9-30"></a><strong>Rule 9-30:</strong> A complex type
  definition with complex content MUST be an object type, an association
  type, an <a href="#def-adapter-type"><span class="termRef">adapter
  type</span></a>, or an <a
  href="#def-augmentation-type"><span class="termRef">augmentation
  type</span></a>.</p>
  <p>The rules in this document use the name of a type as the key
  indicator of the type's category. This makes the rules much simpler
  than doing a deep examination of each type (and its base types) to
  identify its category. For complex types, the names follow a
  pattern:</p>
  <ul>
  <li>Name ends with AdapterType → type represents an <a
  href="#def-adapter-class"><span class="termRef">adapter
  class</span></a>. (see <a href="#rule7-4">Rule 7-4</a>)</li>
  <li>Name ends with AssociationType → type represents an <a
  href="#def-association-class"><span class="termRef">association
  class</span></a>. (see <a href="#rule7-5">Rule 7-5</a>)</li>
  <li>Name ends with AugmentationType → type is an <a
  href="#def-augmentation-type"><span class="termRef">augmentation
  type</span></a>.</li>
  <li>Otherwise → type is the XSD representation of an <a
  href="#def-object-class"><span class="termRef">object
  class</span></a>.</li>
  </ul>
  <p><a name="rule9-31"></a><strong>Rule 9-31:</strong> A type
  definition that represents an <a
  href="#def-adapter-class"><span class="termRef">adapter
  class</span></a> MUST be derived from
  <code>structures:AdapterType</code>.</p>
  <p><a name="rule9-32"></a><strong>Rule 9-32:</strong> A type
  definition that represents an <a
  href="#def-association-class"><span class="termRef">association
  class</span></a> MUST be derived from
  <code>structures:AssociationType</code> or from another <a
  href="#def-association-class"><span class="termRef">association
  class</span></a>.</p>
  <p><a name="rule9-33"></a><strong>Rule 9-33:</strong> A type
  definition that is an <a
  href="#def-augmentation-type"><span class="termRef">augmentation
  type</span></a> MUST be derived from
  <code>structures:AugmentationType</code>.</p>
  <p><a name="rule9-34"></a><strong>Rule 9-34:</strong> A type with
  complex content that does not represent an <a
  href="#def-adapter-class"><span class="termRef">adapter
  class</span></a>, an <a
  href="#def-association-class"><span class="termRef">association
  class</span></a>, or an <a
  href="#def-augmentation-type"><span class="termRef">augmentation
  type</span></a> MUST be derived from
  <code>structures:ObjectType</code> or from another object type.</p>
  <p><a name="rule9-35"></a><strong>Rule 9-35:</strong> A complex type
  definition with simple content MUST include
  <code>structures:SimpleObjectAttributeGroup</code>.</p>
  <p><a name="rule9-36"></a><strong>Rule 9-36:</strong> The base type
  definition of a type definition MUST have the target namespace or the
  XML Schema namespace or a namespace that is imported as
  conformant.</p>
  <p><a name="rule9-37"></a><strong>Rule 9-37:</strong> An attribute or
  element reference MUST have the target namespace or a namespace that
  is imported as conformant.</p>
  <p><a name="rule9-38"></a><strong>Rule 9-38:</strong> An attribute
  group reference MUST be
  <code>structures:SimpleObjectAttributeGroup</code>.</p>
  <p>The use of attribute groups is restricted in a <a
  href="#def-conforming-schema-document"><span class="termRef">conforming
  schema document</span></a>. The only attribute group defined by NIEM
  for use in conformant schemas is
  <code>structures:SimpleObjectAttributeGroup</code>. This attribute
  group provides the attributes necessary for identifiers and
  references.</p>
  <p><a name="rule9-39"></a><strong>Rule 9-39:</strong> The item type of
  a list simple type definition MUST have a target namespace equal to
  the target namespace of the XML Schema document within which it is
  defined, or a namespace that is imported as conformant by the <a
  href="#def-schema-document"><span class="termRef">schema
  document</span></a> within which it is defined.</p>
  <p><a name="rule9-40"></a><strong>Rule 9-40:</strong> Every member
  type of a union simple type definition MUST have a target namespace
  that is equal to either the target namespace of the XML Schema
  document within which it is defined or a namespace that is imported as
  conformant by the <a
  href="#def-schema-document"><span class="termRef">schema
  document</span></a> within which it is defined.</p>
  <h2 id="93-rules-for-attribute-and-element-declarations">9.3 Rules for
  attribute and element declarations</h2>
  <p><a name="rule9-41"></a><strong>Rule 9-41:</strong> The name of an
  element declaration or attribute declaration MUST NOT end in
  "Literal".</p>
  <p>Literal properties appear only in the CMF representation of a <a
  href="#def-literal-class"><span class="termRef">literal
  class</span></a>.</p>
  <p><a name="rule9-42"></a><strong>Rule 9-42:</strong> An attribute
  declaration or element declaration MUST be top-level.</p>
  <p><a name="rule9-43"></a><strong>Rule 9-43:</strong> An element
  declaration MUST NOT have a simple type.</p>
  <p><a name="rule9-44"></a><strong>Rule 9-44:</strong> The type
  definition of an attribute or element declaration MUST have a target
  namespace that is the target namespace, or a namespace that is
  imported as conformant.</p>
  <p><a name="rule9-45"></a><strong>Rule 9-45:</strong> An element
  substitution group MUST have either the target namespace or a
  namespace that is imported as conformant.</p>
  <p><a name="rule9-46"></a><strong>Rule 9-46:</strong> An attribute
  declaration or element declaration MUST NOT have a type from the <a
  href="#def-structures-namespace"><span class="termRef">structures
  namespace</span></a>.</p>
  <p><a name="rule9-47"></a><strong>Rule 9-47:</strong> The attribute
  declaration of a <a
  href="#def-reference-attribute-property"><span class="termRef">reference
  attribute property</span></a> MUST have type <code>xs:IDREFS</code>;
  all other attribute and element declarations MUST NOT.</p>
  <p><a
  href="#def-reference-attribute-property"><span class="termRef">Reference
  attribute properties</span></a> are a special form of object
  reference. <em>(See <a
  href="#14210-reference-attributes">§14.2.10</a>.)</em></p>
  <h2 id="94-rules-for-adapters-and-external-components">9.4 Rules for
  adapters and external components</h2>
  <p><a name="rule9-48"></a><strong>Rule 9-48:</strong> An
  <code>xs:import</code> element importing an <a
  href="#def-external-schema-document"><span class="termRef">external
  schema document</span></a> MUST own the attribute
  <code>appinfo:externalImportIndicator</code> with a value of
  <code>true</code>.</p>
  <p>An <a
  href="#def-external-schema-document"><span class="termRef">external
  schema document</span></a> is any schema document that is not</p>
  <ul>
  <li>a <a
  href="#def-reference-schema-document"><span class="termRef">reference
  schema document</span></a>, or</li>
  <li>an <a
  href="#def-extension-schema-document"><span class="termRef">extension
  schema document</span></a>, or</li>
  <li>a <a
  href="#def-subset-schema-document"><span class="termRef">subset schema
  document</span></a>, or</li>
  <li>a schema document that has the <a
  href="#def-structures-namespace"><span class="termRef">structures
  namespace</span></a> as its target namespace, or</li>
  <li>a schema document that has the XML namespace as its target
  namespace.</li>
  </ul>
  <p>There are a variety of commonly used standards that are represented
  in XML Schema. Such schemas are generally not NIEM-conformant.
  NIEM-conformant schemas may reference components defined by these
  external schema documents.</p>
  <p>A schema component defined by an external schema document may be
  called an external component. A NIEM-conformant type may use external
  components in its definition. There are two ways to integrate <a
  href="#def-external-component"><span class="termRef">external
  components</span></a> into a NIEM-conformant schema:</p>
  <ul>
  <li><p>An <a href="#def-adapter-class"><span class="termRef">adapter
  class</span></a> may be constructed from externally-defined elements
  and attributes. A goal of this method is to represent, as a single
  unit, a set of data that embodies a single concept from an external
  standard.</p></li>
  <li><p>A type that is not an <a
  href="#def-adapter-type"><span class="termRef">adapter
  type</span></a>, and which is defined by an <a
  href="#def-extension-schema-document"><span class="termRef">extension
  schema document</span></a> or <a
  href="#def-subset-schema-document"><span class="termRef">subset schema
  document</span></a>, may incorporate an externally-defined
  attribute.</p></li>
  </ul>
  <p><a name="rule9-49"></a><strong>Rule 9-49:</strong> An
  <code>xs:import</code> element importing an <a
  href="#def-external-schema-document"><span class="termRef">external
  schema document</span></a> MUST be a <a
  href="#def-documented-component"><span class="termRef">documented
  component</span></a>.</p>
  <p>A NIEM-conformant schema has well-known documentation points.
  Therefore, a schema that imports a NIEM-conformant namespace need not
  provide additional documentation for the imported namespace. However,
  when an external schema document is imported, appropriate
  documentation must be provided on the <code>xs:import</code> element.
  This ensures that documentation for all external schema documents will
  be both available and accessible in a consistent manner.</p>
  <p><a name="rule9-50"></a><strong>Rule 9-50:</strong> An <a
  href="#def-adapter-type"><span class="termRef">adapter type</span></a>
  definition MUST be a complex type definition with complex content that
  extends <code>structures:ObjectType</code>, and that uses
  <code>xs:sequence</code> as its top-level compositor.</p>
  <p>An <a href="#def-adapter-type"><span class="termRef">adapter
  type</span></a> is a NIEM-conformant type that adapts <a
  href="#def-external-component"><span class="termRef">external
  components</span></a> for use within NIEM. An <a
  href="#def-adapter-type"><span class="termRef">adapter type</span></a>
  creates a new class of object that embodies a single concept composed
  of <a href="#def-external-component"><span class="termRef">external
  components</span></a>. A NIEM-conformant schema defines an <a
  href="#def-adapter-type"><span class="termRef">adapter
  type</span></a>.</p>
  <p>An <a href="#def-adapter-type"><span class="termRef">adapter
  type</span></a> should contain the information from an external
  standard to express a complete concept. This expression should be
  composed of content entirely from an external schema document. Most
  likely, the <a
  href="#def-external-schema-document"><span class="termRef">external
  schema document</span></a> will be based on an external standard with
  its own legacy support.</p>
  <p>In the case of an external expression that is in the form of model
  groups, attribute groups, or types, additional elements and type
  components may be created in an external schema document, and the <a
  href="#def-adapter-type"><span class="termRef">adapter type</span></a>
  may use those components.</p>
  <p>In normal (conformant) type definitions, a reference to an
  attribute or element is a reference to a documented component. Within
  an <a href="#def-adapter-type"><span class="termRef">adapter
  type</span></a>, the references to the attributes and elements being
  adapted are references to undocumented components. These components
  must be documented to provide comprehensibility and interoperability.
  Since documentation made available by nonconformant schemas is
  undefined and variable, documentation of these components is required
  at their point of use, within the conformant schema.</p>
  <p><a name="rule9-51"></a><strong>Rule 9-51:</strong> An element
  reference that appears within an <a
  href="#def-adapter-type"><span class="termRef">adapter type</span></a>
  MUST have a target namespace that is imported as external.</p>
  <p><a name="rule9-52"></a><strong>Rule 9-52:</strong> An <a
  href="#def-adapter-type"><span class="termRef">adapter type</span></a>
  definition MUST NOT be a base type definition.</p>
  <p><a name="rule9-53"></a><strong>Rule 9-53:</strong> An external
  attribute use MUST be a documented component with a non-empty data
  definition.</p>
  <p><a name="rule9-54"></a><strong>Rule 9-54:</strong> An attribute use
  schema component MUST NOT have an attribute declaration with an ID
  type.</p>
  <p>NIEM schemas use <code>structures:id</code> to enable references
  between components. Each NIEM-defined complex type in a reference or
  extension schema document must incorporate a definition for
  <code>structures:id</code>. <a href="#xml"><b>[XML]</b></a> Section
  3.3.1, Attribute Types entails that a complex type may have no more
  than one ID attribute. This means that an external attribute use must
  not be an ID attribute.</p>
  <p>The term "attribute use schema component" is defined by
  <a href="#xml-schema-structures"><b>[XML Schema Structures]</b></a>
  Section 3.5.1, The Attribute Use Schema Component. Attribute type ID
  is defined by <a href="#xml"><b>[XML]</b></a> Section 3.3.1, Attribute
  Types.</p>
  <p><a name="rule9-55"></a><strong>Rule 9-55:</strong> An external
  attribute use MUST be a documented component with a non-empty data
  definition.</p>
  <h2 id="95-rules-for-proxy-types">9.5 Rules for proxy types</h2>
  <p><a name="rule9-56"></a><strong>Rule 9-56:</strong> The XSD
  declaration of a <a href="#def-proxy-type"><span class="termRef">proxy
  type</span></a> MUST have the same name as the simple type it
  extends.</p>
  <p>A <a href="#def-proxy-type"><span class="termRef">proxy
  type</span></a> is an XSD complex type definition with simple content
  that extends one of the simple types in the XML Schema namespace with
  <code>structures:SimpleObjectAttributeGroup</code>; for example:</p>
  <pre><code>&lt;xs:complexType name=&quot;string&quot;&gt;
  &lt;xs:simpleContent&gt;
    &lt;xs:extension base=&quot;xs:string&quot;&gt;
      &lt;xs:attributeGroup ref=&quot;structures:SimpleObjectAttributeGroup&quot;/&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;</code></pre>
  <p>A <a href="#def-proxy-type"><span class="termRef">proxy
  type</span></a> is not a model component. It is a convenience complex
  type definition wrapper for a simple type in the XML Schema namespace;
  for example, <code>niem-xs:token</code> is a proxy type wrapper for
  <code>xs:token</code>. Unlike other complex type definitions, proxy
  types have the same local name as the builtin simple type. This is
  done to make conformant schemas more understandable to people that are
  familiar with the names of the XML Schema namespace simple types.</p>
  <p><a name="rule9-57"></a><strong>Rule 9-57:</strong> A proxy type
  MUST have the designated structure. It MUST use
  <code>xs:extension</code>. It MUST NOT use <code>xs:attribute</code>.
  It MUST include exactly one <code>xs:attributeGroup</code> reference,
  which must be to
  <code>structures:SimpleObjectAttributeGroup</code>.</p>
  <h2 id="96-rules-for-augmentations">9.6 Rules for augmentations</h2>
  <p><a name="rule9-58"></a><strong>Rule 9-58:</strong> The XSD
  definition of an <a
  href="#def-augmentation-type"><span class="termRef">augmentation
  type</span></a> MUST have a name ending in "AugmentationType"; all
  other XSD components MUST NOT.</p>
  <p><a name="rule9-59"></a><strong>Rule 9-59:</strong> The XSD
  declaration of an <a
  href="#def-augmentation-element"><span class="termRef">augmentation
  element</span></a> MUST have a name ending in "Augmentation"; all
  other XSD components MUST NOT.</p>
  <p><a name="rule9-60"></a><strong>Rule 9-60:</strong> The XSD
  declaration of an <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a> MUST have a name ending in
  "AugmentationPoint"; all other XSD components MUST NOT.</p>
  <p><a name="rule9-61"></a><strong>Rule 9-61:</strong> The data
  definition for an <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a> SHOULD begin with standard opening phrase "An
  augmentation point...".</p>
  <p><a name="rule9-62"></a><strong>Rule 9-62:</strong> The data
  definition for an <a
  href="#def-augmentation-element"><span class="termRef">augmentation
  element</span></a> SHOULD begin with the standard opening phrase
  "Supplements..." or "Additional information about...".</p>
  <p><a name="rule9-63"></a><strong>Rule 9-63:</strong> The data
  definition for an <a
  href="#def-augmentation-type"><span class="termRef">augmentation
  type</span></a> SHOULD begin with the standard opening phrase "A data
  type (that supplements|for additional information about)...".</p>
  <p><a name="rule9-64"></a><strong>Rule 9-64:</strong> A type
  definition that is an <a
  href="#def-association-type"><span class="termRef">association
  type</span></a> or an <a
  href="#def-object-type"><span class="termRef">object type</span></a>
  MUST have exactly one <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a>.</p>
  <p><a name="rule9-65"></a><strong>Rule 9-65:</strong> The name of the
  <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a> within an <a
  href="#def-association-type"><span class="termRef">association
  type</span></a> or an <a
  href="#def-object-type"><span class="termRef">object type</span></a>
  MUST be the same as the complex type name, with the suffix "Type"
  replaced by "AugmentationPoint".</p>
  <p>For example, the <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a> for an <a
  href="#def-object-type"><span class="termRef">object type</span></a>
  named <code>FooType</code> must be named
  <code>FooAugmentationPoint</code>.</p>
  <p><a name="rule9-66"></a><strong>Rule 9-66:</strong> A schema
  document containing an element declaration for an <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a> MUST also contain a complex type definition
  for its augmented base type.</p>
  <p>For example, a schema document with an element declaration for
  <code>FooAugmentationPoint</code> must also contain a complex type
  definition for <code>FooType</code>.</p>
  <p><a name="rule9-67"></a><strong>Rule 9-67:</strong> An <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a> MUST have no type.</p>
  <p><a name="rule9-68"></a><strong>Rule 9-68:</strong> An <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a> MUST NOT have a substitution group.</p>
  <p><a name="rule9-69"></a><strong>Rule 9-69:</strong> An <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a> MUST only be referenced by its base type.</p>
  <p>For example, the <code>FooAugmentationPoint</code> element must not
  be referenced by any type other than <code>FooType</code>.</p>
  <p><a name="rule9-70"></a><strong>Rule 9-70:</strong> An <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a> particle MUST have attribute
  <code>minOccurs</code> equal to 0 and attribute <code>maxOccurs</code>
  set to unbounded.</p>
  <p><a name="rule9-71"></a><strong>Rule 9-71:</strong> An <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a> particle MUST be the last element occurrence
  in the content model of its augmentable type.</p>
  <p><a name="rule9-72"></a><strong>Rule 9-72:</strong> The name of an
  <a href="#def-augmentation-element"><span class="termRef">augmentation
  element</span></a> MUST be the same as the name of the augmented type
  definition, with the suffix "Type" replaced with "Augmentation".</p>
  <p>For example, an <a
  href="#def-augmentation-element"><span class="termRef">augmentation
  element</span></a> substitutable for
  <code>PersonAugmentationPoint</code> must be named
  <code>PersonAugmentation</code>.</p>
  <p><a name="rule9-73"></a><strong>Rule 9-73:</strong> The declaration
  of an <a
  href="#def-augmentation-element"><span class="termRef">augmentation
  element</span></a> MUST have a type that is an <a
  href="#def-augmentation-type"><span class="termRef">augmentation
  type</span></a>; all other element declarations MUST NOT.</p>
  <p><a name="rule9-74"></a><strong>Rule 9-74:</strong> The declaration
  of an <a
  href="#def-augmentation-element"><span class="termRef">augmentation
  element</span></a> MUST be a member of a substitution group headed by
  an <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a>; all other element declarations MUST NOT.</p>
  <p><a name="rule9-75"></a><strong>Rule 9-75:</strong> A schema
  document MUST NOT contain two element declarations that are
  substitutable for the same <a
  href="#def-augmentation-point-element"><span class="termRef">augmentation
  point element</span></a>.</p>
  <p><a name="rule9-76"></a><strong>Rule 9-76:</strong> A complex type
  definition MUST NOT have an element use of an <a
  href="#def-augmentation-element"><span class="termRef">augmentation
  element</span></a> declaration, or an element declaration that is in
  the substitution group of an augmentation point element
  declaration.</p>
  <p><a
  href="#def-augmentation-element"><span class="termRef">Augmentation
  elements</span></a> do not correspond to a model component, and must
  not be used as a property in any class.</p>
  <p><a name="rule9-77"></a><strong>Rule 9-77:</strong> A schema
  document MUST NOT contain two element declarations with the same <a
  href="#def-augmentation-type"><span class="termRef">augmentation
  type</span></a>.</p>
  <p>For example, a schema document may not contain</p>
  <pre><code>&lt;xs:element name=&quot;PersonAugmentation&quot; type=&quot;my:ReusableAugmentationType&quot; ...&gt;
&lt;xs:element name=&quot;OrganizationAugmentation&quot; type=&quot;my:ReusableAugmentationType&quot; ...&gt;</code></pre>
  <p><a name="rule9-78"></a><strong>Rule 9-78:</strong> The name of an
  <a href="#def-augmentation-type"><span class="termRef">augmentation
  type</span></a> MUST be the same as the name of the augmented type
  definition, with the suffix "Type" replaced with
  "AugmentationType".</p>
  <p>For example, an <a
  href="#def-augmentation-type"><span class="termRef">augmentation
  type</span></a> for <code>nc:PersonType</code> must be named
  <code>PersonAugmentationType</code>.</p>
  <p><a name="rule9-79"></a><strong>Rule 9-79:</strong> The definition
  of an <a
  href="#def-augmentation-type"><span class="termRef">augmentation
  type</span></a> MUST NOT contain the schema component
  <code>xs:any</code> or <code>xs:anyAttribute</code>.</p>
  <h2 id="97-rules-for-machine-readable-annotations">9.7 Rules for
  machine-readable annotations</h2>
  <p>NIEM defines a single namespace that holds components for use in
  NIEM-conformant schema application information, represented by the URI
  <code>https://docs.oasis-open.org/niemopen/ns/model/appinfo/6.0/</code>.
  This namespace is referred to as the <a
  href="#def-appinfo-namespace"><span class="termRef">appinfo
  namespace</span></a>.</p>
  <p><a name="rule9-80"></a><strong>Rule 9-80:</strong> An attribute in
  the <a href="#def-appinfo-namespace"><span class="termRef">appinfo
  namespace</span></a> MUST be owned by an element with a namespace name
  <code>http://www.w3.org/2001/XMLSchema</code> .</p>
  <p><a name="rule9-81"></a><strong>Rule 9-81:</strong> A child of
  element <code>xs:appinfo</code> MUST be an element, a comment, or
  whitespace text.</p>
  <p><a name="rule9-82"></a><strong>Rule 9-82:</strong> An element that
  is a child of <code>xs:appinfo</code> MUST have a namespace name.</p>
  <p><a name="rule9-83"></a><strong>Rule 9-83:</strong> An element that
  is a descendent of <code>xs:appinfo</code> MUST NOT have the XML
  Schema namespace.</p>
  <p><a name="rule9-84"></a><strong>Rule 9-84:</strong> A schema
  component that has an attribute <code>appinfo:deprecated</code> with a
  value of true MUST be a deprecated component.</p>
  <p><a name="rule9-85"></a><strong>Rule 9-85:</strong> When the element
  <code>appinfo:LocalTerm</code> appears in a schema document, it MUST
  be application information on an element <code>xs:schema</code>.</p>
  <h2 id="98-rules-for-reference-schema-documents">9.8 Rules for
  reference schema documents</h2>
  <p><a name="rule9-86"></a><strong>Rule 9-86:</strong> A <a
  href="#def-reference-schema-document"><span class="termRef">reference
  schema document</span></a> MUST NOT have an attribute
  <code>{}final</code>.</p>
  <p><a name="rule9-87"></a><strong>Rule 9-87:</strong> A simple type
  constraining facet in a <a
  href="#def-reference-schema-document"><span class="termRef">reference
  schema document</span></a> MUST NOT have an attribute
  <code>{}fixed</code>.</p>
  <p><a name="rule9-88"></a><strong>Rule 9-88:</strong> A <a
  href="#def-reference-schema-document"><span class="termRef">reference
  schema document</span></a> MUST NOT contain the attribute
  <code>{}block</code> or <code>{}blockDefault</code>.</p>
  <p><a name="rule9-89"></a><strong>Rule 9-89:</strong> A <a
  href="#def-reference-schema-document"><span class="termRef">reference
  schema document</span></a> MUST NOT contain the attribute
  <code>{}final</code> or <code>{}finalDefault</code>.</p>
  <p><a name="rule9-90"></a><strong>Rule 9-90:</strong> An element
  declaration in a <a
  href="#def-reference-schema-document"><span class="termRef">reference
  schema document</span></a> MUST have the <code>{nillable}</code>
  property with a value of true.</p>
  <p>Properties in a reference or extension namespace are always
  referenceable, in order to maximize reuse. Message designers may make
  some properties un-referenceable in a namespace subset.</p>
  <p><a name="rule9-91"></a><strong>Rule 9-91:</strong> A <a
  href="#def-reference-schema-document"><span class="termRef">reference
  schema document</span></a> MUST NOT contain the element
  <code>xs:choice</code>.</p>
  <p><a name="rule9-92"></a><strong>Rule 9-92:</strong> A <a
  href="#def-reference-schema-document"><span class="termRef">reference
  schema document</span></a> MUST NOT contain the element
  <code>xs:any</code> or <code>xs:anyAttribute</code>.</p>
  <p><a name="rule9-93"></a><strong>Rule 9-93:</strong> An <a
  href="#def-external-attribute"><span class="termRef">external
  attribute</span></a> use within a <a
  href="#def-reference-schema-document"><span class="termRef">reference
  schema document</span></a> MUST be in an <a
  href="#def-adapter-type"><span class="termRef">adapter
  type</span></a>.</p>
  <h2 id="99-rules-for-extension-schema-documents">9.9 Rules for
  extension schema documents</h2>
  <p><a name="rule9-94"></a><strong>Rule 9-94:</strong> An element
  declaration in an <a
  href="#def-extension-schema-document"><span class="termRef">extension
  schema document</span></a> MUST have the <code>{nillable}</code>
  property with a value of true.</p>
  <hr />
  <h1 id="10-rules-for-models">10. Rules for models</h1>
  <p>These rules apply to both the CMF and XSD representations of a
  model.</p>
  <p><a name="rule10-1"></a><strong>Rule 10-1:</strong> Every namespace
  in a model MUST be one of the following:</p>
  <ul>
  <li>a <a
  href="#def-conforming-namespace"><span class="termRef">conforming
  namespace</span></a>; that is, a <a
  href="#def-reference-namespace"><span class="termRef">reference
  namespace</span></a>, <a
  href="#def-extension-namespace"><span class="termRef">extension
  namespace</span></a>, or <a
  href="#def-subset-namespace"><span class="termRef">subset
  namespace</span></a></li>
  <li>an <a
  href="#def-external-namespace"><span class="termRef">external
  namespace</span></a></li>
  <li>the <a
  href="#def-structures-namespace"><span class="termRef">structures
  namespace</span></a></li>
  <li>the XML namespace,
  <code>http://www.w3.org/XML/1998/namespace</code></li>
  <li>the XSD namespace,
  <code>http://www.w3.org/2001/XMLSchema</code>.</li>
  </ul>
  <p>The <a href="#def-appinfo-namespace"><span class="termRef">appinfo
  namespace</span></a> is not part of a NIEM model. It provides schema
  components for use in the XSD representation of a NIEM model.</p>
  <p><a name="rule10-2"></a><strong>Rule 10-2:</strong> A model MUST NOT
  contain two namespaces with the same prefix.</p>
  <p>In a NIEM model there is always a one-to-one match between
  namespace prefix and namespace URI.</p>
  <h2 id="101-rules-for-model-files">10.1 Rules for model files</h2>
  <p><a name="rule10-3"></a><strong>Rule 10-3:</strong> A model MUST NOT
  contain two namespaces with the same identifier.</p>
  <p>This is impossible in an XSD representation of a model. It must not
  be done in CMF.</p>
  <h2 id="102-rules-for-schema-document-sets">10.2 Rules for schema
  document sets</h2>
  <p>A <a href="#def-schema-document-set"><span class="termRef">schema
  document set</span></a> is a collection of <a
  href="#def-schema-document"><span class="termRef">schema
  documents</span></a> that together are capable of validating an XML
  document.</p>
  <p><a name="rule10-4"></a><strong>Rule 10-4:</strong> The <a
  href="#def-schema-document"><span class="termRef">schema
  documents</span></a> in a <a
  href="#def-schema-document-set"><span class="termRef">schema document
  set</span></a> MUST be exactly those determined by the following
  procedure:</p>
  <ul>
  <li>Beginning with the empty set</li>
  <li>Add one or more specified initial <a
  href="#def-schema-document"><span class="termRef">schema
  documents</span></a></li>
  <li>As each <a
  href="#def-schema-document"><span class="termRef">schema
  document</span></a> is added, find each <code>&lt;xs:import&gt;</code>
  element contained therein, and add the <a
  href="#def-schema-document"><span class="termRef">schema
  document</span></a> specified by that element to the set.</li>
  </ul>
  <p>Schema assembly is underspecified in <a href="#xml-schema"><b>[XML
  Schema]</b></a>. But a specification that defines message conformance
  in terms of schema validation must have some way to establish the
  schema used to assess validity. Otherwise no one can be certain what
  conforms. This rule establishes the needed certainty.</p>
  <p>Most schema document sets are established by a single extension
  schema document, with all other needed schema documents brought in by
  <code>xs:import</code> elements. But it is also allowable to list
  every document as an initial schema document. Or to have a single
  initial document with no namespace, containing nothing but
  <code>xs:import</code> elements for each document in the set.</p>
  <p><a name="rule10-5"></a><strong>Rule 10-5:</strong> The members of a
  <a href="#def-schema-document-set"><span class="termRef">schema
  document set</span></a> MUST NOT contain two <code>xs:import</code>
  elements that have the same <code>{}namespace</code> attribute but
  specify different schema documents.</p>
  <p>XML Schema permits conflicting imports, but the result is
  underspecified, and can cause errors that are very hard to detect and
  diagnose.</p>
  <p><a name="rule10-6"></a><strong>Rule 10-6:</strong> The members of a
  <a href="#def-schema-document-set"><span class="termRef">schema
  document set</span></a> MUST NOT contain two <code>xs:import</code>
  elements with the same namespace but different values for
  <code>appinfo:externalImportIndicator</code>.</p>
  <p><a name="rule10-7"></a><strong>Rule 10-7:</strong> There MUST be a
  one-to-one match between namespace prefix and namespace URI among all
  the members of a <a
  href="#def-schema-document-set"><span class="termRef">schema document
  set</span></a>.</p>
  <p>XML Schema permits a schema document set to contain</p>
  <ul>
  <li>schema document A containing
  <code>xmlns:foo="http://example.com/MyFoo/"</code></li>
  <li>schema document B containing
  <code>xmlns:bar="http://example.com/MyFoo/"</code></li>
  <li>schema document C containing
  <code>xmlns:foo="http://example.com/MyBar/"</code></li>
  </ul>
  <p>This is not allowed in NIEM XSD. There is always a one-to-one match
  between namespace prefix and URI in CMF.</p>
  <p><a name="rule10-8"></a><strong>Rule 10-8:</strong> A <a
  href="#def-schema-document-set"><span class="termRef">schema document
  set</span></a> MUST be complete; that is, it MUST contain the
  definition of every schema component referenced by any component
  defined by the schema set.</p>
  <p>A <a href="#def-schema-document-set"><span class="termRef">schema
  document set</span></a> defines an XML Schema that may be used to
  validate an XML document. This rule ensures that a schema document set
  under consideration contains definitions for everything that it
  references; it has everything necessary to do a complete validation of
  XML documents, without any unresolved references. Note that some tools
  may allow validation of documents using partial schemas, when
  components that are not present are not exercised by the XML document
  under validation. Such a schema does not satisfy this rule.</p>
  <p><a name="rule10-9"></a><strong>Rule 10-9:</strong> A <a
  href="#def-schema-document-set"><span class="termRef">schema document
  set</span></a> MUST include the <a
  href="#def-structures-namespace"><span class="termRef">structures
  namespace</span></a> as it is defined in <a
  href="#appendix-b--structures-namespace">Appendix B</a> of this
  document.</p>
  <p>This rule further enforces uniform and consistent use of the NIEM
  structures namespace, without addition. Users are not allowed to
  insert types, attributes, etc. that are not specified by this
  document.</p>
  <hr />
  <h1 id="11-rules-for-message-types-and-message-formats">11. Rules for
  message types and message formats</h1>
  <p><a name="rule11-1"></a><strong>Rule 11-1:</strong> A <a
  href="#def-message-type"><span class="termRef">message type</span></a>
  MUST declare the initial property of conforming <a
  href="#def-message"><span class="termRef">messages</span></a>.</p>
  <p>This document does not specify any particular syntax for the
  declaration.</p>
  <p><a name="rule11-2"></a><strong>Rule 11-2:</strong> The <a
  href="#def-schema"><span class="termRef">schema</span></a> for a <a
  href="#def-message-format"><span class="termRef">message
  format</span></a> MUST validate exactly those <a
  href="#def-message"><span class="termRef">messages</span></a> that
  conform to the format's <a
  href="#def-message-type"><span class="termRef">message
  type</span></a>. <em>[Manual]</em></p>
  <p>This is the only conformance rule for the XML Schema in an XML
  message format, or the JSON Schema in a JSON message format. NIEMOpen
  provides free and open-source software to generate conforming schemas
  from the message type. Developers are also free to construct those
  schemas by hand.</p>
  <hr />
  <h1 id="12-rules-for-xml-messages">12. Rules for XML messages</h1>
  <p><a name="rule12-1"></a><strong>Rule 12-1:</strong> An XML <a
  href="#def-message"><span class="termRef">message</span></a> MUST be
  an XML document that contains one instance of the element for the
  initial property specified by its <a
  href="#def-message-type"><span class="termRef">message
  type</span></a>, and all of the message content MUST be a descendent
  of that element.</p>
  <p>The element for the initial property is often the document element,
  but this is not necessarily so. An XML message may be embedded within
  an XML document; for example, as a payload within a SOAP response.</p>
  <p><a name="rule12-2"></a><strong>Rule 12-2:</strong> An XML <a
  href="#def-message"><span class="termRef">message</span></a> MUST be
  schema-valid as assessed against the <a
  href="#def-schema-document-set"><span class="termRef">schema document
  set</span></a> that represents the <a
  href="#def-message-model"><span class="termRef">message
  model</span></a> of a <a
  href="#def-message-type"><span class="termRef">message
  type</span></a>.</p>
  <p>This rule should not be construed to mean that XML validation must
  be performed on all XML instances as they are served or consumed; only
  that the XML instances validate if XML validation is performed. The
  XML Schema component definitions specify XML documents and element
  information items, and the instances should follow the rules given by
  the schemas, even when validation is not performed.</p>
  <p><a name="rule12-3"></a><strong>Rule 12-3:</strong> An XML <a
  href="#def-message"><span class="termRef">message</span></a> MUST NOT
  contain an attribute that is schema-valid only by virtue of an
  <code>xs:anyAttribute</code> element in the <a
  href="#def-structures-namespace"><span class="termRef">structures
  namespace</span></a>.</p>
  <p>The <a href="#def-schema-document"><span class="termRef">schema
  document</span></a> for the <a
  href="#def-structures-namespace"><span class="termRef">structures
  namespace</span></a> contains <code>xs:anyAttribute</code> elements
  for the purpose of attribute augmentation. This permits a message
  designer to augment his subset of a <a
  href="#def-reference-schema-document"><span class="termRef">reference
  schema document</span></a> or <a
  href="#def-extension-schema-document"><span class="termRef">extension
  schema document</span></a> with particular <a
  href="#def-attribute-property"><span class="termRef">attribute
  properties</span></a>, while still following the <a
  href="#def-subset-rule"><span class="termRef">subset rule</span></a>.
  <em>(See <a
  href="#41621-attribute-augmentations-in-xsd">§4.16.2.1</a>)</em></p>
  <p>The <code>xs:anyAttribute</code> elements in the <a
  href="#def-structures-namespace"><span class="termRef">structures
  namespace</span></a> are not intended to allow any attribute within
  any element in a conforming message. That is prohibited by this
  rule.</p>
  <p><a name="rule12-4"></a><strong>Rule 12-4:</strong> An element in an
  XML message MUST NOT have the attribute <code>structures:id</code> if
  it represents a property with an effective reference code of
  <code>NONE</code>.</p>
  <p>The reference code of a property or class is the value of the
  ReferenceCode property in CMF, or the
  <code>appinfo:referenceCode</code> attribute in XSD. The effective
  reference code of a property is that reference code if specified;
  otherwise the effective reference code of the property's class. The
  effective reference code of a class is its reference code if
  specified; otherwise the effective reference code of its parent class
  if one exists; otherwise <code>NONE</code>.</p>
  <p>By default, all message objects appear inline. Model designers must
  specify the object properties and classes that they want to also
  appear through an object reference. <em>(See <a
  href="#1423-objects-and-object-identifiers">§14.2.3</a>)</em></p>
  <p><a name="rule12-5"></a><strong>Rule 12-5:</strong> An element in an
  XML message MUST NOT have the attribute <code>structures:ref</code> if
  it represents a property with an effective reference code of
  <code>ANYURI</code>, <code>RELURI</code>, or <code>NONE</code> .</p>
  <p><a name="rule12-6"></a><strong>Rule 12-6:</strong> An element in an
  XML message MUST NOT have the attribute <code>structures:uri</code> if
  it represents a property with an effective reference code of
  <code>IDREF</code> or <code>NONE</code>.</p>
  <p><a name="rule12-7"></a><strong>Rule 12-7:</strong> An element in an
  XML message MUST NOT have more than one attribute that is
  <code>structures:id</code>, <code>structures:ref</code>, or
  <code>structures:uri</code>.</p>
  <p><a name="rule12-8"></a><strong>Rule 12-8:</strong> The value of an
  attribute <code>structures:ref</code> in an element representing a
  model property MUST match the value of an attribute
  <code>structures:id</code> of some element in the XML message.</p>
  <p>Although many attributes with ID and IDREF semantics are defined by
  many vocabularies, for consistency, within a NIEM XML document any
  attribute <code>structures:ref</code> must refer to an attribute
  <code>structures:id</code>, and not any other attribute.</p>
  <p><a name="rule12-9"></a><strong>Rule 12-9:</strong> Every element
  that has an attribute <code>structures:ref</code> MUST have a
  referencing element validation root that is equal to the referenced
  element validation root.</p>
  <p>The term "validation root" is defined by
  <a href="#xml-schema-structures"><b>[XML Schema Structures]</b></a>
  <em>Section 5.2, Assessing Schema-Validity</em>. It is established as
  a part of validity assessment of an XML document.</p>
  <p>NIEM supports type-safe references; that is, references using
  <code>structures:ref</code> and <code>structures:id</code> must
  preserve the type constraints that would apply if nested elements were
  used instead of a reference. For example, an element of type
  <code>nc:PersonType</code> must always refer to another element of
  type <code>nc:PersonType</code>, or a type derived from
  <code>nc:PersonType</code>, when using <code>structures:ref</code> to
  establish the relationship.</p>
  <p><a name="rule12-10"></a><strong>Rule 12-10:</strong> An element
  that is the target of a <code>structures:ref</code> object reference
  MUST have a type that is validly derived from the type of the
  referencing element.</p>
  <p>The term <em>validly derived</em> is as established by
  <a href="#xml-schema-structures"><b>[XML Schema Structures]</b></a>,
  subsection <em>Schema Component Constraint: Type Derivation OK
  (Complex)</em> within Section 3.4.6, <em>Constraints on Complex Type
  Definition Schema Components</em>.</p>
  <p>This rule requires that the type of the element pointed to by a
  structures:ref attribute must be of (or derived from) the type of the
  reference element.</p>
  <p><a name="rule12-11"></a><strong>Rule 12-11:</strong> An element
  that is the target of a <a
  href="#def-reference-attribute-property"><span class="termRef">reference
  attribute property</span></a> MUST have a type with a name that is the
  QName of the property, with the local part capitalized, and the
  trailing "Ref" replaced with "Type", or a derived type.</p>
  <p>For example, an element that is the target of
  <code>nc:metadataRef</code> must have the type
  <code>nc:MetadataType</code>, or a derived type.</p>
  <p><a name="rule12-12"></a><strong>Rule 12-12:</strong> The value of
  an attribute with or derived from <code>xs:anyURI</code> MUST satisfy
  the grammar syntax <code>&lt;URI-reference&gt;</code> as defined by
  <a href="#rfc-3986"><b>[RFC 3986]</b></a>.</p>
  <p>XML Schema validation does not always check the validity of URI
  values. Examples of valid and invalid URI attributes:</p>
  <pre><code>structures:uri="http://example.com/Person/223/" <span class="codeComment"><-- valid</span>
  structures:uri="#boogala"                       <span class="codeComment"><-- valid</span>
  structures:uri="boogala"                        <span class="codeComment"><-- invalid</span></code></pre>

  <p><a name="rule12-13"></a><strong>Rule 12-13:</strong> An element
  MUST NOT contain two instances of the same <a
  href="#def-augmentation-element"><span class="termRef">augmentation
  element</span></a>.</p>
  <p>For example, a message must not contain</p>
  <pre><code>&lt;nc:Person&gt;
  &lt;j:PersonAugmentation&gt;...
  &lt;j:PersonAugmentation&gt;...
&lt;/nc:Person&gt;</code></pre>
  <p>even though this is schema-valid. Instead, those augmentation
  properties must be consolidated into a single
  <code>j:PersonAugmentation</code> element.</p>
  <p><a name="rule12-14"></a><strong>Rule 12-14:</strong> An element
  with <code>xsi:nil="true"</code> MUST have the attribute
  <code>structures:ref</code> or <code>structures:uri</code>.</p>
  <p>The attribute <code>xsi:nil</code> can only be used to create an
  object reference. It cannot be used to omit mandatory content.</p>
  <hr />
  <h1 id="13-rules-for-json-messages">13. Rules for JSON messages</h1>
  <p><a name="rule13-1"></a><strong>Rule 13-1:</strong> A JSON message
  MUST be valid according to the grammar syntax
  <code>&lt;object&gt;</code> as defined by <a href="#rfc-8259"><b>[RFC
  8259]</b></a>.</p>
  <p>According to the JSON specification, a valid JSON text can be an
  object, array, number, string, or literal name. Only the first of
  these is allowed as a NIEM JSON message.</p>
  <p><a name="rule13-2"></a><strong>Rule 13-2:</strong> A JSON message
  MUST conform to the JSON-LD specification in
  <a href="#json-ld"><b>[JSON-LD]</b></a>.</p>
  <p><a name="rule13-3"></a><strong>Rule 13-3:</strong> A JSON message
  MUST be valid when assessed against the schema of its <a
  href="#def-message-format"><span class="termRef">message
  format</span></a>.</p>
  <p>The schema for a JSON <a
  href="#def-message-format"><span class="termRef">message
  format</span></a> is expressed in JSON Schema, and validates exactly
  those messages that conform to the <a
  href="#def-message-type"><span class="termRef">message
  type</span></a>. <em>(see <a href="#rule11-2">rule 11-2</a>.)</em></p>
  <p><a name="rule13-4"></a><strong>Rule 13-4:</strong> A JSON message
  MUST have an embedded context, remote context, or context via HTTP
  header. The context MUST map each namespace prefix in the <a
  href="#def-message-model"><span class="termRef">message
  model</span></a> to its corresponding namespace URI. The URL for a
  remote context MUST be an <a
  href="#def-absolute-uri"><span class="termRef">absolute
  URI</span></a>.</p>
  <p>Embedded context, remote context, and context via HTTP header are
  defined in <a href="#json-ld"><b>[JSON-LD]</b></a> <a
  href="https://www.w3.org/TR/json-ld11/#the-context">§3.1: The
  Context</a>.</p>
  <p>For example, the JSON message in <a href="#ex3-2">example 3-2</a>
  has a context that maps the prefixes <code>nc</code> and
  <code>msg</code> to their corresponding URIs.</p>
  <p><a name="rule13-5"></a><strong>Rule 13-5:</strong> The name in a
  name-value mapping within a JSON object MUST be a JSON-LD keyword, or
  a term that expands to the URI of a property in the <a
  href="#def-message-model"><span class="termRef">message
  model</span></a>.</p>
  <p>For example:</p>
  <pre><code>&quot;@context&quot;: {
    &quot;nc&quot;: &quot;https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/&quot;,
    &quot;pname&quot;: &quot;nc:PersonName&quot;},
  &quot;nc:Person&quot;: {   <span class="codeComment"><i>valid, expands to https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/Person</i></span>
    &quot;@id&quot;: &quot;#JD&quot;,  <span class="codeComment"><i>valid, JSON-LD keyword</i></span>
    &quot;pname&quot;: {     <span class="codeComment"><i>valid, expands to https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/PersonName</i></span>
      &quot;foo:FullName&quot;: &quot;John Doe&quot;    <span class="codeComment"><i>invalid, no mapping for "foo" prefix</i></span>
    }
  }
  </code></pre>

  <p><a name="rule13-6"></a><strong>Rule 13-6:</strong> Two JSON objects
  with the same value for the <code>@id</code> key MUST represent the
  same message object.</p>
  <p><a name="rule13-7"></a><strong>Rule 13-7:</strong> A JSON object
  representing the value of a model Property object with an effective
  reference code of <code>NONE</code> MUST NOT contain the
  <code>@id</code> key.</p>
  <p><a name="rule13-8"></a><strong>Rule 13-8:</strong> Two JSON objects
  with the same value for the <code>@id</code> key MUST represent
  message objects having the same class or common class ancestor.</p>
  <p>For example, the following NIEM JSON is valid, because
  <code>nc:Item</code> and <code>nc:Equipment</code> have the same class
  <code>nc:ItemType</code>.</p>
  <pre><code>&quot;nc:Item&quot;: {
  &quot;@id&quot;: &quot;#ITEM7&quot;,
  &quot;nc:ItemQuantity&quot;: 7
},
&quot;nc:Equipment&quot;: {
  &quot;@id&quot;: &quot;#ITEM7&quot;,
  &quot;nc:EquipmentName&quot;: &quot;Pump&quot;
}</code></pre>
  <hr />
  <h1 id="14-interpretation-of-niem-data">14. Interpretation of NIEM
  data</h1>
  <p>NIEM is a framework for developer-level specifications of data. The
  primary purpose of a NIEM-based data specification is to establish a
  common understanding among developers, so that they can write software
  that correctly handles the shared data. Much of that common
  understanding comes from the natural language documentation in a NIEM
  model. For example, consider the documentation of the
  <code>nc:PersonName</code> object property shown below:</p>
  <pre><code>&lt;ObjectProperty structures:id=&quot;nc.PersonName&quot;&gt;               | &lt;xs:element name=&quot;PersonName&quot; type=&quot;nc:PersonNameType&quot;&gt;
  &lt;Name&gt;PersonName&lt;/Name&gt;                                    |   &lt;xs:annotation&gt;
  &lt;Namespace structures:ref=&quot;nc&quot;/&gt;                           |     &lt;xs:documentation&gt;
  &lt;DocumentationText&gt;                                        |       A combination of names and/or titles
    A combination of names and/or titles                     |       by which a person is known.
    by which a person is known.                              |     &lt;/xs:documentation&gt;
  &lt;/DocumentationText&gt;                                       |   &lt;/xs:annotation&gt;
  &lt;Class structures:ref=&quot;nc.PersonNameType&quot;/&gt;                | &lt;/xs:element&gt;
&lt;/ObjectProperty&gt;                                            | </code></pre>
  <figcaption><a name="ex14-1">Example 14-1:  Natural language documentation in CMF and XSD</a></figcaption>

  <p>In addition to the definition of individual model components, the
  meaning of NIEM data is also expressed through the arrangement of
  nested objects in a message, which expresses a relationship between
  the parent and child. For example, the meaning of the two equivalent
  messages in <a href="#ex3-2">example 3-2</a> (reproduced below) is
  described in <a href="#tab14-2">table 14-2</a>.</p>
  <pre><code>&lt;msg:Request                                                  | {
 xmlns:nc=&quot;https://docs.oasis-open.org/niemopen/ns/model/niem |   &quot;@context&quot;: {
 xmlns:msg=&quot;http://example.com/ReqRes/1.0/&quot;&gt;                  |     &quot;nc&quot;: &quot;https://docs.oasis-open.org/niemopen/ns/model/niem-
  &lt;msg:RequestID&gt;RQ001&lt;/msg:RequestID&gt;                        |     &quot;msg&quot;: &quot;http://example.com/ReqRes/1.0/&quot;
  &lt;msg:RequestedItem&gt;                                         |   },
    &lt;nc:ItemName&gt;Wrench&lt;/nc:ItemName&gt;                         |   &quot;msg:Request&quot;: {
    &lt;nc:ItemQuantity&gt;10&lt;/nc:ItemQuantity&gt;                     |     &quot;msg:RequestID&quot; : &quot;RQ001&quot;,
  &lt;/msg:RequestedItem&gt;                                        |     &quot;msg:RequestedItem&quot;: {
&lt;/msg:Request&gt;                                                |       &quot;nc:ItemName&quot;: Wrench&quot;,
                                                              |       &quot;nc:ItemQuantity&quot;: 10
                                                              |      }
                                                              |   }
                                                              | }</code></pre>
  <caption>Example 3-2: Messages in XML and JSON syntax<caption>  <!-- no link or index -->

  <table>
  <thead>
  <tr>
  <th>Message data</th>
  <th>Description</th>
  <th>Meaning</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><code>&lt;msg:Request&gt;</code>
  <em>or</em></br><code>"msg:Request":{...}</code></td>
  <td>The initial property is <code>msg:Request</code>. The message
  model defines the range of this property as the
  <code>msg:RequestType</code> class.</td>
  <td>There is an object that is a request for a specified quantity of a
  named item.</td>
  </tr>
  <tr>
  <td><code>&lt;msg:RequestID&gt;</code>
  *or</br><code>"msg:RequestID":...</code></td>
  <td>The next property is <code>msg:RequestID</code>. The message model
  defines the range of this data property as the <code>xs:token</code>
  datatype.</td>
  <td>There is a RequestID relationship between the object of
  <code>msg:RequestType</code> and the literal value
  <code>RQ001</code>.</td>
  </tr>
  <tr>
  <td><code>&lt;msg:RequestedItem&gt;</code>
  <em>or</em></br><code>"msg:RequestedItem":{...}</code></td>
  <td>The next property is <code>msg:RequestedItem</code>. The message
  model defines the range of this object property as the
  <code>nc:ItemType</code> class.</td>
  <td>There is a RequestedItem relationship between the object of
  <code>msg:RequestType</code> and the object of
  <code>nc:ItemType</code>.</td>
  </tr>
  <tr>
  <td><code>&lt;nc:ItemName&gt;</code>
  <em>or</em></br><code>"nc:ItemName":...</code></td>
  <td>The next property is <code>nc:ItemName</code>. The message model
  defines the range of this data property as the
  <code>nc:TextType</code> datatype.</td>
  <td>There is an ItemName relationship between the object of
  <code>nc:ItemType</code> and the literal value
  <code>Wrench</code>.</td>
  </tr>
  <tr>
  <td><code>&lt;nc:ItemQuantity&gt;</code>
  <em>or</em></br><code>nc:ItemQuantity":...</code></td>
  <td>The next property is <code>nc:ItemQuantity</code>. The message
  model defines the range of this data property as the
  <code>nc:QuantityType</code> datatype.</td>
  <td>There is an ItemQuantity relationship between the object of
  <code>nc:ItemType</code> and the literal value <code>10</code>.</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab14-2">Table 14-2: Meaning of NIEM data</a></figcaption>

  <p>NIEM also provides an interpretive framework for model and message
  semantics that is grounded in the Resource Description Framework
  (RDF). Every component in a NIEM model and every object in a NIEM
  message corresponds to a set of RDF triples, using terms from RDFS and
  OWL. The semantics of NIEM models and messages are defined by the
  meaning of those RDF triples, offering several benefits:</p>
  <ul>
  <li><p>Cross-format equivalence: NIEM RDF defines equivalence among
  messages of different message formats. An XML message and a JSON
  message that correspond to the same RDF triples are semantically
  equivalent and can be translated between formats with no loss of
  information.</p></li>
  <li><p>Open-world semantics and explicit assertions: RDF operates
  under the open-world assumption, meaning that the absence of
  information does not imply its negation. It avoids inferring implicit
  relationships unless explicitly stated. These principles also apply to
  NIEM data.</p></li>
  <li><p>Knowledge graph representation: The RDF entailed by a NIEM
  message and its model is a knowledge graph. This representation allows
  NIEM data to be used in semantic web applications, linked data
  ecosystems, and AI-driven systems.</p></li>
  </ul>
  <p>Message designers and developers are not required to understand or
  work directly with RDF. NIEM models, messages, and conformance rules
  are explained without reference to RDF or RDF concepts. NIEM messages
  can always be processed as ordinary XML or JSON data. However, with no
  additional effort, NIEM messages and models are also available as RDF
  as well, for the benefit of those who use semantic technologies.</p>
  <h2 id="141-rdf-interpretation-of-niem-models">14.1 RDF interpretation
  of NIEM models</h2>
  <p>This subsection defines the RDF triples that are entailed by the
  components of a NIEM model. At present, these RDF triples express only
  semantics; they do not express cardinality or datatype constraints. A
  later version of this document may add RDF entailments for those
  constraints, at which point RDF may be said to be a third
  representation for NIEM models.</p>
  <h3 id="1411-model-terminology-in-cmf-xsd-and-rdf">14.1.1 Model
  terminology in CMF, XSD, and RDF</h3>
  <p>CMF, XSD, and RDF use different terms for the same kind of model
  components. The correspondence among these terms is given in <a
  href="#tab14-3">table 14-3</a> below.</p>
  <table>
  <thead>
  <tr>
  <th>CMF</th>
  <th>XSD</th>
  <th>RDF</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Class</td>
  <td>Type definition<br> (with complex content and/or attributes)</td>
  <td>rdfs:Class</td>
  </tr>
  <tr>
  <td>Datatype</td>
  <td>Type definition<br> (with simple content and no attributes)</td>
  <td>rdfs:Datatype</td>
  </tr>
  <tr>
  <td>Property</td>
  <td>Element or attribute declaration</td>
  <td>rdfs:Property</td>
  </tr>
  <tr>
  <td>ObjectProperty</td>
  <td>Element declaration</td>
  <td>owl:ObjectProperty</td>
  </tr>
  <tr>
  <td>DataProperty</td>
  <td>Element or attribute declaration</td>
  <td>owl:DataProperty (or DatatypeProperty)</td>
  </tr>
  </tbody>
  </table>
  <figcaption><a name="tab14-3">Table 14-3: Correspondence of model terminology in CMF, XSD, and RDF</a></figcaption>

  <h3 id="1412-identifiers-for-model-components">14.1.2 Identifiers for
  model components</h3>
  <p>Every component in a NIEM model has exactly one Uniform Resource
  Identifier (URI). It is formed from the component name and the URI for
  the component's namespace, according to the following algorithm:</p>
  <ul>
  <li><p>If the namespace URI ends in <code>/</code> or in
  <code>#</code>, then the component URI is formed by concatenating the
  namespace URI and the component name; for example:</p>
  <ul>
  <li>Namespace URI:
  <code>https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/</code></li>
  <li>Component name: <code>PersonType</code></li>
  <li>Component URI:
  <code>https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/PersonType</code></li>
  </ul></li>
  <li><p>Otherwise, the component URI is formed by concatenating the
  namespace URI, the character <code>/</code>, and the component name;
  for example:</p>
  <ul>
  <li>Namespace URI: <code>http://example.com/SomeNamespace</code></li>
  <li>Component name: <code>FooType</code></li>
  <li>Component URI:
  <code>http://example.com/SomeNamespace/FooType</code></li>
  </ul></li>
  <li><p>When the namespace URI is a URN, the component URI is formed by
  concatenating the namespace URI, the character <code>:</code>, and the
  component name; for example:</p>
  <ul>
  <li>Namespace URI: <code>urn:us:gov:some:thing</code></li>
  <li>Component name: <code>BarType</code></li>
  <li>Component URI: <code>urn:us:gov:some:thing:BarType</code></li>
  </ul></li>
  </ul>
  <h3 id="1413-rdf-interpretation-of-class-objects">14.1.3 RDF
  interpretation of Class objects</h3>
  <p>A Class object</p>
  <ul>
  <li>with the URI <code>$id</code> entails the following RDF:
  <code>$id rdf:type owl:Class .</code></li>
  <li>with a non-empty DocumentationText property <code>$doc</code>
  entails: <code>$id skos:definition $doc .</code></li>
  <li>with a non-empty SubClassOf property <code>$sub</code> entails:
  <code>$id owl:subClassOf $sub .</code></li>
  </ul>
  <p><a href="#ex14-4">Example 14-4</a> below shows the CMF and XSD
  representation of a Class object, plus the RDF entailed by that
  object.</p>
  <pre><code>&lt;Class structures:id=&quot;nc.WeightMeasureType&quot;&gt;
  &lt;Name&gt;WeightMeasureType&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;nc&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;DocumentationText&gt;A data type for a measure of a weight.&lt;/DocumentationText&gt;
  &lt;SubClassOf structures:ref=&quot;nc.MeasureType&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;ChildPropertyAssociation&gt;
    &lt;ObjectProperty structures:ref=&quot;nc.WeightUnitAbstract&quot; xsi:nil=&quot;true&quot;/&gt;
    &lt;MinOccursQuantity&gt;0&lt;/MinOccursQuantity&gt;
    &lt;MaxOccursQuantity&gt;unbounded&lt;/MaxOccursQuantity&gt;
  &lt;/ChildPropertyAssociation&gt;
&lt;/Class&gt;
---------------
 &lt;xs:complexType name=&quot;WeightMeasureType&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;A data type for a measure of a weight.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base=&quot;nc:MeasureType&quot;&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref=&quot;nc:WeightUnitAbstract&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
        &lt;xs:element ref=&quot;nc:WeightMeasureAugmentationPoint&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;
---------------
nc:WeightMeasureType 
  rdf:type owl:Class ;
  skos:definition &quot;A data type for a measure of a weight.&quot; ;
  owl:subClassOf nc:MeasureType .</code></pre>
  <figcaption><a name="ex14-4">Example 14-4: RDF entailed by a Class object</a></figcaption>

  <h3 id="1414-rdf-interpretation-of-dataproperty-objects">14.1.4 RDF
  interpretation of DataProperty objects</h3>
  <p>A DataProperty object</p>
  <ul>
  <li>with the URI <code>$id</code> entails the following RDF:
  <code>$id rdf:type owl:DataProperty .</code></li>
  <li>with a non-empty DocumentationText property <code>$doc</code>
  entails: <code>$id skos:definition $doc .</code></li>
  <li>with a non-empty Datatype property <code>$type</code> entails:
  <code>$id rdfs:range $type .</code></li>
  <li>with a non-empty SubPropertyOf property <code>$sub</code> entails:
  <code>$id rdfs:subPropertyOf $sub .</code></li>
  </ul>
  <p><a href="#ex14-5">Example 14-5</a> below shows the CMF and XSD
  representation of an DataProperty object, plus the RDF entailed by
  that object.</p>
  <pre><code>&lt;DataProperty structures:id=&quot;unece.MassUnitCode&quot;&gt;
  &lt;Name&gt;MassUnitCode&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;unece&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;DocumentationText&gt;A unit of measure of the weight value.&lt;/DocumentationText&gt;
  &lt;SubPropertyOf structures:ref=&quot;nc.WeightUnitAbstract&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;Datatype structures:ref=&quot;unece.MassCodeType&quot; xsi:nil=&quot;true&quot;/&gt;
&lt;/DataProperty&gt;
---------------
&lt;xs:element name=&quot;MassUnitCode&quot; type=&quot;unece:MassCodeType&quot; substitutionGroup=&quot;nc:WeightUnitAbstract&quot; nillable=&quot;true&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;A unit of measure of the weight value.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;
---------------
unece:MassUnitCode
  rdf:type owl:DatatypeProperty ;
  skos:definition &quot;A unit of measure of the weight value.&quot; ;
  rdfs:range unece:MassCodeType ;
  rdfs:subPropertyOf nc:WeightUnitAbstract .</code></pre>
  <figcaption><a name="ex14-5">Example 14-5: RDF entailed by a DataProperty object</a></figcaption>

  <h3 id="1415-rdf-interpretation-of-objectproperty-objects">14.1.5 RDF
  interpretation of ObjectProperty objects</h3>
  <p>An ObjectProperty object</p>
  <ul>
  <li>with the URI <code>$id</code> entails the following RDF:
  <code>$id rdf:type owl:ObjectProperty .</code></li>
  <li>with a non-empty DocumentationText property <code>$doc</code>
  entails: <code>$id skos:definition $doc .</code></li>
  <li>with a non-empty Class property <code>$class</code> entails:
  <code>$id rdfs:range $class .</code></li>
  <li>with a non-empty SubClassOf property <code>$sub</code> entails:
  <code>$id rdfs:subClassOf $sub .</code></li>
  </ul>
  <p><a href="#ex14-6">Example 14-6</a> below shows the CMF and XSD
  representation of an ObjectProperty object, plus the RDF entailed by
  that object.</p>
  <pre><code>&lt;ObjectProperty structures:id=&quot;nc.Location2DGeospatialCoordinate&quot;&gt;
  &lt;Name&gt;Location2DGeospatialCoordinate&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;nc&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;DocumentationText&gt;A location identified by a latitude and longitude.&lt;/DocumentationText&gt;
  &lt;SubPropertyOf structures:ref=&quot;nc.LocationGeospatialCoordinateAbstract&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;Class structures:ref=&quot;nc.Location2DGeospatialCoordinateType&quot; xsi:nil=&quot;true&quot;/&gt;
&lt;/ObjectProperty&gt;
---------------
&lt;xs:element name=&quot;Location2DGeospatialCoordinate&quot; type=&quot;nc:Location2DGeospatialCoordinateType&quot;
    substitutionGroup=&quot;nc:LocationGeospatialCoordinateAbstract&quot; nillable=&quot;true&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;A location identified by a latitude and longitude.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;
---------------
nc:Location2DGeospatialCoordinate
  rdf:type owl:ObjectProperty ;
  skos:definition &quot;A location identified by a latitude and longitude.&quot; ;
  rdfs:range nc:Location2DGeospatialCoordinateType ;
  rdfs:subPropertyOf nc:LocationGeospatialCoordinateAbstract .</code></pre>
  <figcaption><a name="ex14-6">Example 14-6: RDF entailed by an ObjectProperty object</a></figcaption>

  <h2 id="142-rdf-interpretation-of-niem-messages">14.2 RDF
  interpretation of NIEM messages</h2>
  <p>This subsection defines the RDF triples that are entailed by the
  constructs in a NIEM message. The examples show portions of equivalent
  XML and JSON messages, and of the RDF those portions entail.</p>
  <h3 id="1421-objects-properties-and-values">14.2.1 Objects,
  properties, and values</h3>
  <p>The information in a NIEM message is expressed as values of
  properties of objects.</p>
  <ul>
  <li><p>An object in NIEM XML is an element that has attributes, or
  complex content, or both. An object in NIEM JSON is a JSON object that
  is the value of a key/value pair.</p></li>
  <li><p>A property in NIEM XML is an attribute name or an element tag.
  The QName of the attribute or the element tag identifies a Property
  object in the message model; <a
  href="#1412-identifiers-for-model-components">section 14.1.2</a>
  specifies how to convert that QName to the property's URI. A property
  in NIEM JSON is the key in a key/value pair. The key is a compact IRI
  that expands to the property's URI.</p></li>
  <li><p>A value in NIEM XML can be a literal, the value of an attribute
  or the simple content of an element. A value in NIEM XML can also be
  an object, a child element with attributes and/or complex content. A
  value in NIEM JSON can be an object, or a literal; that is, a string,
  number, or boolean. (A value in NIEM JSON can also be an array of
  values for a repeatable property; see <a
  href="#1427-repeatable-properties">section 14.2.7</a>.)</p></li>
  </ul>
  <p>In the XML shown in <a href="#ex14-7">example 14-7</a> below, the
  <code>nc:PersonName</code> element is an object;
  <code>nc:PersonGivenName</code> is a property of that object;
  <code>Tom</code> is a literal value of that property. In the JSON, the
  value of the <code>nc:PersonName</code> key is an object;
  <code>nc:PersonGivenName</code> is a property of that object;
  <code>Tom</code> is a literal value of that property.</p>
  <pre><code>&lt;nc:PersonName&gt;                                           | &quot;nc:PersonName&quot;: {    
  &lt;nc:PersonGivenName&gt;Tom&lt;/nc:PersonGivenName&gt;            |   &quot;nc:PersonGivenName&quot;: &quot;Tom&quot;
&lt;/nc:PersonName&gt;                                          | }   </code></pre>
  <figcaption><a name="ex14-7">Example 14-7:  NIEM objects, properties, and values</a></figcaption>

  <h3 id="1422-messages-and-message-objects">14.2.2 Messages and message
  objects</h3>
  <p>A <a href="#def-message-type"><span class="termRef">message
  type</span></a> declares the <a
  href="#def-message-property"><span class="termRef">message
  property</span></a> for the messages of that type (<em>see <a
  href="#313">§3.1.3</a></em>). The value of the message property is
  known as the <a
  href="#def-message-object"><span class="termRef">message
  object</span></a>. The data structure of a NIEM message is a directed
  graph in which all nodes are reachable from the message object.</p>
  <p>A NIEM XML message is an XML document. The message object is the
  element with the message property tag; this is usually the document
  object.</p>
  <p>A NIEM JSON message is a JSON object with at least one
  <code>@context</code> key, plus one key that is the message property.
  The message object is the value of that key.</p>
  <p>For example, the message object in the XML message below is the
  element with the <code>msg:Request</code> tag. The message object in
  the JSON message is the value of the <code>msg:Request</code> key.</p>
  <pre><code>&lt;msg:Request                                                  | {
 xmlns:nc=&quot;https://docs.oasis-open.org/niemopen/ns/model/niem |   &quot;@context&quot;: {
 xmlns:msg=&quot;http://example.com/ReqRes/1.0/&quot;&gt;                  |     &quot;nc&quot;: &quot;https://docs.oasis-open.org/niemopen/ns/model/niem-
  &lt;msg:RequestID&gt;RQ001&lt;/msg:RequestID&gt;                        |     &quot;msg&quot;: &quot;http://example.com/ReqRes/1.0/&quot;
  &lt;msg:RequestedItem&gt;                                         |   },
    &lt;nc:ItemName&gt;Wrench&lt;/nc:ItemName&gt;                         |   &quot;msg:Request&quot;: {
    &lt;nc:ItemQuantity&gt;10&lt;/nc:ItemQuantity&gt;                     |     &quot;msg:RequestID&quot; : &quot;RQ001&quot;,
  &lt;/msg:RequestedItem&gt;                                        |     &quot;msg:RequestedItem&quot;: {
&lt;/msg:Request&gt;                                                |       &quot;nc:ItemName&quot;: &quot;Wrench&quot;,
                                                              |       &quot;nc:ItemQuantity&quot;: 10
                                                              |      }
                                                              |   }
                                                              | }</code></pre>
  <figcaption><a name="ex14-8">Example 14-8: Message objects in NIEM XML and NIEM JSON</a></figcaption>

  <h3 id="1423-objects-and-object-identifiers">14.2.3 Objects and object
  identifiers</h3>
  <p>A hierarchy of nested objects (for example, those described in <a
  href="#tab14-2">table 14-2</a> above) is sufficient to represent
  simple data that takes the form of a tree. However, this simple
  representation has limitations, and is not capable of expressing all
  relationships among objects. Situations that cause problems
  include:</p>
  <ul>
  <li><p>Cycles: some object has a relationship that, when followed,
  eventually circles back to itself. For example, suppose that Bob has a
  sister relationship to Sue, who has a brother relationship back to
  Bob. These relationships do not form a tree; they require a data
  structure that is a graph, rather than a simple hierarchy of
  objects.</p></li>
  <li><p>Reuse: multiple objects have a relationship to a common object.
  For example, suppose Bob and Sue both have a mother relationship to
  Sally. Expressed as a tree of nested objects, this would result in a
  duplicate representation of Sally.</p></li>
  </ul>
  <p>NIEM solves these problems through message object identifiers. The
  data that represents an object may include an object identifier. Data
  with the same identifier represents the same object, and is
  interpreted as if the the object in its entirety appeared at that
  point in the message. The resulting data structure is a graph, not a
  tree.</p>
  <p>This subsection describes how those identifiers become the subject
  IRIs or blank node identifiers in the RDF triples entailed by a
  message object.</p>
  <p>Most objects in a NIEM message have no identifier. These objects
  entail RDF triples with a subject that is a blank node. <a
  href="#ex14-9">Example 14-9</a> shows XML and JSON objects with no
  identifier, and the triples these objects entail.</p>
  <pre><code>&lt;nc:PersonName&gt;                                      | &quot;nc:PersonName&quot;: {                  | _:b0 rdf:type nc:PersonNameType .
  &lt;nc:PersonGivenName&gt;Tom&lt;/nc:PersonGivenName&gt;       |   &quot;nc:PersonGivenName&quot;: &quot;Tom&quot;       | _:b0 nc:PersonName _:b1 .
&lt;/nc:PersonName&gt;                                     | }                                   | </code></pre>
  <figcaption><a name="ex14-9">Example 14-9:  NIEM objects without identifiers</a></figcaption>

  <p>Some objects are identified by a <em>fragment identifier</em>. In
  the common case, where the message does not have a base URI, these
  objects also entail RDF triples with a blank node subject. In an XML
  message, <code>structures:id</code> always supplies a fragment
  identifier, as does <code>structures:uri</code> when the leading
  character is <code>#</code>. In a JSON message, a value of the
  <code>@id</code> key beginning with <code>#</code> also supplies a
  fragment identifier. By convention, the fragment identifier is used as
  the blank node identifier. <a href="#ex14-10">Example 14-10</a> shows
  XML and JSON objects with fragment identifiers, and the blank node RDF
  triples these objects entail.</p>
  <pre><code>&lt;nc:PersonName structures:id=&quot;N01&quot;&gt;                 | &quot;nc:PersonName&quot;: [                   | _:N01 rdf:type nc:PersonNameType .
  &lt;nc:PersonGivenName&gt;Tom&lt;/nc:PersonGivenName&gt;      |   { &quot;@id&quot;: &quot;#N01&quot;,                   | _:N01 nc:PersonName _:b1 .
&lt;/nc:PersonName&gt;                                    |     &quot;nc:PersonGivenName&quot;: &quot;Tom&quot;      | _:N02 rdf:type nc:PersonNameType .
&lt;nc:PersonName structures:uri=&quot;#N02&quot;&gt;               |   },                                 | _:N02 nc:PersonName _:b2 .
  &lt;nc:PersonGivenName&gt;Dick&lt;/nc:PersonGivenName&gt;     |   { &quot;@id&quot;: &quot;#N02&quot;,                   | 
&lt;/nc:PersonName&gt;                                    |     &quot;nc:PersonGivenName&quot;: &quot;Dick&quot;     | 
                                                    |   }                                  | 
                                                    | ]                                    |</code></pre>
  <figcaption><a name="ex14-10">Example 14-10:  NIEM objects with fragment identifiers</a></figcaption>

  <p>Some objects are identified by an <em>absolute URI</em>. These
  entail RDF triples with a resource subject. In XML, these identifiers
  are supplied by <code>structures:uri</code>; in JSON, by
  <code>@id</code>. <a href="#ex14-11">Example 14-11</a> shows XML and
  JSON objects identified by absolute URI, and the RDF triples these
  objects entail.</p>
  <pre><code>&lt;nc:PersonName structures:uri=&quot;http://example.com/Name7&quot;&gt;
  &lt;nc:PersonGivenName&gt;Harry&lt;/nc:PersonGivenName&gt;
&lt;/nc:PersonName&gt;
----------
&quot;nc:PersonName&quot;: {
  &quot;@id&quot;: &quot;http://example.com/Name7&quot;,
  &quot;nc:PersonGivenName&quot;: &quot;Harry&quot;
}
----------
&lt;http://example.com/Name7&gt; rdf:type nc:PersonNameType .
&lt;http://example.com/Name7&gt; nc:PersonName _:b1 .</code></pre>
  <figcaption><a name="ex14-11">Example 14-11:  NIEM objects identified by absolute URI</a></figcaption>

  <p>NIEM messages are often without expectation of permanence, existing
  only to exchange data from producer to consumers. There is typically
  no identifier for such a message as a whole. However, some messages do
  have identifiers; these are encoded in an XML message by
  <code>xml:base</code>, and in JSON by a <code>@base</code> key in the
  message context.</p>
  <p>When a NIEM message has an identifier, objects with a fragment
  identifier entail RDF triples with a resource subject instead of a
  blank node identifier. The URI for the resource is then formed from
  the fragment identifier and the message URI according to the process
  in section 5 of <a href="#rfc-3986"><b>[RFC 3986]</b></a>, treating
  the message URI as the base URI. <a href="#ex14-12">Example 14-12</a>
  shows an XML and JSON message with an identifer, and the RDF triples
  entailed by the objects therein.</p>
  <pre><code>&lt;my:Message
  xmlns:my=&quot;http://example.com/My/Namespace/&quot;
  xmlns:nc=&quot;https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/&quot;
  xml:base=&quot;http://example.com/MSG/22&quot;&gt;
  &lt;nc:PersonName structures:id=&quot;N01&quot;&gt;
    &lt;nc:PersonGivenName&gt;Tom&lt;/nc:PersonGivenName&gt;
  &lt;/nc:PersonName&gt;
  &lt;nc:PersonName structures:uri=&quot;#N02&quot;&gt;
    &lt;nc:PersonGivenName&gt;Dick&lt;/nc:PersonGivenName&gt;
  &lt;/nc:PersonName&gt;
&lt;/my:Message&gt;
----------
{ 
  &quot;@context&quot;: {
    &quot;my&quot;: &quot;http://example.com/My/Namespace/&quot;,
    &quot;nc&quot;: &quot;https://docs.oasis-open.org/niemopen/ns/model/niem-core/6.0/&quot;,
    &quot;@base&quot;: &quot;http://example.com/MSG/22&quot;
  },
  &quot;nc:PersonName&quot;: [
    { &quot;@id&quot;: &quot;#N01&quot;,
      &quot;nc:PersonGivenName&quot;: &quot;Tom&quot;
    },
    { &quot;@id&quot;: &quot;#N02&quot;,
      &quot;nc:PersonGivenName&quot;: &quot;Dick&quot;
    }
  ]
}
--------
&lt;http://example.com/MSG/22#N01&gt; nc:PersonGivenName &quot;Tom&quot; .
&lt;http://example.com/MSG/22#N02&gt; nc:PersonGivenName &quot;Dick&quot; .</code></pre>
  <figcaption><a name="ex14-12">Example 14-12: Objects with fragment identifiers and message base URI</a></figcaption>

  <h3 id="1424-object-properties-and-object-class">14.2.4 Object
  properties and object class</h3>
  <p>Every object in a NIEM message is an instance of a Class in the
  message model; specifically, the class of the <a
  href="#def-object-property"><span class="termRef">object
  property</span></a> <em>(see <a
  href="#48-objectproperty">§4.8</a>)</em>. Every object entails a RDF
  triple specifying its class via <code>rdf:type</code>. For example,
  the objects below are values of the <code>nc:PersonName</code> object
  property, and are instances of the <code>nc:PersonNameType</code>
  class, and entail the RDF triple shown.</p>
  <pre><code>&lt;nc:PersonName&gt;                                      | &quot;nc:PersonName&quot;: {                    | _:b0 rdf:type nc:PersonNameType .
  &lt;nc:PersonGivenName&gt;Tom&lt;/nc:PersonGivenName&gt;       |   &quot;nc:PersonGivenName&quot;: &quot;Tom&quot;         | 
&lt;/nc:PersonName&gt;                                     | }                                     |                                  

&lt;nc:PersonName structures:id=&quot;N01&quot;&gt;                  | &quot;nc:PersonName&quot;: {                    | _:N01 rdf:type nc:PersonNameType
  &lt;nc:PersonGivenName&gt;Dick&lt;/nc:PersonGivenName&gt;      |   &quot;@id&quot;: &quot;#N01&quot;,                      |
&lt;/nc:PersonName&gt;                                     |   &quot;nc:PersonGivenName&quot;: &quot;Dick&quot;        |

&lt;nc:PersonName                                       | &quot;nc:PersonName&quot;: {                    | &lt;http://example.com/Name7&gt;
  structures:uri=&quot;http://example.com/Name7&quot;&gt;         |   &quot;@id&quot;: &quot;http://example.com/Name7&quot;,  |     rdf:type nc:PersonNameType .
  &lt;nc:PersonGivenName&gt;Harry&lt;/nc:PersonGivenName&gt;     |   nc:PersonGivenName&quot;: &quot;Harry&quot;        |
&lt;/nc:PersonName&gt;                                     | }                                     |</code></pre>
  <figcaption><a name="ex14-13">Example 14-13:  Object property and class</a></figcaption>

  <h3 id="1425-data-properties-and-literal-values">14.2.5 Data
  properties and literal values</h3>
  <p>When the Property in the model is a DataProperty, the property
  value in the message is a literal. In <a href="#ex14-13">example
  14-13</a> above, <code>nc:PersonGivenName</code> is a data property;
  it has the Datatype <code>nc:PersonNameType</code>; its values are the
  literal strings "Tom", "Dick", and "Harry".</p>
  <p>Literal values have a type definition that is a Datatype object in
  the message model; specifically, the datatype of the <a
  href="#def-data-property"><span class="termRef">data
  property</span></a> <em>(see <a
  href="#49-dataproperty">§4.9</a>)</em>. If the datatype is not derived
  from <code>xs:string</code>, then the value in the RDF triple includes
  a specification of the XSD base type, in the form
  <code>"$value"^^$baseType</code>, where <em><span
  class="math inline"><em>v</em><em>a</em><em>l</em><em>u</em><em>e</em> * <em>i</em><em>s</em><em>t</em><em>h</em><em>e</em><em>l</em><em>i</em><em>t</em><em>e</em><em>r</em><em>a</em><em>l</em><em>a</em><em>n</em><em>d</em>*</span>baseType</em>
  is the QName of the XSD type. For example, in <a
  href="#ex14-14">example 14-14</a> below, the datatype of
  <code>nc:ItemQuantity</code> is derived from <code>xsd:decimal</code>;
  the RDF triple entailed by that property is as shown.</p>
  <pre><code>&lt;msg:RequestedItem&gt;                           | {                                  | _:b0 rdf:type msg:RequestedItemType .
  &lt;nc:ItemName&gt;Wrench&lt;/nc:ItemName&gt;           |   &quot;msg:RequestedItem&quot;: {           | _:b0 nc:ItemName &quot;Wrench&quot; .
  &lt;nc:ItemQuantity&gt;10&lt;/nc:ItemQuantity&gt;       |     &quot;nc:ItemName&quot;: &quot;Wrench&quot;,       | _:b0 nc:ItemQuantity &quot;10&quot;^^xsd:decimal .
&lt;/msg:RequestedItem&gt;                          |     &quot;nc:ItemQuantity&quot;: 10          | 
                                              |    }                               | 
                                              | }                                  | </code></pre>
  <figcaption><a name="ex14-14">Example 14-14: Data property and datatype in RDF</a></figcaption>

  <p>Language-tagged strings are represented in NIEM as an <a
  href="#def-object-property"><span class="termRef">object
  property</span></a> with a <a
  href="#def-literal-class"><span class="termRef">literal
  class</span></a>, and not as a data property, as shown in the next
  section.</p>
  <h3 id="1426-literal-class-and-language-tags">14.2.6 Literal class and
  language tags</h3>
  <p>A literal that has a language specification is represented as an
  instance of a literal class in NIEM XML and NIEM JSON. The language
  tag is specified by <code>xml:lang</code> in an XML message, and is
  specified by <code>@language</code> in a JSON message, and entails a
  language-tagged string in RDF. For example, the class of the object
  property <code>nc:CommentText</code> is <code>nc:TextType</code>,
  which is defined as follows in CMF and XSD:</p>
  <pre><code>&lt;Class structures:id=&quot;nc.TextType&quot;&gt;
  &lt;Name&gt;TextType&lt;/Name&gt;
  &lt;Namespace structures:ref=&quot;nc&quot; xsi:nil=&quot;true&quot;/&gt;
  &lt;DocumentationText&gt;A data type for a character string.&lt;/DocumentationText&gt;
  &lt;ChildPropertyAssociation&gt;
    &lt;DataProperty structures:ref=&quot;nc.TextLiteral&quot; xsi:nil=&quot;true&quot;/&gt;
    &lt;MinOccursQuantity&gt;1&lt;/MinOccursQuantity&gt;
    &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;
  &lt;/ChildPropertyAssociation&gt;
  &lt;ChildPropertyAssociation&gt;
    &lt;DataProperty structures:ref=&quot;xml.lang&quot; xsi:nil=&quot;true&quot;/&gt;
    &lt;MinOccursQuantity&gt;0&lt;/MinOccursQuantity&gt;
    &lt;MaxOccursQuantity&gt;1&lt;/MaxOccursQuantity&gt;
  &lt;/ChildPropertyAssociation&gt;
&lt;/Class&gt;
----------
  &lt;xs:complexType name=&quot;TextType&quot;&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;A data type for a character string.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:extension base=&quot;niem-xs:string&quot;&gt;
        &lt;xs:attribute ref=&quot;xml:lang&quot; use=&quot;optional&quot;/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;</code></pre>
  <figcaption><a name="ex14-15">Example 14-15: Literal class definition of a language-tagged string</a></figcaption>

  <p><a href="#ex14-16">Example 14-16</a> shows a language-tagged
  instance of <code>nc:CommentText</code> in XML and JSON, and shows the
  RDF triples entailed by this object.</p>
  <pre><code>&lt;nc:CommentText xml:lang=&quot;fr&quot;&gt;            | &quot;nc:CommentText&quot;: {                  | _:b0 rdf:type nc:TextType .
  Très bien!                              |   &quot;@value&quot;: &quot;Très bien!&quot;,            | _:b0 nc:CommentText &quot;Très bien!&quot;@fr .
&lt;/nc:CommentText&gt;                         |   &quot;@language&quot;: &quot;fr&quot;                  | 
                                          | }                                    | </code></pre>
  <figcaption><a name="ex14-16">Example 14-16: Language-tagged string in XML, JSON, and RDF</a></figcaption>

  <p><a href="#51-datatypes-and-literal-classes">Section 5.1,
  <em>Datatypes and literal classes</em></a> contains more examples of
  literal class values in XML and JSON.</p>
  <h3 id="1427-repeatable-properties">14.2.7 Repeatable properties</h3>
  <p>Class objects in the model specify the allowable cardinalities of
  their properties via a ChildPropertyAssociation object.</p>
  <p>A ChildPropertyAssociation object in the message model represents
  an association between a class and a child property of that class
  (<em>see <a href="#45-childpropertyassociation">§4.5</a>)</em>. When
  that model object has a MaxOccursQuantity greater than one, the
  property is repeatable. The values of a repeatable property are
  represented as an array in JSON (even if the property occurs only
  once). Each value entails a separate RDF triple. <a
  href="#ex14-17">Example 14-17</a> shows the values of the repeatable
  property <code>foo</code> in XML and JSON, and the RDF triples
  entailed by those values.</p>
  <pre><code>&lt;msg:Inventory&gt;                               | {                                    | _:b0 rdf:type msg:InventoryType .
  &lt;nc:Item&gt;                                   |   &quot;msg:Inventory&quot;: {                 | _:b0 nc:Item :_b1 .
    &lt;nc:ItemName&gt;Wrench&lt;/nc:ItemName&gt;         |     &quot;nc:Item&quot;: [                     | _:b0 nc:Item :_b2 .
    &lt;nc:ItemQuantity&gt;10&lt;/nc:ItemQuantity&gt;     |       {                              | _:b1 rdf:type nc:ItemType .
  &lt;/nc:Item&gt;                                  |         &quot;nc:ItemName&quot;: &quot;Wrench&quot;,     | _:b1 nc:ItemName &quot;Wrench&quot; .
  &lt;nc:Item&gt;                                   |         &quot;nc:ItemQuantity&quot;: 10        | _:b1 nc:ItemQuantity &quot;10&quot;^^xsd:decimal .
    &lt;nc:ItemName&gt;Hammer&lt;/nc:ItemName&gt;         |       },                             | _:b2 rdf:type nc:ItemType .
    &lt;nc:ItemQuantity&gt;2&lt;/nc:ItemQuantity&gt;      |       {                              | _:b2 nc:ItemName &quot;Hammer&quot; .
  &lt;/nc:Item&gt;                                  |         &quot;nc:ItemName&quot;: &quot;Hammer&quot;,     | _:b2 nc:ItemQuantity &quot;2&quot;^^xsd:decimal .
&lt;/msg:Inventory&gt;                              |         &quot;nc:ItemQuantity&quot;: 2         | 
                                              |       }                              | 
                                              |     ]                                | 
                                              |   }                                  | 
                                              | }                                    | </code></pre>
  <figcaption><a name="ex14-17">Example 14-17: Repeatable object property</a></figcaption>

  <p>Data properties that have a List datatype are also repeatable
  properties. For example, <code>nc:MeasureTextList</code> is a data
  property with a datatype that is a list of <code>xs:string</code>
  values. <a href="#ex14-18">Example 14-18</a> shows an instance of that
  property in XML and JSON, and shows the RDF triples entailed by that
  property.</p>
  <pre><code>&lt;cbrn:TotalEfficiencyCalculation&gt;
  &lt;cbrn:EnergyValueList&gt;15.0 32.2&lt;/cbrn:EnergyValueList&gt;
&lt;/cbrn:TotalEfficiencyCalculation&gt;
----------
{
  &quot;cbrn:TotalEfficiencyCalculation&quot;: {
    &quot;cbrn:EnergyValueList&quot;: [ 15.0, 32.2 ]
  }
}
----------
_:b0 rdf:type cbrn:EfficiencyCalibrationType .
_:b0 cbrn:EnergyValueList 15.0^^xsd:double .
_:b0 cbrn:EnergyValueList 32.2^^xsd:double .</code></pre>
  <figcaption><a name="ex14-18">Example 14-18: Repeatable data property with a List datatype</a></figcaption>

  <h3 id="1428-ordered-properties">14.2.8 Ordered properties</h3>
  <p>By default, the order of a repeated property in an object is not
  significant. For example, there is no meaning to the fact that
  "Wrench" appears before "Hammer" in <a href="#ex14-17">example
  14-17</a>, or that "15.0" comes before "32.2" in <a
  href="#ex14-18">example 14-18</a>.</p>
  <p>An ordered property is a repeatable property in which order is
  signficant. For example, the order of a repeated
  <code>nc:PersonMiddleName</code> property is usually significant;
  "Peter Death Bredon Wimsey" is not the same name as "Peter Bredon
  Death Wimsey". An ordered property is indicated in the model by a
  Property object in which OrderedPropertyIndicator is true. For
  example, <a href="#ex4-23">example 4-23</a> shows the CMF and XSD
  definition of a ChildPropertyAssociation object belonging to
  <code>nc:PersonNameType</code>, in which
  <code>nc:PersonMiddleName</code> is an ordered property.</p>
  <p>An ordered property is represented in JSON as a JSON object with
  the <code>@list</code> key and an array of the ordered values. In RDF,
  it is a list. <a href="#ex14-19">Example 14-19</a> below shows the
  values of an ordered property in XML and JSON, and the RDF triples
  entailed by those values.</p>
  <pre><code>&lt;nc:PersonName&gt;
  &lt;nc:PersonGivenName&gt;Peter&lt;/nc:PersonGivenName&gt;
  &lt;nc:PersonMiddleName&gt;Death&lt;/nc:PersonMiddleName&gt;
  &lt;nc:PersonMiddleName&gt;Bredon&lt;/nc:PersonMiddleName&gt;
  &lt;nc:PersonSurName&gt;Wimsey&lt;/nc:PersonSurName&gt;
&lt;/nc:PersonName&gt;
----------
{
  &quot;nc:PersonName&quot;: {
    &quot;nc:PersonGivenName&quot;: &quot;Peter&quot;,
    &quot;nc:PersonMiddleName&quot;: {
      &quot;@list&quot;: [ &quot;Death&quot;, &quot;Bredon&quot; ]
    },
    &quot;nc:PersonSurName&quot;: &quot;Wimsey&quot;
  }
}
----------
_:b0 rdf:type nc:PersonNameType .
_:b0 nc:PersonGivenName &quot;Peter&quot; .
_:b0 nc:PersonMiddleName ( &quot;Death&quot;, &quot;Bredon&quot; ) .
_:b0 nc:PersonSurName &quot;Wimsey&quot; .</code></pre>
  <figcaption><a name="ex14-19">Example 14-19: Ordered property values</a></figcaption>

  <h3 id="1429-relationship-properties">14.2.9 Relationship
  properties</h3>
  <p>NIEM uses embedded triples from <a href="#rdf-1.2"><b>[RDF
  1.2]</b></a> to represent relationship properties. <a
  href="#ex14-20">Example 14-20</a> shows the RDF entailed by the XML
  and JSON message from <a href="#ex5-11">example 5-11</a>, which
  records the secret relationship between a person object and the name
  "Superman". <a href="#fig14-21">Figure 14-21</a> depicts that RDF
  graph.</p>
  <pre><code>&lt;nc:Person&gt;                              | &quot;nc:Person&quot;: {                              | _:b1 nc:PersonName _:b2 .
  &lt;nc:PersonName my:isSecret=&quot;true&quot;&gt;     |   &quot;nc:PersonName&quot;: [                        | _:b1 nc:PersonName _:b2
    &lt;nc:PersonFullName&gt;                  |     {                                       |        {| &quot;my:isSecret&quot;: &quot;true&quot; |} .
      Superman                           |       &quot;nc:PersonFullName&quot;: &quot;Superman&quot;,      | _:b2 nc:PersonFullName &quot;Superman&quot; .
    &lt;/nc:PersonFullName&gt;                 |       &quot;@annotation&quot;: {                      | _:b3 nc:PersonFullName &quot;Clark Kent&quot; .
  &lt;/nc:PersonName&gt;                       |         &quot;my:isSecret&quot;: &quot;true&quot;               | 
  &lt;nc:PersonName&gt;                        |       }                                     | 
    &lt;nc:PersonFullName&gt;                  |     },                                      | 
      Clark Kent                         |     {                                       | 
    &lt;/nc:PersonFullName&gt;                 |       &quot;nc:PersonFullName&quot;: &quot;Clark Kent&quot;     | 
  &lt;/nc:PersonName&gt;                       |     }                                       | 
&lt;/nc:Person&gt;                             |   ]                                         | 
                                         | }                                           | </code></pre>
  <figcaption><a name="ex14-20">Example 14-20: RDF1.2 equivalent for a relationship property</a></figcaption>

  <figure>
    <img src="images/relProp.png" style="zoom: 100%;" />
  <figcaption><a name="fig14-21">Figure 14-21: RDF graph for a relationship property</a></figcaption>
  </figure>
  ```

  <h3 id="14210-reference-attributes">14.2.10 Reference attributes</h3>
  <p>Reference attributes are a means for of augmentation in XML
  messages, used to augment a datatype or literal class with an object
  property. <em>(See <a
  href="#41624-augmenting-a-literal-class-with-an-element-property-in-xsd">§4.16.2.4</a>)</em>
  A reference attribute contains a list of object references. Each
  referenced object is a value of the augmentation property. <a
  href="#ex14-22">Example 14-22</a> shows an XML message with a
  reference attribute, plus the corresponding RDF.</p>
  <pre><code>&lt;nc:Person&gt;
  &lt;nc:PersonName&gt;
    &lt;nc:PersonFullName&gt;John Doe&lt;/nc:PersonFullName&gt;
  &lt;/nc:PersonName&gt;
  &lt;j:PersonSexualOrientationCode my:privacyAssertionRef=&quot;PRIV01&quot;&gt;UNKNOWN&lt;/j:PersonSexualOrientationCode&gt;
&lt;/nc:Person&gt;
&lt;my:PrivacyAssertion structures:id=&quot;PRIV01&quot;&gt;
  &lt;nc:Date&gt;2023-08-05&lt;/nc:Date&gt;
  &lt;my:PrivacyText&gt;RESTRICTED&lt;/my:PrivacyText&gt;
&lt;/my:PrivacyAssertion&gt;  
----------
_:b0 rdf:type nc:PersonType .
_:b0 nc:PersonName _:b1 .
_:b0 j:PersonSexualOrientationCode _:b2 .
_:b1 rdf:type nc:PersonNameType .
_:b1 nc:PersonFullName &quot;John Doe&quot; .
_:b2 rdf:type j:PersonSexualOrientationCodeType .
_:b2 ndex:PersonSexualOrientationCodeLiteral &quot;UNKNOWN&quot; .
_:b2 my:PrivacyAssertion _:PRIV01 .
_:PRIV01 rdf:type my:PrivacyAssertionType .
_:PRIV01 nc:Date &quot;2023-08-05&quot; .
_:PRIV01 my:PrivacyText &quot;RESTRICTED&quot; .</code></pre>
  <figcaption><a name="ex14-22">Example 14-22: Reference attribute and RDF</a></figcaption>

  <h3 id="14211-augmentation-elements">14.2.11 Augmentation
  elements</h3>
  <p>Augmentation elements are a means for augmentation in XML messages,
  used to augment an ordinary class with an object property. <em>(See <a
  href="#41622-augmenting-one-object-class-or-association-class-with-an-element-property">§4.16.2.2</a>)</em>
  An augmentation element is a container for property values belonging
  to its parent. For example, the augmentation element
  <code>j:PersonAugmentation</code> in <a href="#ex14-23">example
  14-23</a> below contains two values belonging to the
  <code>nc:Person</code> element. Augmentation elements have no meaning
  of their own, and do not appear in JSON or RDF messages. <a
  href="#ex14-23">Example 14-23</a> shows an XML message with an
  augmentation element, plus the corresponding JSON message and the RDF
  entailed.</p>
  <pre><code>&lt;nc:Person&gt;
  &lt;nc:PersonBirthDate&gt;
    &lt;nc:Date&gt;2021-09-11&lt;/nc:Date&gt;
  &lt;/nc:PersonBirthDate&gt;
  &lt;nc:PersonName&gt;
    &lt;nc:PersonFullName&gt;John Doe&lt;/nc:PersonFullName&gt;
  &lt;/nc:PersonName&gt;
  &lt;j:PersonAugmentation&gt;
    &lt;j:PersonAdultIndicator&gt;true&lt;/j:PersonAdultIndicator&gt;
    &lt;j:PersonSightedIndicator&gt;true&lt;/j:PersonSightedIndicator&gt;
  &lt;/j:PersonAugmentation&gt;
&lt;/nc:Person&gt;
----------
&quot;nc:Person&quot;: {
  &quot;nc:PersonBirthDate&quot;: {
    &quot;nc:Date&quot;: &quot;2021-09-11&quot;
  },
  &quot;nc:PersonName&quot;: {
    &quot;nc:PersonFullName&quot;: &quot;John Doe&quot;
  },
  &quot;j:PersonAdultIndicator&quot;: true,
  &quot;j:PersonSightedIndicator&quot;: true
}
----------
_:b0 rdf:type nc:PersonType .
_:b0 nc:PersonBirthDate _:b1 .
_:b0 nc:PersonName _:b2 .
_:b0 j:PersonAdultIndicator &quot;true&quot;^^xsd:boolean .
_:b0 j:PersonSightedIndicator &quot;true&quot;^^xsd:boolean .
_:b1 rdf:type nc:DateType .
_:b1 nc:Date &quot;2021-09-11&quot; .
_:b2 rdf:type nc:PersonNameType .
_:b2 nc:PersonFullName &quot;John Doe&quot; .</code></pre>
  <figcaption><a name="ex14-23">Example 14-23: Augmentation element and RDF</a></figcaption>

  <hr />
  <h1 id="appendix-a-references">Appendix A. References</h1>
  <p>This appendix contains the normative and informative references
  that are used in this document. Any normative work cited in the body
  of the text as needed to implement the work product must be listed in
  the Normative References section below. Each reference to a separate
  document or artifact in this work must be listed here and must be
  identified as either a Normative or an Informative Reference.
  Normative references are specific (identified by date of publication
  and/or edition number or version number) and Informative references
  are either specific or non-specific.</p>
  <p>While any hyperlinks included in this appendix were valid at the
  time of publication, OASIS cannot guarantee their long-term
  validity.</p>
  <h2 id="a1-normative-references">A.1 Normative References</h2>
  <p>The following documents are referenced in such a way that some or
  all of their content constitutes requirements of this document.</p>
  <h6 id="bcp14">[BCP14]</h6>
  <p>Best Current Practice 14.
  <a class="uri" href="https://www.rfc-editor.org/refs/ref-bcp14.txt">https://www.rfc-editor.org/refs/ref-bcp14.txt</a></p>
  <h6 id="clarkns">[ClarkNS]</h6>
  <p>Clark, J. "XML Namespaces", 4 February 1999.
  <a class="uri" href="http://www.jclark.com/xml/xmlns.htm">http://www.jclark.com/xml/xmlns.htm</a>.</p>
  <h6 id="cmf">[CMF]</h6>
  <p>Common Model Format Specification, NIEM Technical Architecture
  Committee.
  <a class="uri" href="https://github.com/niemopen/common-model-format">https://github.com/niemopen/common-model-format</a>.</p>
  <h6 id="code-lists">[Code Lists]</h6>
  <p>Roberts, W. "NIEM Code Lists Specification". NIEM Technical
  Architecture Committee (NTAC), November 7, 2017.
  <a class="uri" href="https://reference.niem.gov/niem/specification/code-lists/4.0/niem-code-lists-4.0.html">https://reference.niem.gov/niem/specification/code-lists/4.0/niem-code-lists-4.0.html</a>.</p>
  <h6 id="ctas">[CTAS]</h6>
  <p>Conformance Targets Attribute Specification (CTAS) Version 3.0.
  Edited by Tom Carlson. 22 February 2023. OASIS Project Specification
  01.
  <a class="uri" href="https://docs.oasis-open.org/niemopen/ctas/v3.0/ctas-v3.0.html">https://docs.oasis-open.org/niemopen/ctas/v3.0/ctas-v3.0.html</a>.</p>
  <h6 id="iso-11179-4">[ISO 11179-4]</h6>
  <p>"ISO/IEC 11179-4 Information Technology — Metadata Registries (MDR)
  — Part 4: Formulation of Data Definitions Second Edition", 15 July
  2004.</p>
  <h6 id="iso-11179-5">[ISO 11179-5]</h6>
  <p>"ISO/IEC 11179-5:2005, Information technology — Metadata registries
  (MDR) — Part 5: Naming and identification principles".</p>
  <h6 id="json-ld">[JSON-LD]</h6>
  <p>Sporny, M., et al. "JSON-LD 1.1: A JSON-based Serialization for
  Linked Data". W3C Recommendation, 16 July 2020.
  <a class="uri" href="https://www.w3.org/TR/json-ld11/">https://www.w3.org/TR/json-ld11/</a>.</p>
  <h6 id="oed">[OED]</h6>
  <p>Oxford English Dictionary, Third Edition, Oxford University Press,
  November 2010.
  <a class="uri" href="http://dictionary.oed.com/">http://dictionary.oed.com/</a>.</p>
  <h6 id="rdf-12">[RDF 1.2]</h6>
  <p>RDF 1.2 Concepts and Abstract Syntax, W3C Working Draft, 04 July
  2025.<br />
  <a class="uri" href="https://www.w3.org/TR/rdf12-concepts/">https://www.w3.org/TR/rdf12-concepts/</a>.</p>
  <h6 id="rfc-2119">[RFC 2119]</h6>
  <p>Bradner, S., "Key words for use in RFCs to Indicate Requirement
  Levels", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.
  <a class="uri" href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>.</p>
  <h6 id="rfc-3986">[RFC 3986]</h6>
  <p>Berners-Lee, T., et al., "Uniform Resource Identifier (URI):
  Generic Syntax", Request for Comments 3986, January 2005.
  <a class="uri" href="http://tools.ietf.org/html/rfc3986">http://tools.ietf.org/html/rfc3986</a>.</p>
  <h6 id="rfc-8174">[RFC 8174]</h6>
  <p>Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC 2119 Key
  Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017,
  <a class="uri" href="http://www.rfc-editor.org/info/rfc8174">http://www.rfc-editor.org/info/rfc8174</a>.</p>
  <h6 id="rfc-8259">[RFC 8259]</h6>
  <p>Bray, T. "The JavaScript Object Notation (JSON) Data Interchange
  Format", Request for Comments 8259, December 2017.
  <a class="uri" href="https://www.rfc-editor.org/rfc/rfc8259">https://www.rfc-editor.org/rfc/rfc8259</a>.</p>
  <h6 id="semver">[SemVer]</h6>
  <p>"Semantic Versioning 2.0.0".
  <a class="uri" href="https://semver.org/">https://semver.org/</a>.</p>
  <h6 id="xml">[XML]</h6>
  <p>"Extensible Markup Language (XML) 1.0 (Fourth Edition)", W3C
  Recommendation, 16 August 2006.
  <a class="uri" href="http://www.w3.org/TR/2008/REC-xml-20081126/">http://www.w3.org/TR/2008/REC-xml-20081126/</a>.</p>
  <h6 id="xml-infoset">[XML Infoset]</h6>
  <p>Cowan, John, and Richard Tobin. "XML Information Set (Second
  Edition)", 4 February 2004.
  <a class="uri" href="http://www.w3.org/TR/2004/REC-xml-infoset-20040204/">http://www.w3.org/TR/2004/REC-xml-infoset-20040204/</a>.</p>
  <h6 id="xml-namespaces">[XML Namespaces]</h6>
  <p>"Namespaces in XML 1.0 (Third Edition)", W3C Recommendation, 8
  December 2009.
  <a class="uri" href="http://www.w3.org/TR/2009/REC-xml-names-20091208/">http://www.w3.org/TR/2009/REC-xml-names-20091208/</a></p>
  <h6 id="xml-schema-structures">[XML Schema Structures]</h6>
  <p>"XML Schema Part 1: Structures Second Edition", W3C Recommendation,
  28 October 2004.
  <a class="uri" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/">http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/</a>.</p>
  <h2 id="a2-informative-references">A.2 Informative References</h2>
  <h6 id="niem-tools">[NIEM-Tools]</h6>
  <p><a class="uri" href="https://github.com/niemopen/ntac-admin/tree/main/tools">https://github.com/niemopen/ntac-admin/tree/main/tools</a></p>
  <h6 id="webarch">[webarch]</h6>
  <p>Jacobs, I. "Architecture of the World Wide Web, Volume One". W3C
  Recommendation 15 December 2004.
  <a class="uri" href="https://www.w3.org/TR/webarch/">https://www.w3.org/TR/webarch/</a>.</p>
  <hr />
  <h1 id="appendix-b-structures-namespace">Appendix B. Structures
  namespace</h1>
  <pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;xs:schema
  targetNamespace=&quot;https://docs.oasis-open.org/niemopen/ns/model/structures/6.0/&quot;
  xmlns:structures=&quot;https://docs.oasis-open.org/niemopen/ns/model/structures/6.0/&quot;
  xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
  version=&quot;ps02&quot;
  xml:lang=&quot;en-US&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;The structures namespace provides base types and other components for definition of NIEM-conformant XML schemas.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:attributeGroup name=&quot;SimpleObjectAttributeGroup&quot;&gt;
    &lt;xs:attribute ref=&quot;structures:id&quot;/&gt;
    &lt;xs:attribute ref=&quot;structures:ref&quot;/&gt;
    &lt;xs:attribute ref=&quot;structures:uri&quot;/&gt;
    &lt;xs:anyAttribute processContents=&quot;strict&quot; namespace=&quot;##other&quot;/&gt;
  &lt;/xs:attributeGroup&gt;
  &lt;xs:complexType name=&quot;AdapterType&quot; abstract=&quot;true&quot;&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;A data type for a type that contains a single non-conformant property from an external standard for use in NIEM.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref=&quot;structures:ObjectAugmentationPoint&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute ref=&quot;structures:appliesToParent&quot;/&gt;
    &lt;xs:attribute ref=&quot;structures:id&quot;/&gt;
    &lt;xs:attribute ref=&quot;structures:ref&quot;/&gt;
    &lt;xs:attribute ref=&quot;structures:uri&quot;/&gt;
    &lt;xs:anyAttribute processContents=&quot;strict&quot; namespace=&quot;##other&quot;/&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name=&quot;AssociationType&quot; abstract=&quot;true&quot;&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;A data type for a relationship between two or more objects, including any properties of that relationship.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref=&quot;structures:AssociationAugmentationPoint&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute ref=&quot;structures:appliesToParent&quot;/&gt;
    &lt;xs:attribute ref=&quot;structures:id&quot;/&gt;
    &lt;xs:attribute ref=&quot;structures:ref&quot;/&gt;
    &lt;xs:attribute ref=&quot;structures:uri&quot;/&gt;
    &lt;xs:anyAttribute processContents=&quot;strict&quot; namespace=&quot;##other&quot;/&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name=&quot;AugmentationType&quot; abstract=&quot;true&quot;&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;A data type for a set of properties to be applied to a base type.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name=&quot;ObjectType&quot; abstract=&quot;true&quot;&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;A data type for a thing with its own lifespan that has some existence.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref=&quot;structures:ObjectAugmentationPoint&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute ref=&quot;structures:appliesToParent&quot;/&gt;
    &lt;xs:attribute ref=&quot;structures:id&quot;/&gt;
    &lt;xs:attribute ref=&quot;structures:ref&quot;/&gt;
    &lt;xs:attribute ref=&quot;structures:uri&quot;/&gt;
    &lt;xs:anyAttribute processContents=&quot;strict&quot; namespace=&quot;##other&quot;/&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:element name=&quot;AssociationAugmentationPoint&quot; abstract=&quot;true&quot;&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;An augmentation point for type structures:AssociationType.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name=&quot;ObjectAugmentationPoint&quot; abstract=&quot;true&quot;&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;An augmentation point for type structures:ObjectType.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
  &lt;/xs:element&gt;
  &lt;xs:attribute name=&quot;appliesToParent&quot; type=&quot;xs:boolean&quot; default=&quot;true&quot;&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;True if this element is a property of its parent; false if it appears only to support referencing.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
  &lt;/xs:attribute&gt;
  &lt;xs:attribute name=&quot;id&quot; type=&quot;xs:ID&quot;&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;A document-relative identifier for an XML element.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
  &lt;/xs:attribute&gt;
  &lt;xs:attribute name=&quot;ref&quot; type=&quot;xs:IDREF&quot;&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;A document-relative reference to an XML element.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
  &lt;/xs:attribute&gt;
  &lt;xs:attribute name=&quot;uri&quot; type=&quot;xs:anyURI&quot;&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;An internationalized resource identifier or uniform resource identifier for a node or object.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
  &lt;/xs:attribute&gt;
&lt;/xs:schema&gt;</code></pre>
  <hr />
  <h1 id="appendix-c-index-of-rules">Appendix C. Index of rules</h1>
  <ul>
  <li><a href="#rule7-1">Rule 7-1: Attribute and element do not have
  same uncased name</a>.</li>
  <li><a href="#rule7-2">Rule 7-2: Name of Class, Datatype, and Property
  components</a>.</li>
  <li><a href="#rule7-3">Rule 7-3: Augmentation names are
  reserved</a>.</li>
  <li><a href="#rule7-4">Rule 7-4: Name of adapter classes</a>.</li>
  <li><a href="#rule7-5">Rule 7-5: Name of association classes</a>.</li>
  <li><a href="#rule7-6">Rule 7-6: Name of code list literal
  classes</a>.</li>
  <li><a href="#rule7-7">Rule 7-7: Names ending in
  "SimpleType"</a>.</li>
  <li><a href="#rule7-8">Rule 7-8: Names ending in
  "CodeSimpleType"</a>.</li>
  <li><a href="#rule7-9">Rule 7-9: Name of code list datatypes</a>.</li>
  <li><a href="#rule7-10">Rule 7-10: Name of abstract
  properties</a>.</li>
  <li><a href="#rule7-11">Rule 7-11: Name of association
  properties</a>.</li>
  <li><a href="#rule7-12">Rule 7-12: Name of code properties</a>.</li>
  <li><a href="#rule7-13">Rule 7-13: Name of literal properties in
  CMF</a>.</li>
  <li><a href="#rule7-14">Rule 7-14: Name of representation
  attributes</a>.</li>
  <li><a href="#rule7-15">Rule 7-15: Component name composed of English
  words</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-16">Rule 7-16: Component names have only specific
  characters</a>.</li>
  <li><a href="#rule7-17">Rule 7-17: Component names use camel
  case</a>.</li>
  <li><a href="#rule7-18">Rule 7-18: Name of attribute properties begin
  with lower case letter</a>.</li>
  <li><a href="#rule7-19">Rule 7-19: Name of components other than
  attribute properties begin with upper case letter</a>.</li>
  <li><a href="#rule7-20">Rule 7-20: Punctuation in component name is a
  separator</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-21">Rule 7-21: Singular form is preferred in
  name</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-22">Rule 7-22: Present tense is preferred in
  name</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-23">Rule 7-23: Name does not have nonessential
  words</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-24">Rule 7-24: Property name follows ISO 11179-5
  pattern</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-25">Rule 7-25: Object-class term identifies
  concrete category</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-26">Rule 7-26: Property term describes
  characteristic or subpart</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-27">Rule 7-27: Name may have multiple qualifier
  terms</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-28">Rule 7-28: Name avoids unnecessary qualifier
  terms</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-29">Rule 7-29: Order of qualifiers is not
  significant</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-30">Rule 7-30: Redundant term in name is
  omitted</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-31">Rule 7-31: Data property uses representation
  term</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-32">Rule 7-32: Object property uses representation
  term when appropriate</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-33">Rule 7-33: Object property uses representation
  term only when appropriate</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-34">Rule 7-34: Names use common abbreviations</a>.
  <em>[Manual]</em></li>
  <li><a href="#rule7-35">Rule 7-35: Local terms usable within their
  namespace</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-36">Rule 7-36: Local term has literal or
  definition</a>.</li>
  <li><a href="#rule7-37">Rule 7-37: Namespace has data
  definition</a>.</li>
  <li><a href="#rule7-38">Rule 7-38: Model component has data
  definition</a>.</li>
  <li><a href="#rule7-39">Rule 7-39: Enumeration facet has data
  definition</a>.</li>
  <li><a href="#rule7-40">Rule 7-40: Pattern facet has data
  definition</a>.</li>
  <li><a href="#rule7-41">Rule 7-41: Documentation is provided in US
  English</a>.</li>
  <li><a href="#rule7-42">Rule 7-42: Data definition does not introduce
  ambiguity</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-43">Rule 7-43: Object class has only one
  meaning</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-44">Rule 7-44: Data definition of a part does not
  redefine the whole</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-45">Rule 7-45: Do not leak representation into
  data definition</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-46">Rule 7-46: Data definition follows 11179-4
  requirements</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-47">Rule 7-47: Data definition follows 11179-4
  recommendations</a>. <em>[Manual]</em></li>
  <li><a href="#rule7-48">Rule 7-48: Standard opening phrase for
  abstract property data definition</a>.</li>
  <li><a href="#rule7-49">Rule 7-49: Standard opening phrase for
  association property data definition</a>.</li>
  <li><a href="#rule7-50">Rule 7-50: Standard opening phrase for date
  property data definition</a>.</li>
  <li><a href="#rule7-51">Rule 7-51: Standard opening phrase for
  quantity property data definition</a>.</li>
  <li><a href="#rule7-52">Rule 7-52: Standard opening phrase for picture
  property data definition</a>.</li>
  <li><a href="#rule7-53">Rule 7-53: Standard opening phrase for
  indicator property data definition</a>.</li>
  <li><a href="#rule7-54">Rule 7-54: Standard opening phrase for
  identification property data definition</a>.</li>
  <li><a href="#rule7-55">Rule 7-55: Standard opening phrase for name
  property data definition</a>.</li>
  <li><a href="#rule7-56">Rule 7-56: Standard opening phrase for
  property data definition</a>.</li>
  <li><a href="#rule7-57">Rule 7-57: Standard opening phrase for
  association class data definition</a>.</li>
  <li><a href="#rule7-58">Rule 7-58: Standard opening phrase for class
  data definition</a>.</li>
  <li><a href="#rule7-59">Rule 7-59: Enumerations are unique</a>.</li>
  <li><a href="#rule8-1">Rule 8-1: Namespace identifier is absolute
  URI</a>.</li>
  <li><a href="#rule8-2">Rule 8-2: Namespace URI is owned by namespace
  authority</a>. <em>[Manual]</em></li>
  <li><a href="#rule8-3">Rule 8-3: Namespaces use slash URIs</a>.</li>
  <li><a href="#rule8-4">Rule 8-4: Namespace URI includes
  version</a>.</li>
  <li><a href="#rule8-5">Rule 8-5: Namespace URI uses semantic
  versioning</a>. <em>[Manual]</em></li>
  <li><a href="#rule8-6">Rule 8-6: Namespace has a prefix</a>.</li>
  <li><a href="#rule8-7">Rule 8-7: Namespace has version</a>.</li>
  <li><a href="#rule8-8">Rule 8-8: Namespace has language</a>.</li>
  <li><a href="#rule8-9">Rule 8-9: Reference namespace asserts
  conformance</a>.</li>
  <li><a href="#rule8-10">Rule 8-10: Reference namespace does not have
  wildcard</a>.</li>
  <li><a href="#rule8-11">Rule 8-11: Object properties in reference
  namespace are referenceable</a>.</li>
  <li><a href="#rule8-12">Rule 8-12: Reference namespace uses reference
  namespace components</a>.</li>
  <li><a href="#rule8-13">Rule 8-13: Extension namespace asserts
  conformance</a>.</li>
  <li><a href="#rule8-14">Rule 8-14: Object properties in extension
  namespace are referenceable</a>.</li>
  <li><a href="#rule8-15">Rule 8-15: Subset namespace asserts
  conformance</a>.</li>
  <li><a href="#rule8-16">Rule 8-16: Subset has corresponding reference
  or extension namespace</a>. <em>[Manual]</em></li>
  <li><a href="#rule8-17">Rule 8-17: Subset does not extend component
  range</a>. <em>[Manual]</em></li>
  <li><a href="#rule8-18">Rule 8-18: Subset does not add components</a>.
  <em>[Manual]</em></li>
  <li><a href="#rule8-19">Rule 8-19: Subset does not alter data
  definition</a>. <em>[Manual]</em></li>
  <li><a href="#rule9-1">Rule 9-1: Schema is CTAS-conformant</a>.</li>
  <li><a href="#rule9-2">Rule 9-2: Document element has attribute
  <code>ct:conformanceTargets</code></a>.</li>
  <li><a href="#rule9-3">Rule 9-3: Document is a valid schema
  document</a>.</li>
  <li><a href="#rule9-4">Rule 9-4: Document element is
  <code>xs:schema</code></a>.</li>
  <li><a href="#rule9-5">Rule 9-5: Prohibited schema
  components</a>.</li>
  <li><a href="#rule9-6">Rule 9-6: Prohibited base types</a>.</li>
  <li><a href="#rule9-7">Rule 9-7: Prohibited list item types</a>.</li>
  <li><a href="#rule9-8">Rule 9-8: Prohibited union item types</a>.</li>
  <li><a href="#rule9-9">Rule 9-9: Prohibited attribute and element
  types</a>.</li>
  <li><a href="#rule9-10">Rule 9-10: No mixed content on complex type or
  complex content</a>.</li>
  <li><a href="#rule9-11">Rule 9-11: Complex type content is explicitly
  simple or complex</a>.</li>
  <li><a href="#rule9-12">Rule 9-12: Base type of complex type with
  complex content must have complex content</a>.</li>
  <li><a href="#rule9-13">Rule 9-13: Untyped element is
  abstract</a>.</li>
  <li><a href="#rule9-14">Rule 9-14: Element type not in the XML or XML
  Schema namespace</a>.</li>
  <li><a href="#rule9-15">Rule 9-15: Element type is not simple
  type</a>.</li>
  <li><a href="#rule9-16">Rule 9-16: Attribute declaration has
  type</a>.</li>
  <li><a href="#rule9-17">Rule 9-17: No default or fixed value</a>.</li>
  <li><a href="#rule9-18">Rule 9-18: Sequence has minimum and maximum
  cardinality 1</a>.</li>
  <li><a href="#rule9-19">Rule 9-19: <code>xs:choice</code> must be
  child of <code>xs:sequence</code></a>.</li>
  <li><a href="#rule9-20">Rule 9-20: Choice has minimum and maximum
  cardinality 1</a>.</li>
  <li><a href="#rule9-21">Rule 9-21: Comment is not
  recommended</a>.</li>
  <li><a href="#rule9-22">Rule 9-22: Documentation element has no
  element children</a>.</li>
  <li><a href="#rule9-23">Rule 9-23: Import has namespace</a>.</li>
  <li><a href="#rule9-24">Rule 9-24: Import specifies local
  resource</a>.</li>
  <li><a href="#rule9-25">Rule 9-25: Name of type definitions</a>.</li>
  <li><a href="#rule9-26">Rule 9-26: Name of simple type
  definitions</a>.</li>
  <li><a href="#rule9-27">Rule 9-27: Name of complex type
  definition</a>.</li>
  <li><a href="#rule9-28">Rule 9-28: <code>xs:sequence</code> must be
  child of <code>xs:extension</code></a>.</li>
  <li><a href="#rule9-29">Rule 9-29: Type definition is
  top-level</a>.</li>
  <li><a href="#rule9-30">Rule 9-30: Complex type with complex content
  has a category</a>.</li>
  <li><a href="#rule9-31">Rule 9-31: Adapter type derived from
  <code>structures:AdapterType</code></a>.</li>
  <li><a href="#rule9-32">Rule 9-32: Association type derived from
  <code>structures:AssociationType</code></a>.</li>
  <li><a href="#rule9-33">Rule 9-33: Augmentation type derived from
  <code>structures:AugmentationType</code></a>.</li>
  <li><a href="#rule9-34">Rule 9-34: Object type derived from
  <code>structures:ObjectType</code></a>.</li>
  <li><a href="#rule9-35">Rule 9-35: Complex type with simple content
  has <code>structures:SimpleObjectAttributeGroup</code></a>.</li>
  <li><a href="#rule9-36">Rule 9-36: Base type definition defined by
  conformant schema</a>.</li>
  <li><a href="#rule9-37">Rule 9-37: Component reference defined by
  conformant schema</a>.</li>
  <li><a href="#rule9-38">Rule 9-38: Schema uses only known attribute
  groups</a>.</li>
  <li><a href="#rule9-39">Rule 9-39: List item type defined by
  conformant schemas</a>.</li>
  <li><a href="#rule9-40">Rule 9-40: Union member types defined by
  conformant schemas</a>.</li>
  <li><a href="#rule9-41">Rule 9-41: No literal properties in
  XSD</a>.</li>
  <li><a href="#rule9-42">Rule 9-42: Declarations are
  top-level</a>.</li>
  <li><a href="#rule9-43">Rule 9-43: Element type is not simple
  type</a>.</li>
  <li><a href="#rule9-44">Rule 9-44: Attribute and element type is from
  conformant namespace</a>.</li>
  <li><a href="#rule9-45">Rule 9-45: Element substitution group defined
  by conformant schema</a>.</li>
  <li><a href="#rule9-46">Rule 9-46: Attribute and element type not from
  structures namespace</a>.</li>
  <li><a href="#rule9-47">Rule 9-47: Only reference attributes have type
  <code>xs:IDREFS</code></a>.</li>
  <li><a href="#rule9-48">Rule 9-48: Import of external schema document
  is labeled</a>.</li>
  <li><a href="#rule9-49">Rule 9-49: Import of external namespace has
  data definition</a>.</li>
  <li><a href="#rule9-50">Rule 9-50: Structure of external adapter type
  definition follows pattern</a>.</li>
  <li><a href="#rule9-51">Rule 9-51: Element use from external adapter
  type defined by external schema documents</a>.</li>
  <li><a href="#rule9-52">Rule 9-52: External adapter type not a base
  type</a>.</li>
  <li><a href="#rule9-53">Rule 9-53: External attribute use has data
  definition</a>.</li>
  <li><a href="#rule9-54">Rule 9-54: External attribute use not an
  ID</a>.</li>
  <li><a href="#rule9-55">Rule 9-55: External element use has data
  definition</a>.</li>
  <li><a href="#rule9-56">Rule 9-56: Proxy types</a>.</li>
  <li><a href="#rule9-57">Rule 9-57: Proxy type has designated
  structure</a>.</li>
  <li><a href="#rule9-58">Rule 9-58: Name of augmentation
  types</a>.</li>
  <li><a href="#rule9-59">Rule 9-59: Name of augmentation
  elements</a>.</li>
  <li><a href="#rule9-60">Rule 9-60: Name of augmentation point
  elements</a>.</li>
  <li><a href="#rule9-61">Rule 9-61: Standard opening phrase for
  augmentation point element data definition</a>.</li>
  <li><a href="#rule9-62">Rule 9-62: Standard opening phrase for
  augmentation element data definition</a>.</li>
  <li><a href="#rule9-63">Rule 9-63: Standard opening phrase for
  augmentation type data definition</a>.</li>
  <li><a href="#rule9-64">Rule 9-64: Association type and object type
  are augmentable</a>.</li>
  <li><a href="#rule9-65">Rule 9-65: Augmentation point element named
  after augmented type</a>.</li>
  <li><a href="#rule9-66">Rule 9-66: Augmentation point element
  corresponds to its base type</a>.</li>
  <li><a href="#rule9-67">Rule 9-67: An augmentation point element has
  no type</a>.</li>
  <li><a href="#rule9-68">Rule 9-68: An augmentation point element has
  no substitution group</a>.</li>
  <li><a href="#rule9-69">Rule 9-69: Augmentation point element is only
  referenced by its base type</a>.</li>
  <li><a href="#rule9-70">Rule 9-70: Augmentation point element use is
  optional and unbounded</a>.</li>
  <li><a href="#rule9-71">Rule 9-71: Augmentation point element use must
  be last element in its base type</a>.</li>
  <li><a href="#rule9-72">Rule 9-72: Augmentation element named after
  augmented type</a>.</li>
  <li><a href="#rule9-73">Rule 9-73: Augmentation element type is an
  augmentation type</a>.</li>
  <li><a href="#rule9-74">Rule 9-74: Augmentation element is
  substitutable for augmentation point</a>.</li>
  <li><a href="#rule9-75">Rule 9-75: Augmentation element is
  unique</a>.</li>
  <li><a href="#rule9-76">Rule 9-76: Augmentation elements are not used
  directly</a>.</li>
  <li><a href="#rule9-77">Rule 9-77: Augmentation type has one
  augmentation element</a>.</li>
  <li><a href="#rule9-78">Rule 9-78: Augmentation type named after
  augmented type</a>.</li>
  <li><a href="#rule9-79">Rule 9-79: No wildcard in augmentation
  type</a>.</li>
  <li><a href="#rule9-80">Rule 9-80: Appinfo attribute annotates schema
  component</a>.</li>
  <li><a href="#rule9-81">Rule 9-81: <code>xs:appinfo</code> children
  are comments, elements, or whitespace</a>.</li>
  <li><a href="#rule9-82">Rule 9-82: Appinfo child elements have
  namespaces</a>.</li>
  <li><a href="#rule9-83">Rule 9-83: Appinfo descendants are not XML
  Schema elements</a>.</li>
  <li><a href="#rule9-84">Rule 9-84: Component marked as deprecated is
  deprecated component</a>.</li>
  <li><a href="#rule9-85">Rule 9-85: LocalTerm appinfo applies to
  schema</a>.</li>
  <li><a href="#rule9-86">Rule 9-86: No simple type disallowed
  derivation</a>.</li>
  <li><a href="#rule9-87">Rule 9-87: No use of "fixed" on simple type
  facets</a>.</li>
  <li><a href="#rule9-88">Rule 9-88: No disallowed
  substitutions</a>.</li>
  <li><a href="#rule9-89">Rule 9-89: No disallowed derivation</a>.</li>
  <li><a href="#rule9-90">Rule 9-90: Element declaration is
  nillable</a>.</li>
  <li><a href="#rule9-91">Rule 9-91: No <code>xs:choice</code></a>.</li>
  <li><a href="#rule9-92">Rule 9-92: No wildcards</a>.</li>
  <li><a href="#rule9-93">Rule 9-93: External attribute use only in
  adapter type</a>.</li>
  <li><a href="#rule9-94">Rule 9-94: Element declaration is
  nillable</a>.</li>
  <li><a href="#rule10-1">Rule 10-1: Namespaces are conforming or
  external</a>.</li>
  <li><a href="#rule10-2">Rule 10-2: Unique namespace prefixes</a>.</li>
  <li><a href="#rule10-3">Rule 10-3: Unique namespace
  identifiers</a>.</li>
  <li><a href="#rule10-4">Rule 10-4: Composition of schema document
  set</a>.</li>
  <li><a href="#rule10-5">Rule 10-5: Consistent import schema
  document</a>.</li>
  <li><a href="#rule10-6">Rule 10-6: Consistent import labels</a>.</li>
  <li><a href="#rule10-7">Rule 10-7: Namespace prefix is
  unique</a>.</li>
  <li><a href="#rule10-8">Rule 10-8: Schema document set must be
  complete</a>.</li>
  <li><a href="#rule10-9">Rule 10-9: Use structures namespace consistent
  with specification</a>.</li>
  <li><a href="#rule11-1">Rule 11-1: Message type declares initial
  property</a>.</li>
  <li><a href="#rule11-2">Rule 11-2: Message format schema matches
  message type</a>. <em>[Manual]</em></li>
  <li><a href="#rule12-1">Rule 12-1: Message begins with initial
  property</a>.</li>
  <li><a href="#rule12-2">Rule 12-2: Message is schema-valid</a>.</li>
  <li><a href="#rule12-3">Rule 12-3: No attributes from wildcards in
  structures</a>.</li>
  <li><a href="#rule12-4">Rule 12-4: No forbidden references</a>.</li>
  <li><a href="#rule12-5">Rule 12-5: No forbidden references</a>.</li>
  <li><a href="#rule12-6">Rule 12-6: No forbidden references</a>.</li>
  <li><a href="#rule12-7">Rule 12-7: Element has only one resource
  identifying attribute</a>.</li>
  <li><a href="#rule12-8">Rule 12-8: Attribute
  <code>structures:ref</code> must reference
  <code>structures:id</code></a>.</li>
  <li><a href="#rule12-9">Rule 12-9: Linked elements have same
  validation root</a>.</li>
  <li><a href="#rule12-10">Rule 12-10: Attribute
  <code>structures:ref</code> references element of correct
  type</a>.</li>
  <li><a href="#rule12-11">Rule 12-11: Reference attribute property
  refers to correct class</a>.</li>
  <li><a href="#rule12-12">Rule 12-12: <code>xs:anyURI</code> value must
  be valid URI</a>.</li>
  <li><a href="#rule12-13">Rule 12-13: No duplicate augmentation
  elements</a>.</li>
  <li><a href="#rule12-14">Rule 12-14: Nilled element must be an object
  reference</a>.</li>
  <li><a href="#rule13-1">Rule 13-1: Message is a JSON object</a>.</li>
  <li><a href="#rule13-2">Rule 13-2: Message is a JSON-LD
  document</a>.</li>
  <li><a href="#rule13-3">Rule 13-3: Message conforms to message
  format</a>.</li>
  <li><a href="#rule13-4">Rule 13-4: Message has context map for model
  namespaces</a>.</li>
  <li><a href="#rule13-5">Rule 13-5: Object keys are defined</a>.</li>
  <li><a href="#rule13-6">Rule 13-6: @id keyword is object
  reference</a>.</li>
  <li><a href="#rule13-7">Rule 13-7: No forbidden references</a>.</li>
  <li><a href="#rule13-8">Rule 13-8: Linked objects have compatible
  class</a>.</li>
  </ul>
  <hr />
  <h1 id="appendix-d-mapping-niem-5-rules-to-niem-6">Appendix D. Mapping
  NIEM 5 rules to NIEM 6</h1>
  <table>
  <thead>
  <tr>
  <th style="text-align: left;">NIEM 5 Rule</th>
  <th style="text-align: left;">NIEM 6 Rules</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_4-1">Rule
  4-1, Schema marked as reference schema document must conform</a></td>
  <td style="text-align: left;"><a href="#rule8-9">rule 8-9</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_4-2">Rule
  4-2, Schema marked as extension schema document must conform</a></td>
  <td style="text-align: left;"><a href="#rule8-13">rule 8-13</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_4-3">Rule
  4-3, Schema is CTAS-conformant</a></td>
  <td style="text-align: left;"><a href="#rule9-1">rule 9-1</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_4-4">Rule
  4-4, Document element has attribute ct:conformanceTargets</a></td>
  <td style="text-align: left;"><a href="#rule9-2">rule 9-2</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_4-5">Rule
  4-5, Schema claims reference schema conformance target</a></td>
  <td style="text-align: left;"><a href="#rule8-9">rule 8-9</a>, <a
  href="#rule8-15">rule 8-15</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_4-6">Rule
  4-6, Schema claims extension conformance target</a></td>
  <td style="text-align: left;"><a href="#rule8-13">rule 8-13</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_5-1">Rule
  5-1, structures:uri denotes resource identifier</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_7-1">Rule
  7-1, Document is an XML document</a></td>
  <td style="text-align: left;"><a href="#rule9-3">rule 9-3</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_7-2">Rule
  7-2, Document uses XML namespaces properly</a></td>
  <td style="text-align: left;"><a href="#rule9-3">rule 9-3</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_7-3">Rule
  7-3, Document is a schema document</a></td>
  <td style="text-align: left;"><a href="#rule9-3">rule 9-3</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_7-4">Rule
  7-4, Document element is xs:schema</a></td>
  <td style="text-align: left;"><a href="#rule9-4">rule 9-4</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_7-5">Rule
  7-5, Component name follows ISO 11179 Part 5 Annex A</a></td>
  <td style="text-align: left;"><a href="#rule7-24">rule 7-24</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-1">Rule
  9-1, No base type in the XML namespace</a></td>
  <td style="text-align: left;"><a href="#rule9-6">rule 9-6</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-2">Rule
  9-2, No base type of xs:ID</a></td>
  <td style="text-align: left;"><a href="#rule9-6">rule 9-6</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-3">Rule
  9-3, No base type of xs:IDREF</a></td>
  <td style="text-align: left;"><a href="#rule9-6">rule 9-6</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-4">Rule
  9-4, No base type of xs:IDREFS</a></td>
  <td style="text-align: left;"><a href="#rule9-6">rule 9-6</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-5">Rule
  9-5, No base type of xs:anyType</a></td>
  <td style="text-align: left;"><a href="#rule9-6">rule 9-6</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-6">Rule
  9-6, No base type of xs:anySimpleType</a></td>
  <td style="text-align: left;"><a href="#rule9-6">rule 9-6</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-7">Rule
  9-7, No base type of xs:NOTATION</a></td>
  <td style="text-align: left;"><a href="#rule9-6">rule 9-6</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-8">Rule
  9-8, No base type of xs:ENTITY</a></td>
  <td style="text-align: left;"><a href="#rule9-6">rule 9-6</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-9">Rule
  9-9, No base type of xs:ENTITIES</a></td>
  <td style="text-align: left;"><a href="#rule9-6">rule 9-6</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-10">Rule
  9-10, Simple type definition is top-level</a></td>
  <td style="text-align: left;"><a href="#rule9-29">rule 9-29</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-11">Rule
  9-11, No simple type disallowed derivation</a></td>
  <td style="text-align: left;"><a href="#rule9-86">rule 9-86</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-12">Rule
  9-12, Simple type has data definition</a></td>
  <td style="text-align: left;"><a href="#rule7-38">rule 7-38</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-13">Rule
  9-13, No use of fixed on simple type facets</a></td>
  <td style="text-align: left;"><a href="#rule9-87">rule 9-87</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-14">Rule
  9-14, Enumeration has data definition</a></td>
  <td style="text-align: left;"><a href="#rule7-39">rule 7-39</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-15">Rule
  9-15, No list item type of xs:ID</a></td>
  <td style="text-align: left;"><a href="#rule9-7">rule 9-7</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-16">Rule
  9-16, No list item type of xs:IDREF</a></td>
  <td style="text-align: left;"><a href="#rule9-7">rule 9-7</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-17">Rule
  9-17, No list item type of xs:anySimpleType</a></td>
  <td style="text-align: left;"><a href="#rule9-7">rule 9-7</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-18">Rule
  9-18, No list item type of xs:ENTITY</a></td>
  <td style="text-align: left;"><a href="#rule9-7">rule 9-7</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-19">Rule
  9-19, No union member types of xs:ID</a></td>
  <td style="text-align: left;"><a href="#rule9-8">rule 9-8</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-20">Rule
  9-20, No union member types of xs:IDREF</a></td>
  <td style="text-align: left;"><a href="#rule9-8">rule 9-8</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-21">Rule
  9-21, No union member types of xs:IDREFS</a></td>
  <td style="text-align: left;"><a href="#rule9-8">rule 9-8</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-22">Rule
  9-22, No union member types of xs:anySimpleType</a></td>
  <td style="text-align: left;"><a href="#rule9-8">rule 9-8</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-23">Rule
  9-23, No union member types of xs:ENTITY</a></td>
  <td style="text-align: left;"><a href="#rule9-8">rule 9-8</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-24">Rule
  9-24, No union member types of xs:ENTITIES</a></td>
  <td style="text-align: left;"><a href="#rule9-8">rule 9-8</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-25">Rule
  9-25, Complex type definition is top-level</a></td>
  <td style="text-align: left;"><a href="#rule9-29">rule 9-29</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-26">Rule
  9-26, Complex type has data definition</a></td>
  <td style="text-align: left;"><a href="#rule7-38">rule 7-38</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-27">Rule
  9-27, No mixed content on complex type</a></td>
  <td style="text-align: left;"><a href="#rule9-10">rule 9-10</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-28">Rule
  9-28, No mixed content on complex content</a></td>
  <td style="text-align: left;"><a href="#rule9-10">rule 9-10</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-29">Rule
  9-29, Complex type content is explicitly simple or complex</a></td>
  <td style="text-align: left;"><a href="#rule9-11">rule 9-11</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-30">Rule
  9-30, Complex content uses extension</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-31">Rule
  9-31, Base type of complex type with complex content must have complex
  content</a></td>
  <td style="text-align: left;"><a href="#rule9-12">rule 9-12</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-32">Rule
  9-32, Base type of complex type with complex content must have complex
  content</a></td>
  <td style="text-align: left;"><a href="#rule9-12">rule 9-12</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-33">Rule
  9-33, Simple content uses extension</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-34">Rule
  9-34, No complex type disallowed substitutions</a></td>
  <td style="text-align: left;"><a href="#rule9-88">rule 9-88</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-35">Rule
  9-35, No complex type disallowed derivation</a></td>
  <td style="text-align: left;"><a href="#rule9-89">rule 9-89</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-36">Rule
  9-36, Element declaration is top-level</a></td>
  <td style="text-align: left;"><a href="#rule9-42">rule 9-42</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-37">Rule
  9-37, Element declaration has data definition</a></td>
  <td style="text-align: left;"><a href="#rule7-38">rule 7-38</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-38">Rule
  9-38, Untyped element is abstract</a></td>
  <td style="text-align: left;"><a href="#rule9-13">rule 9-13</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-39">Rule
  9-39, Element of type xs:anySimpleType is abstract</a></td>
  <td style="text-align: left;"><a href="#rule9-13">rule 9-13</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-40">Rule
  9-40, Element type not in the XML Schema namespace</a></td>
  <td style="text-align: left;"><a href="#rule9-14">rule 9-14</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-41">Rule
  9-41, Element type not in the XML namespace</a></td>
  <td style="text-align: left;"><a href="#rule9-14">rule 9-14</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-42">Rule
  9-42, Element type is not simple type</a></td>
  <td style="text-align: left;"><a href="#rule9-15">rule 9-15</a>, <a
  href="#rule9-43">rule 9-43</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-43">Rule
  9-43, No element disallowed substitutions</a></td>
  <td style="text-align: left;"><a href="#rule9-88">rule 9-88</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-44">Rule
  9-44, No element disallowed derivation</a></td>
  <td style="text-align: left;"><a href="#rule9-89">rule 9-89</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-45">Rule
  9-45, No element default value</a></td>
  <td style="text-align: left;"><a href="#rule9-17">rule 9-17</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-46">Rule
  9-46, No element fixed value</a></td>
  <td style="text-align: left;"><a href="#rule9-17">rule 9-17</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-47">Rule
  9-47, Element declaration is nillable</a></td>
  <td style="text-align: left;"><a href="#rule9-90">rule 9-90</a>, <a
  href="#rule9-94">rule 9-94</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-48">Rule
  9-48, Attribute declaration is top-level</a></td>
  <td style="text-align: left;"><a href="#rule9-42">rule 9-42</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-49">Rule
  9-49, Attribute declaration has data definition</a></td>
  <td style="text-align: left;"><a href="#rule7-38">rule 7-38</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-50">Rule
  9-50, Attribute declaration has type</a></td>
  <td style="text-align: left;"><a href="#rule9-16">rule 9-16</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-51">Rule
  9-51, No attribute type of xs:ID</a></td>
  <td style="text-align: left;"><a href="#rule9-9">rule 9-9</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-52">Rule
  9-52, No attribute type of xs:IDREF</a></td>
  <td style="text-align: left;"><a href="#rule9-9">rule 9-9</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-53">Rule
  9-53, No attribute type of xs:IDREFS</a></td>
  <td style="text-align: left;"><a href="#rule9-9">rule 9-9</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-54">Rule
  9-54, No attribute type of xs:ENTITY</a></td>
  <td style="text-align: left;"><a href="#rule9-9">rule 9-9</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-55">Rule
  9-55, No attribute type of xs:ENTITIES</a></td>
  <td style="text-align: left;"><a href="#rule9-9">rule 9-9</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-56">Rule
  9-56, No attribute type of xs:anySimpleType</a></td>
  <td style="text-align: left;"><a href="#rule9-9">rule 9-9</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-57">Rule
  9-57, No attribute default values</a></td>
  <td style="text-align: left;"><a href="#rule9-17">rule 9-17</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-58">Rule
  9-58, No fixed values for optional attributes</a></td>
  <td style="text-align: left;"><a href="#rule9-17">rule 9-17</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-59">Rule
  9-59, No use of element xs:notation</a></td>
  <td style="text-align: left;"><a href="#rule9-5">rule 9-5</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-60">Rule
  9-60, Model group does not affect meaning</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-61">Rule
  9-61, No xs:all</a></td>
  <td style="text-align: left;"><a href="#rule9-5">rule 9-5</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-62">Rule
  9-62, xs:sequence must be child of xs:extension</a></td>
  <td style="text-align: left;"><a href="#rule9-28">rule 9-28</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-63">Rule
  9-63, xs:sequence must be child of xs:extension or
  xs:restriction</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-64">Rule
  9-64, No xs:choice</a></td>
  <td style="text-align: left;"><a href="#rule9-91">rule 9-91</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-65">Rule
  9-65, xs:choice must be child of xs:sequence</a></td>
  <td style="text-align: left;"><a href="#rule9-19">rule 9-19</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-66">Rule
  9-66, Sequence has minimum cardinality 1</a></td>
  <td style="text-align: left;"><a href="#rule9-18">rule 9-18</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-67">Rule
  9-67, Sequence has maximum cardinality 1</a></td>
  <td style="text-align: left;"><a href="#rule9-18">rule 9-18</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-68">Rule
  9-68, Choice has minimum cardinality 1</a></td>
  <td style="text-align: left;"><a href="#rule9-20">rule 9-20</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-69">Rule
  9-69, Choice has maximum cardinality 1</a></td>
  <td style="text-align: left;"><a href="#rule9-20">rule 9-20</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-70">Rule
  9-70, No use of xs:any</a></td>
  <td style="text-align: left;"><a href="#rule8-10">rule 8-10</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-71">Rule
  9-71, No use of xs:anyAttribute</a></td>
  <td style="text-align: left;"><a href="#rule8-10">rule 8-10</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-72">Rule
  9-72, No use of xs:unique</a></td>
  <td style="text-align: left;"><a href="#rule9-5">rule 9-5</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-73">Rule
  9-73, No use of xs:key</a></td>
  <td style="text-align: left;"><a href="#rule9-5">rule 9-5</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-74">Rule
  9-74, No use of xs:keyref</a></td>
  <td style="text-align: left;"><a href="#rule9-5">rule 9-5</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-75">Rule
  9-75, No use of xs:group</a></td>
  <td style="text-align: left;"><a href="#rule9-5">rule 9-5</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-76">Rule
  9-76, No definition of attribute groups</a></td>
  <td style="text-align: left;"><a href="#rule9-5">rule 9-5</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-77">Rule
  9-77, Comment is not recommended</a></td>
  <td style="text-align: left;"><a href="#rule9-21">rule 9-21</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-78">Rule
  9-78, Documentation element has no element children</a></td>
  <td style="text-align: left;"><a href="#rule9-22">rule 9-22</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-79">Rule
  9-79, xs:appinfo children are comments, elements, or
  whitespace</a></td>
  <td style="text-align: left;"><a href="#rule9-81">rule 9-81</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-80">Rule
  9-80, Appinfo child elements have namespaces</a></td>
  <td style="text-align: left;"><a href="#rule9-82">rule 9-82</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-81">Rule
  9-81, Appinfo descendants are not XML Schema elements</a></td>
  <td style="text-align: left;"><a href="#rule9-83">rule 9-83</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-82">Rule
  9-82, Schema has data definition</a></td>
  <td style="text-align: left;"><a href="#rule7-37">rule 7-37</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-83">Rule
  9-83, Schema document defines target namespace</a></td>
  <td style="text-align: left;"><a href="#rule8-1">rule 8-1</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-84">Rule
  9-84, Target namespace is absolute URI</a></td>
  <td style="text-align: left;"><a href="#rule8-1">rule 8-1</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-85">Rule
  9-85, Schema has version</a></td>
  <td style="text-align: left;"><a href="#rule8-7">rule 8-7</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-86">Rule
  9-86, No disallowed substitutions</a></td>
  <td style="text-align: left;"><a href="#rule9-88">rule 9-88</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-87">Rule
  9-87, No disallowed derivations</a></td>
  <td style="text-align: left;"><a href="#rule9-89">rule 9-89</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-88">Rule
  9-88, No use of xs:redefine</a></td>
  <td style="text-align: left;"><a href="#rule9-5">rule 9-5</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-89">Rule
  9-89, No use of xs:include</a></td>
  <td style="text-align: left;"><a href="#rule9-5">rule 9-5</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-90">Rule
  9-90, xs:import must have namespace</a></td>
  <td style="text-align: left;"><a href="#rule9-23">rule 9-23</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-91">Rule
  9-91, XML Schema document set must be complete</a></td>
  <td style="text-align: left;"><a href="#rule10-8">rule 10-8</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-92">Rule
  9-92, Namespace referenced by attribute type is imported</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-93">Rule
  9-93, Namespace referenced by attribute base is imported</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-94">Rule
  9-94, Namespace referenced by attribute itemType is imported</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-95">Rule
  9-95, Namespaces referenced by attribute memberTypes is
  imported</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-96">Rule
  9-96, Namespace referenced by attribute ref is imported</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_9-97">Rule
  9-97, Namespace referenced by attribute substitutionGroup is
  imported</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-1">Rule
  10-1, Complex type has a category</a></td>
  <td style="text-align: left;"><a href="#rule9-30">rule 9-30</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-2">Rule
  10-2, Object type with complex content is derived from
  structures:ObjectType</a></td>
  <td style="text-align: left;"><a href="#rule9-34">rule 9-34</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-3">Rule
  10-3, RoleOf element type is an object type</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-4">Rule
  10-4, Only object type has RoleOf element</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-5">Rule
  10-5, RoleOf elements indicate the base types of a role type</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-6">Rule
  10-6, Instance of RoleOf element indicates a role object</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-7">Rule
  10-7, Import of external namespace has data definition</a></td>
  <td style="text-align: left;"><a href="#rule9-49">rule 9-49</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-8">Rule
  10-8, External adapter type has indicator</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-9">Rule
  10-9, Structure of external adapter type definition follows
  pattern</a></td>
  <td style="text-align: left;"><a href="#rule9-50">rule 9-50</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-10">Rule
  10-10, Element use from external adapter type defined by external
  schema documents</a></td>
  <td style="text-align: left;"><a href="#rule9-51">rule 9-51</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-11">Rule
  10-11, External adapter type not a base type</a></td>
  <td style="text-align: left;"><a href="#rule9-52">rule 9-52</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-12">Rule
  10-12, External adapter type not a base type</a></td>
  <td style="text-align: left;"><a href="#rule9-52">rule 9-52</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-13">Rule
  10-13, External attribute use only in external adapter type</a></td>
  <td style="text-align: left;"><a href="#rule9-93">rule 9-93</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-14">Rule
  10-14, External attribute use has data definition</a></td>
  <td style="text-align: left;"><a href="#rule9-53">rule 9-53</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-15">Rule
  10-15, External attribute use not an ID</a></td>
  <td style="text-align: left;"><a href="#rule9-54">rule 9-54</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-16">Rule
  10-16, External element use has data definition</a></td>
  <td style="text-align: left;"><a href="#rule9-55">rule 9-55</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-17">Rule
  10-17, Name of code type ends in CodeType</a></td>
  <td style="text-align: left;"><a href="#rule7-6">rule 7-6</a>, <a
  href="#rule7-9">rule 7-9</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-18">Rule
  10-18, Code type corresponds to a code list</a></td>
  <td style="text-align: left;"><a href="#rule7-6">rule 7-6</a>, <a
  href="#rule7-9">rule 7-9</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-19">Rule
  10-19, Element of code type has code representation term</a></td>
  <td style="text-align: left;"><a href="#rule7-12">rule 7-12</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-20">Rule
  10-20, Proxy type has designated structure</a></td>
  <td style="text-align: left;"><a href="#rule9-56">rule 9-56</a>, <a
  href="#rule9-57">rule 9-57</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-21">Rule
  10-21, Association type derived from
  structures:AssociationType</a></td>
  <td style="text-align: left;"><a href="#rule7-5">rule 7-5</a>, <a
  href="#rule9-32">rule 9-32</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-22">Rule
  10-22, Association element type is an association type</a></td>
  <td style="text-align: left;"><a href="#rule7-11">rule 7-11</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-23">Rule
  10-23, Augmentable type has augmentation point element</a></td>
  <td style="text-align: left;"><a href="#rule9-64">rule 9-64</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-24">Rule
  10-24, Augmentable type has at most one augmentation point
  element</a></td>
  <td style="text-align: left;"><a href="#rule9-64">rule 9-64</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-25">Rule
  10-25, Augmentation point element corresponds to its base
  type</a></td>
  <td style="text-align: left;"><a href="#rule9-66">rule 9-66</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-26">Rule
  10-26, An augmentation point element has no type</a></td>
  <td style="text-align: left;"><a href="#rule9-67">rule 9-67</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-27">Rule
  10-27, An augmentation point element has no substitution
  group</a></td>
  <td style="text-align: left;"><a href="#rule9-68">rule 9-68</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-28">Rule
  10-28, Augmentation point element is only referenced by its base
  type</a></td>
  <td style="text-align: left;"><a href="#rule9-69">rule 9-69</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-29">Rule
  10-29, Augmentation point element use is optional</a></td>
  <td style="text-align: left;"><a href="#rule9-70">rule 9-70</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-30">Rule
  10-30, Augmentation point element use is unbounded</a></td>
  <td style="text-align: left;"><a href="#rule9-70">rule 9-70</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-31">Rule
  10-31, Augmentation point element use must be last element in its base
  type</a></td>
  <td style="text-align: left;"><a href="#rule9-71">rule 9-71</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-32">Rule
  10-32, Element within instance of augmentation type modifies
  base</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-33">Rule
  10-33, Only an augmentation type name ends in
  AugmentationType</a></td>
  <td style="text-align: left;"><a href="#rule9-58">rule 9-58</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-34">Rule
  10-34, Schema component with name ending in AugmentationType is an
  augmentation type</a></td>
  <td style="text-align: left;"><a href="#rule9-58">rule 9-58</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-35">Rule
  10-35, Type derived from structures:AugmentationType is an
  augmentation type</a></td>
  <td style="text-align: left;"><a href="#rule9-33">rule 9-33</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-36">Rule
  10-36, Augmentation element type is an augmentation type</a></td>
  <td style="text-align: left;"><a href="#rule9-59">rule 9-59</a>, <a
  href="#rule9-73">rule 9-73</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-37">Rule
  10-37, Augmentation elements are not used directly</a></td>
  <td style="text-align: left;"><a href="#rule9-76">rule 9-76</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-38">Rule
  10-38, Metadata type has data about data</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-39">Rule
  10-39, Metadata types are derived from
  structures:MetadataType</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-40">Rule
  10-40, Metadata element declaration type is a metadata type</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-41">Rule
  10-41, Metadata element has applicable elements</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-42">Rule
  10-42, Name of element that ends in Representation is
  abstract</a></td>
  <td style="text-align: left;"><a href="#rule7-10">rule 7-10</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-43">Rule
  10-43, A substitution for a representation element declaration is a
  value for a type</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-44">Rule
  10-44, Schema component name composed of English words</a></td>
  <td style="text-align: left;"><a href="#rule7-15">rule 7-15</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-45">Rule
  10-45, Schema component name has xml:lang</a></td>
  <td style="text-align: left;"><a href="#rule8-8">rule 8-8</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-46">Rule
  10-46, Schema component names have only specific characters</a></td>
  <td style="text-align: left;"><a href="#rule7-16">rule 7-16</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-47">Rule
  10-47, Punctuation in component name is a separator</a></td>
  <td style="text-align: left;"><a href="#rule7-20">rule 7-20</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-48">Rule
  10-48, Names use camel case</a></td>
  <td style="text-align: left;"><a href="#rule7-17">rule 7-17</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-49">Rule
  10-49, Attribute name begins with lower case letter</a></td>
  <td style="text-align: left;"><a href="#rule7-18">rule 7-18</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-50">Rule
  10-50, Name of schema component other than attribute and proxy type
  begins with upper case letter</a></td>
  <td style="text-align: left;"><a href="#rule7-19">rule 7-19</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-51">Rule
  10-51, Names use common abbreviations</a></td>
  <td style="text-align: left;"><a href="#rule7-34">rule 7-34</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-52">Rule
  10-52, Local term declaration is local to its schema document</a></td>
  <td style="text-align: left;"><a href="#rule7-35">rule 7-35</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-53">Rule
  10-53, Local terminology interpretation</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-54">Rule
  10-54, Singular form is preferred in name</a></td>
  <td style="text-align: left;"><a href="#rule7-21">rule 7-21</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-55">Rule
  10-55, Present tense is preferred in name</a></td>
  <td style="text-align: left;"><a href="#rule7-22">rule 7-22</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-56">Rule
  10-56, Name does not have nonessential words</a></td>
  <td style="text-align: left;"><a href="#rule7-23">rule 7-23</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-57">Rule
  10-57, Element or attribute name follows pattern</a></td>
  <td style="text-align: left;"><a href="#rule7-24">rule 7-24</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-58">Rule
  10-58, Object-class term identifies concrete category</a></td>
  <td style="text-align: left;"><a href="#rule7-25">rule 7-25</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-59">Rule
  10-59, Property term describes characteristic or subpart</a></td>
  <td style="text-align: left;"><a href="#rule7-26">rule 7-26</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-60">Rule
  10-60, Name may have multiple qualifier terms</a></td>
  <td style="text-align: left;"><a href="#rule7-27">rule 7-27</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-61">Rule
  10-61, Name has minimum necessary number of qualifier terms</a></td>
  <td style="text-align: left;"><a href="#rule7-28">rule 7-28</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-62">Rule
  10-62, Order of qualifiers is not significant</a></td>
  <td style="text-align: left;"><a href="#rule7-29">rule 7-29</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-63">Rule
  10-63, Redundant term in name is omitted</a></td>
  <td style="text-align: left;"><a href="#rule7-30">rule 7-30</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-64">Rule
  10-64, Element with simple content has representation term</a></td>
  <td style="text-align: left;"><a href="#rule7-31">rule 7-31</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-65">Rule
  10-65, Element with complex content has representation term when
  appropriate</a></td>
  <td style="text-align: left;"><a href="#rule7-32">rule 7-32</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-66">Rule
  10-66, Element with complex content has representation term only when
  appropriate</a></td>
  <td style="text-align: left;"><a href="#rule7-33">rule 7-33</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-67">Rule
  10-67, Machine-readable annotations are valid</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-68">Rule
  10-68, Component marked as deprecated is deprecated component</a></td>
  <td style="text-align: left;"><a href="#rule9-84">rule 9-84</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-69">Rule
  10-69, Deprecated annotates schema component</a></td>
  <td style="text-align: left;"><a href="#rule9-80">rule 9-80</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-70">Rule
  10-70, External import indicator annotates import</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-71">Rule
  10-71, External adapter type indicator annotates complex type</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-72">Rule
  10-72, appinfo:appliesToTypes annotates metadata element</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-73">Rule
  10-73, appinfo:appliesToTypes references types</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-74">Rule
  10-74, appinfo:appliesToElements annotates metadata element</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-75">Rule
  10-75, appinfo:appliesToElements references elements</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-76">Rule
  10-76, appinfo:LocalTerm annotates schema</a></td>
  <td style="text-align: left;"><a href="#rule9-85">rule 9-85</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-77">Rule
  10-77, appinfo:LocalTerm has literal or definition</a></td>
  <td style="text-align: left;"><a href="#rule7-36">rule 7-36</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_10-78">Rule
  10-78, Use structures consistent with specification</a></td>
  <td style="text-align: left;"><a href="#rule10-9">rule 10-9</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-1">Rule
  11-1, Name of type ends in Type</a></td>
  <td style="text-align: left;"><a href="#rule7-2">rule 7-2</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-2">Rule
  11-2, Only types have name ending in Type or SimpleType</a></td>
  <td style="text-align: left;"><a href="#rule7-2">rule 7-2</a>, <a
  href="#rule9-25">rule 9-25</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-3">Rule
  11-3, Base type definition defined by conformant schema</a></td>
  <td style="text-align: left;"><a href="#rule9-36">rule 9-36</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-4">Rule
  11-4, Name of simple type ends in SimpleType</a></td>
  <td style="text-align: left;"><a href="#rule9-26">rule 9-26</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-5">Rule
  11-5, Use lists only when data is uniform</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-6">Rule
  11-6, List item type defined by conformant schemas</a></td>
  <td style="text-align: left;"><a href="#rule9-39">rule 9-39</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-7">Rule
  11-7, Union member types defined by conformant schemas</a></td>
  <td style="text-align: left;"><a href="#rule9-40">rule 9-40</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-8">Rule
  11-8, Name of a code simple type ends in CodeSimpleType</a></td>
  <td style="text-align: left;"><a href="#rule7-8">rule 7-8</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-9">Rule
  11-9, Code simple type corresponds to a code list</a></td>
  <td style="text-align: left;"><a href="#rule7-8">rule 7-8</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-10">Rule
  11-10, Attribute of code simple type has code representation
  term</a></td>
  <td style="text-align: left;"><a href="#rule7-12">rule 7-12</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-11">Rule
  11-11, Complex type with simple content has
  structures:SimpleObjectAttributeGroup</a></td>
  <td style="text-align: left;"><a href="#rule9-35">rule 9-35</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-12">Rule
  11-12, Element type does not have a simple type name</a></td>
  <td style="text-align: left;"><a href="#rule9-43">rule 9-43</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-13">Rule
  11-13, Element type is from conformant namespace</a></td>
  <td style="text-align: left;"><a href="#rule9-44">rule 9-44</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-14">Rule
  11-14, Name of element that ends in Abstract is abstract</a></td>
  <td style="text-align: left;"><a href="#rule7-10">rule 7-10</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-15">Rule
  11-15, Name of element declaration with simple content has
  representation term</a></td>
  <td style="text-align: left;"><a href="#rule7-31">rule 7-31</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-16">Rule
  11-16, Name of element declaration with simple content has
  representation term</a></td>
  <td style="text-align: left;"><a href="#rule7-31">rule 7-31</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-17">Rule
  11-17, Element substitution group defined by conformant
  schema</a></td>
  <td style="text-align: left;"><a href="#rule9-45">rule 9-45</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-18">Rule
  11-18, Attribute type defined by conformant schema</a></td>
  <td style="text-align: left;"><a href="#rule9-44">rule 9-44</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-19">Rule
  11-19, Attribute name uses representation term</a></td>
  <td style="text-align: left;"><a href="#rule7-31">rule 7-31</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-20">Rule
  11-20, Element or attribute declaration introduced only once into a
  type</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-21">Rule
  11-21, Element reference defined by conformant schema</a></td>
  <td style="text-align: left;"><a href="#rule9-37">rule 9-37</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-22">Rule
  11-22, Referenced attribute defined by conformant schemas</a></td>
  <td style="text-align: left;"><a href="#rule9-37">rule 9-37</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-23">Rule
  11-23, Schema uses only known attribute groups</a></td>
  <td style="text-align: left;"><a href="#rule9-38">rule 9-38</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-24">Rule
  11-24, Data definition does not introduce ambiguity</a></td>
  <td style="text-align: left;"><a href="#rule7-42">rule 7-42</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-25">Rule
  11-25, Object class has only one meaning</a></td>
  <td style="text-align: left;"><a href="#rule7-43">rule 7-43</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-26">Rule
  11-26, Data definition of a part does not redefine the whole</a></td>
  <td style="text-align: left;"><a href="#rule7-44">rule 7-44</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-27">Rule
  11-27, Do not leak representation into data definition</a></td>
  <td style="text-align: left;"><a href="#rule7-45">rule 7-45</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-28">Rule
  11-28, Data definition follows 11179-4 requirements</a></td>
  <td style="text-align: left;"><a href="#rule7-46">rule 7-46</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-29">Rule
  11-29, Data definition follows 11179-4 recommendations</a></td>
  <td style="text-align: left;"><a href="#rule7-47">rule 7-47</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-30">Rule
  11-30, xs:documentation has xml:lang</a></td>
  <td style="text-align: left;"><a href="#rule8-8">rule 8-8</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-31">Rule
  11-31, Standard opening phrase for augmentation point element data
  definition</a></td>
  <td style="text-align: left;"><a href="#rule9-61">rule 9-61</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-32">Rule
  11-32, Standard opening phrase for augmentation element data
  definition</a></td>
  <td style="text-align: left;"><a href="#rule9-62">rule 9-62</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-33">Rule
  11-33, Standard opening phrase for metadata element data
  definition</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-34">Rule
  11-34, Standard opening phrase for association element data
  definition</a></td>
  <td style="text-align: left;"><a href="#rule7-49">rule 7-49</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-35">Rule
  11-35, Standard opening phrase for abstract element data
  definition</a></td>
  <td style="text-align: left;"><a href="#rule7-48">rule 7-48</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-36">Rule
  11-36, Standard opening phrase for date element or attribute data
  definition</a></td>
  <td style="text-align: left;"><a href="#rule7-50">rule 7-50</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-37">Rule
  11-37, Standard opening phrase for quantity element or attribute data
  definition</a></td>
  <td style="text-align: left;"><a href="#rule7-51">rule 7-51</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-38">Rule
  11-38, Standard opening phrase for picture element or attribute data
  definition</a></td>
  <td style="text-align: left;"><a href="#rule7-52">rule 7-52</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-39">Rule
  11-39, Standard opening phrase for indicator element or attribute data
  definition</a></td>
  <td style="text-align: left;"><a href="#rule7-53">rule 7-53</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-40">Rule
  11-40, Standard opening phrase for identification element or attribute
  data definition</a></td>
  <td style="text-align: left;"><a href="#rule7-54">rule 7-54</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-41">Rule
  11-41, Standard opening phrase for name element or attribute data
  definition</a></td>
  <td style="text-align: left;"><a href="#rule7-55">rule 7-55</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-42">Rule
  11-42, Standard opening phrase for element or attribute data
  definition</a></td>
  <td style="text-align: left;"><a href="#rule7-56">rule 7-56</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-43">Rule
  11-43, Standard opening phrase for association type data
  definition</a></td>
  <td style="text-align: left;"><a href="#rule7-57">rule 7-57</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-44">Rule
  11-44, Standard opening phrase for augmentation type data
  definition</a></td>
  <td style="text-align: left;"><a href="#rule9-63">rule 9-63</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-45">Rule
  11-45, Standard opening phrase for metadata type data
  definition</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-46">Rule
  11-46, Standard opening phrase for complex type data
  definition</a></td>
  <td style="text-align: left;"><a href="#rule7-58">rule 7-58</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-47">Rule
  11-47, Standard opening phrase for simple type data
  definition</a></td>
  <td style="text-align: left;"><a href="#rule7-58">rule 7-58</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-48">Rule
  11-48, Same namespace means same components</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-49">Rule
  11-49, Different version means different view</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-50">Rule
  11-50, Reference schema document imports reference schema
  document</a></td>
  <td style="text-align: left;"><a href="#rule8-12">rule 8-12</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-51">Rule
  11-51, Extension schema document imports reference or extension schema
  document</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-52">Rule
  11-52, Structures imported as conformant</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-53">Rule
  11-53, XML namespace imported as conformant</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-54">Rule
  11-54, Each namespace may have only a single root schema in a schema
  set</a></td>
  <td style="text-align: left;"><a href="#rule10-5">rule 10-5</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_11-55">Rule
  11-55, Consistently marked namespace imports</a></td>
  <td style="text-align: left;"><a href="#rule10-6">rule 10-6</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-1">Rule
  12-1, Instance must be schema-valid</a></td>
  <td style="text-align: left;"><a href="#rule12-2">rule 12-2</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-2">Rule
  12-2, Empty content has no meaning</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-3">Rule
  12-3, Element has only one resource identifying attribute</a></td>
  <td style="text-align: left;"><a href="#rule12-7">rule 12-7</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-4">Rule
  12-4, Attribute structures:ref must reference structures:id</a></td>
  <td style="text-align: left;"><a href="#rule12-8">rule 12-8</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-5">Rule
  12-5, Linked elements have same validation root</a></td>
  <td style="text-align: left;"><a href="#rule12-9">rule 12-9</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-6">Rule
  12-6, Attribute structures:ref references element of correct
  type</a></td>
  <td style="text-align: left;"><a href="#rule12-10">rule 12-10</a></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-7">Rule
  12-7, structures:uri denotes resource identifier</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-8">Rule
  12-8, structures:id and structures:ref denote resource
  identifier</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-9">Rule
  12-9, Nested elements and references have the same meaning.</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-10">Rule
  12-10, Order of properties is expressed via
  structures:sequenceID</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-11">Rule
  12-11, Metadata applies to referring entity</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-12">Rule
  12-12, Referent of structures:relationshipMetadata annotates
  relationship</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-13">Rule
  12-13, Values of structures:metadata refer to values of
  structures:id</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-14">Rule
  12-14, Values of structures:relationshipMetadata refer to values of
  structures:id</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-15">Rule
  12-15, structures:metadata and structures:relationshipMetadata refer
  to metadata elements</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-16">Rule
  12-16, Attribute structures:metadata references metadata
  element</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-17">Rule
  12-17, Attribute structures:relationshipMetadata references metadata
  element</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  <tr>
  <td style="text-align: left;"><a
  href="https://reference.niem.gov/niem/specification/naming-and-design-rules/5.0/niem-ndr-5.0.html#rule_12-18">Rule
  12-18, Metadata is applicable to element</a></td>
  <td style="text-align: left;"><em>no matching NIEM6 rule</em></td>
  </tr>
  </tbody>
  </table>
  <hr />
  <h1 id="appendix-e-table-of-examples">Appendix E. Table of
  examples</h1>
  <ul>
  <li><a href="#ex3-2">Example 3-2: Messages in XML and JSON
  syntax</a></li>
  <li><a href="#ex3-3">Example 3-3: Example message format
  schemas</a></li>
  <li><a href="#ex3-4">Example 3-4: Example message model in XSD and
  CMF</a></li>
  <li><a href="#ex3-5">Example 3-5: Message specifications, types, and
  formats</a></li>
  <li><a href="#ex3-9">Example 3-9: CMF model in XML and JSON
  syntax</a></li>
  <li><a href="#ex3-10">Example 3-10: RDF triples from a NIEM model and
  message</a></li>
  <li><a href="#ex4-8">Example 4-8: Namespace object in CMF and
  XSD</a></li>
  <li><a href="#ex4-12">Example 4-12: Component object (abstract) in CMF
  and XSD</a></li>
  <li><a href="#ex4-17">Example 4-17: Instance of a class in XML and
  JSON</a></li>
  <li><a href="#ex4-18">Example 4-18: A Class object in CMF and XSD (CCC
  type)</a></li>
  <li><a href="#ex4-20">Example 4-20: Instance of a literal class in XML
  and JSON</a></li>
  <li><a href="#ex4-21">Example 4-21: A literal class object in CMF and
  XSD (CSC type)</a></li>
  <li><a href="#ex4-23">Example 4-23: ChildPropertyAssociation object in
  CMF and XSD</a></li>
  <li><a href="#ex4-25">Example 4-25: AnyPropertyAssociation objects in
  CMF and XSD</a></li>
  <li><a href="#ex4-30">Example 4-30: ObjectProperty object in CMF and
  XSD</a></li>
  <li><a href="#ex4-33">Example 4-33: DataProperty object in CMF and
  XSD</a></li>
  <li><a href="#ex4-36">Example 4-36: Plain CMF datatype object for
  <code>xs:string</code></a></li>
  <li><a href="#ex4-38">Example 4-38: List object in CMF and
  XSD</a></li>
  <li><a href="#ex4-41">Example 4-41: Union object in CMF and
  XSD</a></li>
  <li><a href="#ex4-44">Example 4-44: Restriction object in CMF and
  XSD</a></li>
  <li><a href="#ex4-47">Example 4-47: Facet object in CMF and
  XSD</a></li>
  <li><a href="#ex4-50">Example 4-50: CodeListBinding object in CMF and
  XSD</a></li>
  <li><a href="#ex4-54">Example 4-54: Augmenting a single class in
  CMF</a></li>
  <li><a href="#ex4-55">Example 4-55: Global augmentation in
  CMF</a></li>
  <li><a href="#ex4-58">Example 4-58: Attribute augmentation in XSD and
  CMF model representations</a></li>
  <li><a href="#ex4-59">Example 4-59: Attribute augmentations in XML and
  JSON messages</a></li>
  <li><a href="#ex4-60">Example 4-60: Mandatory global attribute
  augmentation in XSD model representation</a></li>
  <li><a href="#ex4-61">Example 4-61: Complex type with complex content
  (CCC type) defining an object class in an XSD model
  representation</a></li>
  <li><a href="#ex4-62">Example 4-62: An augmentation point element
  declaration</a></li>
  <li><a href="#ex4-63">Example 4-63: Augmenting a class with an
  augmentation type and element in XSD</a></li>
  <li><a href="#ex4-64">Example 4-64: Element augmentation in XML and
  JSON messages</a></li>
  <li><a href="#ex4-65">Example 4-65: Augmenting a class with an element
  property in XSD</a></li>
  <li><a href="#ex4-66">Example 4-66: Augmentation with an element
  property in XML</a></li>
  <li><a href="#ex4-67">Example 4-67: Augmenting every object class with
  an element property in XSD</a></li>
  <li><a href="#ex4-68">Example 4-68: Global augmentation with an
  element property in XML</a></li>
  <li><a href="#ex4-69">Example 4-69: Augmenting a literal class with an
  element property</a></li>
  <li><a href="#ex4-70">Example 4-70: Reference attribute augmentation
  in XML and JSON</a></li>
  <li><a href="#ex4-71">Example 4-71: Augmenting every literal class
  with an element property</a></li>
  <li><a href="#ex4-73">Example 4-73: Example LocalTerm objects in CMF
  and XSD</a></li>
  <li><a href="#ex5-1">Example 5-1: A literal class in CMF and
  XSD</a></li>
  <li><a href="#ex5-2">Example 5-2: Objects of a literal class in an XML
  and JSON message</a></li>
  <li><a href="#ex5-3">Example 5-3: A restriction datatype in a CMF and
  XSD model subset</a></li>
  <li><a href="#ex5-4">Example 5-4: A data property in an XML and JSON
  message</a></li>
  <li><a href="#ex5-5">Example 5-5: A datatype in CMF and XSD</a></li>
  <li><a href="#ex5-6">Example 5-6: A data property in an XML and JSON
  message</a></li>
  <li><a href="#ex5-7">Example 5-7: A literal class in a CMF and XSD
  model subset</a></li>
  <li><a href="#ex5-8">Example 5-8: An object property with a code list
  class in an XML and JSON message</a></li>
  <li><a href="#ex5-9">Example 5-9: Metadata properties used in a
  designer's own class</a></li>
  <li><a href="#ex5-10">Example 5-10: Metadata object property
  augmenting a reused class</a></li>
  <li><a href="#ex5-11">Example 5-11: Example of an ordinary
  property</a></li>
  <li><a href="#ex5-12">Example 5-12: Example of a relationship
  property</a></li>
  <li><a href="#ex5-13">Example 5-13: Relationship property in CMF and
  XSD</a></li>
  <li><a href="#ex5-14">Example 5-14: Roles and object
  identifiers</a></li>
  <li><a href="#ex5-15">Example 5-15: The DateRepresentation pattern in
  CMF and XSD</a></li>
  <li><a href="#ex6-1">Example 6-1: Conformance target assertion in
  XSD</a></li>
  <li><a href="#ex6-2">Example 6-2: Conformance target assertion in
  CMF</a></li>
  <li><a href="#ex14-1">Example 14-1: Natural language documentation in
  CMF and XSD</a></li>
  <li><a href="#ex14-4">Example 14-4: RDF entailed by a Class
  object</a></li>
  <li><a href="#ex14-5">Example 14-5: RDF entailed by a DataProperty
  object</a></li>
  <li><a href="#ex14-6">Example 14-6: RDF entailed by an ObjectProperty
  object</a></li>
  <li><a href="#ex14-7">Example 14-7: NIEM objects, properties, and
  values</a></li>
  <li><a href="#ex14-8">Example 14-8: Message objects in NIEM XML and
  NIEM JSON</a></li>
  <li><a href="#ex14-9">Example 14-9: NIEM objects without
  identifiers</a></li>
  <li><a href="#ex14-10">Example 14-10: NIEM objects with fragment
  identifiers</a></li>
  <li><a href="#ex14-11">Example 14-11: NIEM objects identified by
  absolute URI</a></li>
  <li><a href="#ex14-12">Example 14-12: Objects with fragment
  identifiers and message base URI</a></li>
  <li><a href="#ex14-13">Example 14-13: Object property and
  class</a></li>
  <li><a href="#ex14-14">Example 14-14: Data property and datatype in
  RDF</a></li>
  <li><a href="#ex14-15">Example 14-15: Literal class definition of a
  language-tagged string</a></li>
  <li><a href="#ex14-16">Example 14-16: Language-tagged string in XML,
  JSON, and RDF</a></li>
  <li><a href="#ex14-17">Example 14-17: Repeatable object
  property</a></li>
  <li><a href="#ex14-18">Example 14-18: Repeatable data property with a
  List datatype</a></li>
  <li><a href="#ex14-19">Example 14-19: Ordered property values</a></li>
  <li><a href="#ex14-20">Example 14-20: RDF1.2 equivalent for a
  relationship property</a></li>
  <li><a href="#ex14-22">Example 14-22: Reference attribute and
  RDF</a></li>
  <li><a href="#ex14-23">Example 14-23: Augmentation element and
  RDF</a></li>
  </ul>
  <hr />
  <h1 id="appendix-f-table-of-figures">Appendix F. Table of figures</h1>
  <ul>
  <li><a href="#fig2-1">Figure 2-1: User roles and activities</a></li>
  <li><a href="#fig3-1">Figure 3-1: Message types, message formats, and
  messages</a></li>
  <li><a href="#fig3-6">Figure 3-6: NIEM communities and data
  models</a></li>
  <li><a href="#fig3-7">Figure 3-7: High-level view of the NIEM
  metamodel</a></li>
  <li><a href="#fig3-8">Figure 3-8: Message, message model, and
  metamodel relationships</a></li>
  <li><a href="#fig3-11">Figure 3-11: Knowledge graph portrayal of a
  NIEM model and message</a></li>
  <li><a href="#fig4-1">Figure 4-1: The NIEM metamodel</a></li>
  <li><a href="#fig4-4">Figure 4-4: Model class diagram</a></li>
  <li><a href="#fig4-6">Figure 4-6: Namespace class diagram</a></li>
  <li><a href="#fig4-10">Figure 4-10: Component class diagram</a></li>
  <li><a href="#fig4-14">Figure 4-14: Class, AnyPropertyAssociation, and
  ChildPropertyAssociation class diagram</a></li>
  <li><a href="#fig4-27">Figure 4-27: Property class diagram</a></li>
  <li><a href="#fig4-35">Figure 4-35: Datatype classes</a></li>
  <li><a href="#fig4-52">Figure 4-52: Augmentation class
  diagram</a></li>
  <li><a href="#fig14-21">Figure 14-21: RDF graph for a relationship
  property</a></li>
  </ul>
  <hr />
  <h1 id="appendix-g-table-of-tables">Appendix G. Table of tables</h1>
  <ul>
  <li><a href="#tab2-2">Table 2-2: Relevant document sections by user
  role</a></li>
  <li><a href="#tab4-2">Table 4-2: Definition of columns in metamodel
  property tables</a></li>
  <li><a href="#tab4-3">Table 4-3: Definition of columns in CMF-XSD
  mapping tables</a></li>
  <li><a href="#tab4-5">Table 4-5: Properties of the Model object
  class</a></li>
  <li><a href="#tab4-7">Table 4-7: Properties of the Namespace object
  class</a></li>
  <li><a href="#tab4-9">Table 4-9: Namespace object properties in CMF
  and XSD</a></li>
  <li><a href="#tab4-11">Table 4-11: Properties of the Component
  abstract class</a></li>
  <li><a href="#tab4-13">Table 4-13: Component object properties in CMF
  and XSD</a></li>
  <li><a href="#tab4-15">Table 4-15: Properties of the Class object
  class</a></li>
  <li><a href="#tab4-16">Table 4-16: ReferenceCode code list</a></li>
  <li><a href="#tab4-19">Table 4-19: Class object object properties in
  CMF and XSD</a></li>
  <li><a href="#tab4-22">Table 4-22: Properties of the
  ChildPropertyAssociation object class</a></li>
  <li><a href="#tab4-24">Table 4-24: ChildPropertyAssociation object
  properties in CMF and XSD</a></li>
  <li><a href="#tab4-26">Table 4-26: ChildPropertyAssociation object
  properties in CMF and XSD</a></li>
  <li><a href="#tab4-28">Table 4-28: Properties of the Property abstract
  class</a></li>
  <li><a href="#tab4-29">Table 4-29: Properties of the ObjectProperty
  object class</a></li>
  <li><a href="#tab4-31">Table 4-31: ObjectProperty object properties in
  CMF and XSD</a></li>
  <li><a href="#tab4-32">Table 4-32: Properties of the DataProperty
  object class</a></li>
  <li><a href="#tab4-34">Table 4-34: DataProperty object properties in
  CMF and XSD</a></li>
  <li><a href="#tab4-37">Table 4-37: Properties of the List object class
  </a></li>
  <li><a href="#tab4-39">Table 4-39: List object properties in CMF and
  XSD</a></li>
  <li><a href="#tab4-40">Table 4-40: Properties of the Union object
  class</a></li>
  <li><a href="#tab4-42">Table 4-42: Union object properties in CMF and
  XSD</a></li>
  <li><a href="#tab4-43">Table 4-43: Properties of the Restriction
  object class</a></li>
  <li><a href="#tab4-45">Table 4-45: Restriction object properties in
  CMF and XSD</a></li>
  <li><a href="#tab4-46">Table 4-46: Properties of the Facet object
  class</a></li>
  <li><a href="#tab4-48">Table 4-48: Facet object properties in CMF and
  XSD</a></li>
  <li><a href="#tab4-49">Table 4-49: Properties of the CodeListBinding
  object class</a></li>
  <li><a href="#tab4-51">Table 4-51: CodeListBinding object properties
  in CMF and XSD</a></li>
  <li><a href="#tab4-53">Table 4-53: Properties of the Augmentation
  object class</a></li>
  <li><a href="#tab4-56">Table 4-56: GlobalClassCode code list</a></li>
  <li><a href="#tab4-57">Table 4-57: Augmentation object properties in
  CMF and XSD</a></li>
  <li><a href="#tab4-72">Table 4-72: Properties of the LocalTerm object
  class</a></li>
  <li><a href="#tab4-74">Table 4-74: LocalTerm object properties in CMF
  and XSD</a></li>
  <li><a href="#tab4-75">Table 4-75: Properties of the TextType object
  class</a></li>
  <li><a href="#tab7-1">Table 7-1: Property representation
  terms</a></li>
  <li><a href="#tab14-2">Table 14-2: Meaning of NIEM data</a></li>
  <li><a href="#tab14-3">Table 14-3: Correspondence of model terminology
  in CMF, XSD, and RDF</a></li>
  </ul>
  <hr />
  <h1 id="appendix-h-acknowledgments">Appendix H. Acknowledgments</h1>
  <h2 id="h1-participants">H.1 Participants</h2>
  <p>The following individuals have participated in the creation of this
  specification and are gratefully acknowledged:</p>
  <p><strong>Project-name OP Members:</strong></p>
  <table>
  <thead>
  <tr>
  <th style="text-align: left;">First Name</th>
  <th style="text-align: left;">Last Name</th>
  <th style="text-align: left;">Company</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td style="text-align: left;">Aubrey</td>
  <td style="text-align: left;">Beach</td>
  <td style="text-align: left;">JS J6</td>
  </tr>
  <tr>
  <td style="text-align: left;">Brad</td>
  <td style="text-align: left;">Bollinger</td>
  <td style="text-align: left;">Ernst &amp; Young</td>
  </tr>
  <tr>
  <td style="text-align: left;">James</td>
  <td style="text-align: left;">Cabral</td>
  <td style="text-align: left;">Individual</td>
  </tr>
  <tr>
  <td style="text-align: left;">Tom</td>
  <td style="text-align: left;">Carlson</td>
  <td style="text-align: left;">GTRI</td>
  </tr>
  <tr>
  <td style="text-align: left;">Chuck</td>
  <td style="text-align: left;">Chipman</td>
  <td style="text-align: left;">GTRI</td>
  </tr>
  <tr>
  <td style="text-align: left;">Mike</td>
  <td style="text-align: left;">Douklias</td>
  <td style="text-align: left;">JS J6</td>
  </tr>
  <tr>
  <td style="text-align: left;">Katherine</td>
  <td style="text-align: left;">Escobar</td>
  <td style="text-align: left;">JS J6</td>
  </tr>
  <tr>
  <td style="text-align: left;">Lavdjola</td>
  <td style="text-align: left;">Farrington</td>
  <td style="text-align: left;">JS J6</td>
  </tr>
  <tr>
  <td style="text-align: left;">Dave</td>
  <td style="text-align: left;">Hardy</td>
  <td style="text-align: left;">JS J6</td>
  </tr>
  <tr>
  <td style="text-align: left;">Mike</td>
  <td style="text-align: left;">Hulme</td>
  <td style="text-align: left;">Unisys</td>
  </tr>
  <tr>
  <td style="text-align: left;">Eric</td>
  <td style="text-align: left;">Jahn</td>
  <td style="text-align: left;">Alexandria Consulting</td>
  </tr>
  <tr>
  <td style="text-align: left;">Dave</td>
  <td style="text-align: left;">Kemp</td>
  <td style="text-align: left;">NSA</td>
  </tr>
  <tr>
  <td style="text-align: left;">Vamsi</td>
  <td style="text-align: left;">Kondannagari</td>
  <td style="text-align: left;">Integral Fed</td>
  </tr>
  <tr>
  <td style="text-align: left;">Shunda</td>
  <td style="text-align: left;">Louis</td>
  <td style="text-align: left;">JS J6</td>
  </tr>
  <tr>
  <td style="text-align: left;">Peter</td>
  <td style="text-align: left;">Madruga</td>
  <td style="text-align: left;">GTRI</td>
  </tr>
  <tr>
  <td style="text-align: left;">Christina</td>
  <td style="text-align: left;">Medlin</td>
  <td style="text-align: left;">GTRI</td>
  </tr>
  <tr>
  <td style="text-align: left;">Joe</td>
  <td style="text-align: left;">Mierwa</td>
  <td style="text-align: left;">Mission Critical Partners</td>
  </tr>
  <tr>
  <td style="text-align: left;">April</td>
  <td style="text-align: left;">Mitchell</td>
  <td style="text-align: left;">FBI</td>
  </tr>
  <tr>
  <td style="text-align: left;">Carl</td>
  <td style="text-align: left;">Nelson</td>
  <td style="text-align: left;">RISS</td>
  </tr>
  <tr>
  <td style="text-align: left;">Scott</td>
  <td style="text-align: left;">Renner</td>
  <td style="text-align: left;">MITRE</td>
  </tr>
  <tr>
  <td style="text-align: left;">Beth</td>
  <td style="text-align: left;">Smalley</td>
  <td style="text-align: left;">JS J6</td>
  </tr>
  <tr>
  <td style="text-align: left;">Duncan</td>
  <td style="text-align: left;">Sparrell</td>
  <td style="text-align: left;">sFractal</td>
  </tr>
  <tr>
  <td style="text-align: left;">Jennifer</td>
  <td style="text-align: left;">Stathakis</td>
  <td style="text-align: left;">NIST</td>
  </tr>
  <tr>
  <td style="text-align: left;">Stephen</td>
  <td style="text-align: left;">Sullivan</td>
  <td style="text-align: left;">JS J6</td>
  </tr>
  <tr>
  <td style="text-align: left;">Josh</td>
  <td style="text-align: left;">Wilson</td>
  <td style="text-align: left;">FBI</td>
  </tr>
  </tbody>
  </table>
  <hr />
  <h1 id="appendix-i-notices">Appendix I. Notices</h1>
  <p>(This required section should not be altered, except to modify the
  license information in the second paragraph if needed.)</p>
  <p>Copyright © OASIS Open 2025. All Rights Reserved.</p>
  <p>All capitalized terms in the following text have the meanings
  assigned to them in the OASIS Intellectual Property Rights Policy (the
  "OASIS IPR Policy"). The full <a
  href="https://www.oasis-open.org/policies-guidelines/ipr/">Policy</a>
  may be found at the OASIS website.</p>
  <p>This specification is published under <a
  href="https://creativecommons.org/licenses/by/4.0/legalcode">Attribution
  4.0 International (CC BY 4.0)</a>. Code associated with this
  specification is provided under <a
  href="https://www.apache.org/licenses/LICENSE-2.0">Apache License
  2.0</a>.</p>
  <p>All contributions made to this project have been made under the <a
  href="https://www.oasis-open.org/policies-guidelines/open-projects-process/#individual-cla-exhibit">OASIS
  Contributor License Agreement (CLA)</a>.</p>
  <p>For information on whether any patents have been disclosed that may
  be essential to implementing this specification, and any offers of
  patent licensing terms, please refer to the <a
  href="https://github.com/niemopen/oasis-open-project/blob/main/IPR-STATEMENT.md">NIEMOpen
  IPR Statement</a> page.</p>
  <p>This document and translations of it may be copied and furnished to
  others, and derivative works that comment on or otherwise explain it
  or assist in its implementation may be prepared, copied, published,
  and distributed, in whole or in part, without restriction of any kind,
  provided that the above copyright notice and this section are included
  on all such copies and derivative works. However, this document itself
  may not be modified in any way, including by removing the copyright
  notice or references to OASIS, except as needed for the purpose of
  developing any document or deliverable produced by an OASIS Open
  Project (in which case the rules applicable to copyrights, as set
  forth in the OASIS IPR Policy, must be followed) or as required to
  translate it into languages other than English.</p>
  <p>The limited permissions granted above are perpetual and will not be
  revoked by OASIS or its successors or assigns.</p>
  <p>This document and the information contained herein is provided on
  an "AS IS" basis and OASIS DISCLAIMS ALL WARRANTIES, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
  INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY
  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
  PURPOSE. OASIS AND ITS MEMBERS WILL NOT BE LIABLE FOR ANY DIRECT,
  INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF
  THIS DOCUMENT OR ANY PART THEREOF.</p>
  <p>As stated in the OASIS IPR Policy, the following three paragraphs
  in brackets apply to OASIS Standards Final Deliverable documents
  (Project Specifications, OASIS Standards, or Approved Errata).</p>
  <p>[OASIS requests that any OASIS Party or any other party that
  believes it has patent claims that would necessarily be infringed by
  implementations of this OASIS Standards Final Deliverable, to notify
  OASIS TC Administrator and provide an indication of its willingness to
  grant patent licenses to such patent claims in a manner consistent
  with the IPR Mode of the OASIS Open Project that produced this
  deliverable.]</p>
  <p>[OASIS invites any party to contact the OASIS TC Administrator if
  it is aware of a claim of ownership of any patent claims that would
  necessarily be infringed by implementations of this OASIS Standards
  Final Deliverable by a patent holder that is not willing to provide a
  license to such patent claims in a manner consistent with the IPR Mode
  of the OASIS Open Project that produced this OASIS Standards Final
  Deliverable. OASIS may include such claims on its website, but
  disclaims any obligation to do so.]</p>
  <p>[OASIS takes no position regarding the validity or scope of any
  intellectual property or other rights that might be claimed to pertain
  to the implementation or use of the technology described in this OASIS
  Standards Final Deliverable or the extent to which any license under
  such rights might or might not be available; neither does it represent
  that it has made any effort to identify any such rights. Information
  on OASIS' procedures with respect to rights in any document or
  deliverable produced by an OASIS Open Project can be found on the
  OASIS website. Copies of claims of rights made available for
  publication and any assurances of licenses to be made available, or
  the result of an attempt made to obtain a general license or
  permission for the use of such proprietary rights by implementers or
  users of this OASIS Standards Final Deliverable, can be obtained from
  the OASIS TC Administrator. OASIS makes no representation that any
  information or list of intellectual property rights will at any time
  be complete, or that any claims in such list are, in fact, Essential
  Claims.]</p>
  <p>The name "OASIS" is a trademark of <a
  href="https://www.oasis-open.org/">OASIS</a>, the owner and developer
  of this specification, and should be used only to refer to the
  organization and its official outputs. OASIS welcomes reference to,
  and implementation and use of, specifications, while reserving the
  right to enforce its marks against misleading uses. Please see
  https://www.oasis-open.org/policies-guidelines/trademark/ for above
  guidance.</p>
  <!-- OASIS style -->

  <style>
  body {
    margin-left: 3pc;
    margin-right: 3pc;
    font-family: LiberationSans, Arial, Helvetica, sans-serif;
    font-size:12pt;
    line-height:1.2;
  }
  html {overflow-x:auto }

  h1 { font-size:18pt; }
  h2 { font-size:14pt; }
  h3 { font-size:13pt; }
  h4 { font-size:12pt; }
  h5 { font-size:11pt; }
  h1,h2,h3,h4,h5 { 
    font-family: LiberationSans, Arial, Helvetica, sans-serif;
    font-weight: bold;
    margin:8pt 0;
    color: #446CAA
  }
  h6 { 
    font-size:12pt; 
    line-height:1.0; 
    font-family: LiberationSans, Arial, Helvetica, sans-serif;
    font-weight: bold;
    margin:0pt;
  }
  hr{page-break-before: always;}
  table {
    border-collapse:collapse;
    border-spacing:0;
    width:100%;
    display:table;
    font-size:12pt;
    margin-top: 6pt;
  }
  table, th, td {
    border: 1pt solid black;
    padding:6pt 6pt;
    text-align:left;
    /*vertical-align:top; -- this causes alignment errors in cells with italics */
  }
  th {
    color:#ffffff;
    background-color: #446CAA;
  }
  pre {
    background-color:#f0f0f0;
    padding: 6px;
  }
  code {
    font-family: "Source Code Pro", "Liberation Mono", monospace;
    font-size: 9pt;
    background-color: #eeeeee;
    color: #111;
    padding: 2px 5px;
    white-space: nowrap;
    border: none;
  }

  /* Block code (unchanged) */
  pre {
    font-family: "Source Code Pro", "Liberation Mono", monospace;
    font-size: 8pt;
    line-height: 1.4;
    background-color: #eeeeee;
    color: #111;
    white-space: pre;
    overflow-x: auto;
    box-sizing: border-box;
    padding: 10px;
    margin: 10px 0;
    border: 1px solid #ccc;
    border-radius: 6px;
    width: 100%;
    max-width: 100vw;
  }

  /* remove ALL layout from nested code */
  pre code {
    font-family: inherit;
    font-size: 8pt;
    line-height: inherit;
    background: inherit;
    overflow-x: auto;
    color: inherit;
    white-space: inherit;
    padding: 0;
    margin: 0;
    border: none;
    width: 100%;
    max-width: 100vw;
    display: block;
  }
  blockquote {
    padding-left: 10px;
    padding-right: 10px;
    border-left: solid lightgray 6px;
  }

  li { margin: 3px 0; }
  </style>

  <!-- NDR style customizations -->

  <style>
  a { font-family: LiberationSans, Arial, Helvetica, sans-serif; text-decoration: none; color: #000; background-color: #FFF; }
  a [href^="#ex"] { white-space: nowrap; }
  a[href]:hover { color: #000; background-color:rgb(212, 225, 250); }
  a.uri { font-family: "Source Code Pro", "Liberation Mono", monospace; font-size: 11pt; white-space: nowrap; }
  span.termRef::before { font-weight: bold; content: "·"; }
  span.termRef::after { font-weight:bold; content: "·"; }
  span.highlight { background-color: #F9FAD4; }
  span.codeComment { background-color: #F9FAD4; font-family: LiberationSans, Arial, Helvetica, sans-serif; }
  img { display:block; margin-left:auto; margin-right:auto; height:auto; }
  figcaption { text-align:center; font-style:italic; margin-top: 10pt; margin-bottom:10pt; }
  caption { text-align:center; font-style:italic; margin-top: 10pt; margin-bottom:10pt; }
  h1 { border-bottom: none; }
  h2,h3,h4 { margin-top:18pt; border: none; }
  code { font-size: 11pt; }
  pre > code { font-size: 9pt; margin-left:auto; margin-right:auto; }
  table { margin-bottom: 12pt; }
  code.uri { background: none; white-space: normal; overflow-wrap: break-word; word-break: break-all; hyphens: none; }
  code.uri-nb { background: none; white-space: nowrap; overflow-wrap: normal; word-wrap: normal; }
  #TOC > ul > li { margin-bottom: 1em; }
  </style>
</body>
